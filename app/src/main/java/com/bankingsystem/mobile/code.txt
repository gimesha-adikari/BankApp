================================================================================
FILE: App.kt  (size: 157 bytes)
================================================================================
package com.bankingsystem.mobile

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class App : Application()

================================================================================
FILE: app/di/AccountsBindings.kt  (size: 545 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.features.accounts.domain.repository.AccountRepository
import com.bankingsystem.mobile.features.accounts.integration.repository.AccountRepositoryImpl
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ViewModelComponent

@Module
@InstallIn(ViewModelComponent::class)
abstract class AccountsBindings {
    @Binds
    abstract fun bindAccountRepository(impl: AccountRepositoryImpl): AccountRepository
}

================================================================================
FILE: app/di/AuthBindings.kt  (size: 518 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.features.auth.domain.repository.UserRepository
import com.bankingsystem.mobile.features.auth.integration.repository.UserRepositoryImpl
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ViewModelComponent

@Module
@InstallIn(ViewModelComponent::class)
abstract class AuthBindings {
    @Binds
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
}

================================================================================
FILE: app/di/CustomerBindings.kt  (size: 587 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.features.customer.domain.repository.CustomerRepository
import com.bankingsystem.mobile.features.customer.integration.repository.CustomerRepositoryImpl
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class CustomerBindings {
    @Binds
    @Singleton
    abstract fun bindCustomerRepository(impl: CustomerRepositoryImpl): CustomerRepository
}

================================================================================
FILE: app/di/KycBindings.kt  (size: 510 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.features.kyc.domain.repository.KycRepository
import com.bankingsystem.mobile.features.kyc.integration.repository.KycRepositoryImpl
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ViewModelComponent

@Module
@InstallIn(ViewModelComponent::class)
abstract class KycBindings {
    @Binds
    abstract fun bindKycRepository(impl: KycRepositoryImpl): KycRepository
}

================================================================================
FILE: app/di/NetworkModule.kt  (size: 5052 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.BuildConfig
import com.bankingsystem.mobile.core.modules.common.storage.AuthStore
import com.bankingsystem.mobile.core.modules.common.storage.TokenManager
import com.bankingsystem.mobile.features.customer.integration.remote.api.CustomerApi
import com.bankingsystem.mobile.features.kyc.integration.remote.api.KycApi
import com.bankingsystem.mobile.features.wallet.integration.api.WalletApi
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.Response
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory
import java.util.concurrent.TimeUnit


@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @IODispatcher
    fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO

    class UnauthorizedHandler(
        private val tokenManager: TokenManager,
        private val io: CoroutineDispatcher
    ) {
        fun onUnauthorized() {
            CoroutineScope(io).launch {
                runCatching { tokenManager.clearToken() }
            }
        }
    }

    class AuthInterceptor(
        private val authStore: AuthStore,
        private val unauthorizedHandler: UnauthorizedHandler
    ) : Interceptor {
        override fun intercept(chain: Interceptor.Chain): Response {
            val token: String? = runBlocking { authStore.getToken() }

            val req = chain.request().newBuilder().apply {
                if (!token.isNullOrBlank()) {
                    header("Authorization", "Bearer $token")
                }
            }.build()

            val resp = chain.proceed(req)
            if (resp.code == 401) {
                unauthorizedHandler.onUnauthorized()
            }
            return resp
        }
    }

    @Provides
    @Singleton
    fun provideUnauthorizedHandler(
        tokenManager: TokenManager,
        @IODispatcher io: CoroutineDispatcher
    ) = UnauthorizedHandler(tokenManager, io)

    @Provides
    @Singleton
    fun provideOkHttp(
        authStore: AuthStore,
        unauthorizedHandler: UnauthorizedHandler
    ): OkHttpClient =
        OkHttpClient.Builder()
            .connectTimeout(60, TimeUnit.SECONDS)
            .readTimeout(120, TimeUnit.SECONDS)
            .writeTimeout(120, TimeUnit.SECONDS)
            .retryOnConnectionFailure(true)
            .addInterceptor(AuthInterceptor(authStore, unauthorizedHandler))
            .addInterceptor(
                HttpLoggingInterceptor().apply {
                    level = if (BuildConfig.DEBUG)
                        HttpLoggingInterceptor.Level.BASIC
                    else
                        HttpLoggingInterceptor.Level.NONE
                }
            )
            .build()


    @Provides
    @Singleton
    fun provideMoshi(): Moshi =
        Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()

    @Provides
    @Singleton
    fun provideRetrofit(
        client: OkHttpClient,
        moshi: Moshi
    ): Retrofit =
        Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .addConverterFactory(MoshiConverterFactory.create(moshi))
            .client(client)
            .build()

    @Provides
    fun provideAuthApi(retrofit: Retrofit): com.bankingsystem.mobile.features.auth.integration.remote.api.AuthApi =
        retrofit.create(com.bankingsystem.mobile.features.auth.integration.remote.api.AuthApi::class.java)

    @Provides
    fun provideAccountsApi(retrofit: Retrofit): com.bankingsystem.mobile.features.accounts.integration.remote.api.AccountsApi =
        retrofit.create(com.bankingsystem.mobile.features.accounts.integration.remote.api.AccountsApi::class.java)

    @Provides
    fun provideProfileApi(retrofit: Retrofit)
            : com.bankingsystem.mobile.features.profile.integration.remote.api.ProfileApi =
        retrofit.create(com.bankingsystem.mobile.features.profile.integration.remote.api.ProfileApi::class.java)

    @Provides
    @Singleton
    fun provideKycApi(retrofit: Retrofit): KycApi =
        retrofit.create(KycApi::class.java)

    @Provides
    @Singleton
    fun provideCustomerApi(retrofit: Retrofit): CustomerApi =
        retrofit.create(CustomerApi::class.java)

    @Provides
    @Singleton
    fun provideWalletApi(retrofit: Retrofit): WalletApi =
        retrofit.create(WalletApi::class.java)
}

================================================================================
FILE: app/di/ProfileBindings.kt  (size: 583 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.features.profile.domain.repository.ProfileRepository
import com.bankingsystem.mobile.features.profile.integration.repository.ProfileRepositoryImpl
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class ProfileBindings {

    @Binds
    @Singleton
    abstract fun bindProfileRepository(impl: ProfileRepositoryImpl): ProfileRepository
}

================================================================================
FILE: app/di/Qualifiers.kt  (size: 159 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import javax.inject.Qualifier

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class IODispatcher

================================================================================
FILE: app/di/StorageModule.kt  (size: 1202 bytes)
================================================================================
// di/StorageModule.kt
package com.bankingsystem.mobile.app.di

import android.content.Context
import com.bankingsystem.mobile.core.modules.common.storage.AuthStore
import com.bankingsystem.mobile.core.modules.common.storage.AuthStoreImpl
import com.bankingsystem.mobile.core.modules.common.storage.DefaultAccountStore
import com.bankingsystem.mobile.core.modules.common.storage.DefaultAccountStoreImpl
import com.bankingsystem.mobile.core.modules.common.storage.TokenManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object StorageModule {

    @Provides @Singleton
    fun provideTokenManager(@ApplicationContext ctx: Context): TokenManager =
        TokenManager(ctx)

    @Provides @Singleton
    fun provideAuthStore(tokenManager: TokenManager): AuthStore =
        AuthStoreImpl(tokenManager)

    @Provides @Singleton
    fun provideDefaultAccountStore(@ApplicationContext ctx: Context): DefaultAccountStore =
        DefaultAccountStoreImpl(ctx)
}

================================================================================
FILE: app/di/WalletBindings.kt  (size: 534 bytes)
================================================================================
package com.bankingsystem.mobile.app.di

import com.bankingsystem.mobile.features.wallet.domain.repository.WalletRepository
import com.bankingsystem.mobile.features.wallet.integration.repository.WalletRepositoryImpl
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ViewModelComponent

@Module
@InstallIn(ViewModelComponent::class)
abstract class WalletBindings {
    @Binds
    abstract fun bindWalletRepository(impl: WalletRepositoryImpl): WalletRepository
}

================================================================================
FILE: app/navigation/AppNavHost.kt  (size: 6503 bytes)
================================================================================
package com.bankingsystem.mobile.app.navigation

import android.os.Build
import androidx.annotation.RequiresApi
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.bankingsystem.mobile.features.accounts.interfaces.ui.AccountTransactionsRoute
import com.bankingsystem.mobile.features.accounts.interfaces.ui.AccountsRoute
import com.bankingsystem.mobile.features.accounts.interfaces.ui.MyAccountsRoute
import com.bankingsystem.mobile.features.customer.interfaces.ui.CustomerRegistrationScreen
import com.bankingsystem.mobile.features.home.interfaces.ui.BankHomeRoute
import com.bankingsystem.mobile.features.home.interfaces.ui.BankHomeScreen
import com.bankingsystem.mobile.features.kyc.interfaces.ui.KycRoute
import com.bankingsystem.mobile.features.kyc.interfaces.ui.KycStatusRoute
import com.bankingsystem.mobile.features.payments.interfaces.ui.PaymentsRoute
import com.bankingsystem.mobile.features.profile.interfaces.ui.ProfileRoute
import com.bankingsystem.mobile.features.settings.interfaces.ui.SettingsScreen
import com.bankingsystem.mobile.features.wallet.interfaces.ui.WalletRoute

@RequiresApi(Build.VERSION_CODES.O)
@ExperimentalMaterial3Api
@Composable
fun AppNavHost(
    userName: String,
    onLogout: () -> Unit,
    nav: NavHostController = rememberNavController()
) {
    NavHost(navController = nav, startDestination = Routes.HOME) {

        /* ---------- Home ---------- */
        composable(Routes.HOME) {
            BankHomeRoute(
                userName = userName,
                selectedItem = "Home",
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

        /* ---------- Profile ---------- */
        composable(Routes.PROFILE) {
            ProfileRoute(
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

        /* ---------- Settings ---------- */
        composable(Routes.SETTINGS) {
            SettingsScreen(
                onLogout = onLogout,
                onBack = { nav.navigateUp() }
            )
        }

        /* ---------- Accounts: My list ---------- */
        composable(Routes.ACCOUNTS_MY) {
            MyAccountsRoute(
                userName = userName,
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

        /* ---------- Accounts: Open account ---------- */
        composable(Routes.ACCOUNTS_OPEN) {
            AccountsRoute(
                userName = userName,
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

        /* ---------- Accounts: Transactions ---------- */
        composable(
            route = Routes.ACCOUNT_TX,
            arguments = listOf(
                navArgument("accountId") { type = NavType.StringType },
                navArgument("accNo") { type = NavType.StringType; defaultValue = "" }
            )
        ) { backStack ->
            val id = backStack.arguments?.getString("accountId").orEmpty()
            val accNo = backStack.arguments?.getString("accNo").orEmpty()

            AccountTransactionsRoute(
                userName = userName,
                accountId = id,
                accountNumber = accNo.ifBlank { null },
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) },
                onBack = { nav.navigateUp() }
            )
        }

        /* ---------- KYC ---------- */
        composable(Routes.KYC) {
            KycRoute(
                userName = userName,
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

        /* ---------- KYC STATUS---------- */
        composable(Routes.KYC_STATUS) {
            KycStatusRoute(
                userName = userName,
                selectedItem = "KYC Status",
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) },
            )
        }


        /* ---------- Payments ---------- */
        composable(Routes.PAYMENTS) {
            PaymentsRoute(
                userName = userName,
                selectedItem = "Payments",
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

        /* ---------- Customer Registration ---------- */
        composable(Routes.CUSTOMER_REG) {
            CustomerRegistrationScreen(
                onBack = { nav.navigateUp() },
                onDone = { nav.popBackStack(Routes.HOME, inclusive = false) }
            )
        }

        /* ---------- Wallet ---------- */
        composable(WalletRoutes.WALLET_HOME){
            WalletRoute(
                userName = userName,
                selectedItem = "Wallet",
                onNavigate = { label -> navigateByLabel(nav, label, onLogout) }
            )
        }

    }
}

/* ---------------- helpers ---------------- */

private fun navigateByLabel(
    nav: NavHostController,
    label: String,
    onLogout: () -> Unit
) {
    if (label.contains('/')) {
        if (label.startsWith("accounts/tx/")) {
            nav.navigate(label)
        } else {
            nav.navigate(label) {
                popUpTo(nav.graph.startDestinationId) { saveState = true }
                launchSingleTop = true
                restoreState = true
            }
        }
        return
    }

    val route = when (label) {
        "Home" -> Routes.HOME
        "Wallet" -> WalletRoutes.WALLET_HOME
        "Profile" -> Routes.PROFILE
        "Settings" -> Routes.SETTINGS
        "Payments" -> Routes.PAYMENTS
        "My Accounts" -> Routes.ACCOUNTS_MY
        "Open Account" -> Routes.ACCOUNTS_OPEN
        "Verify Identity", Routes.KYC -> Routes.KYC
        "KYC Status" -> Routes.KYC_STATUS
        "Logout" -> { onLogout(); return }
        else -> return
    }

    nav.navigate(route) {
        popUpTo(nav.graph.startDestinationId) { saveState = true }
        launchSingleTop = true
        restoreState = true
    }
}

================================================================================
FILE: app/navigation/Routes.kt  (size: 1237 bytes)
================================================================================
package com.bankingsystem.mobile.app.navigation

import android.net.Uri

object Routes {
    const val HOME = "home"
    const val PROFILE = "profile"
    const val PAYMENTS = "payments"
    const val SETTINGS = "settings"
    const val ACCOUNTS_MY = "accounts/my"
    const val ACCOUNTS_OPEN = "accounts/open"
    const val ACCOUNT_TX    = "accounts/tx/{accountId}?accNo={accNo}"
    const val KYC = "kyc"
    const val KYC_STATUS = "kyc/status"
    const val CUSTOMER_REG = "customer/register"

    fun accountTx(accountId: String, accountNumber: String? = null): String {
        val accNo = accountNumber?.let { Uri.encode(it) } ?: ""
        return "accounts/tx/$accountId?accNo=$accNo"
    }
}

object WalletRoutes {
    const val WALLET_HOME = "wallet"
    const val WALLET_CARDS = "wallet/cards"
    const val WALLET_ADD_CARD = "wallet/cards/add"
    const val WALLET_QR_SCAN = "wallet/qr/scan"
    const val WALLET_QR_CONFIRM = "wallet/qr/confirm"
    const val WALLET_RELOAD = "wallet/reload"
    const val WALLET_BILLERS = "wallet/billers"
    const val WALLET_BILL_PAY = "wallet/bill/pay"
    const val WALLET_PROCESSING = "wallet/processing"
    const val WALLET_RESULT = "wallet/result"
}

================================================================================
FILE: collect_text_and_tree.py  (size: 8580 bytes)
================================================================================
#!/usr/bin/env python3
"""
Collect project sources:
- For text files: write full contents (preserved exactly).
- For non-text files: write only the file name (marked as UNSUPPORTED/BINARY).
- Finally, append an ASCII tree of the entire project.

Defaults: no pruning; includes hidden files; deterministic order.
You can pass --exclude to skip specific directories, and --followlinks to follow symlinks.
"""

from __future__ import annotations
import argparse
import os
from pathlib import Path
import sys
import tokenize
import mimetypes
import re

HEADER_LINE = "=" * 80

# Common text-like extensions (still fallback to detection)
TEXT_EXTS = {
    # Code
    ".java", ".kt", ".kts",
    ".js", ".ts", ".jsx", ".tsx",
    ".css", ".scss", ".sass", ".less",
    ".html", ".htm", ".vue", ".svelte",
    ".c", ".h", ".cpp", ".hpp", ".cc", ".m", ".mm",
    ".go", ".rs", ".php", ".rb", ".swift", ".scala",
    ".cs", ".sql", ".sh", ".bat", ".ps1",
    # Config / data / docs
    ".json", ".yaml", ".yml", ".xml", ".ini", ".cfg", ".conf", ".properties",
    ".toml", ".gradle", ".md", ".txt", ".env", ".csv", ".tsv",
    ".gitignore", ".gitattributes", ".editorconfig", ".prettierrc", ".eslintrc",
}

# MIME types we treat as text even if extension is unknown
TEXT_MIME_PREFIXES = ("text/",)
TEXT_MIME_EXTRAS = {
    "application/json", "application/xml", "application/javascript",
    "application/x-sh", "application/x-shellscript",
}

# ---------- Helpers ----------

def _has_bom(head: bytes) -> str | None:
    if head.startswith(b"\xef\xbb\xbf"):
        return "utf-8-sig"
    if head.startswith(b"\xff\xfe\x00\x00"):
        return "utf-32-le"
    if head.startswith(b"\x00\x00\xfe\xff"):
        return "utf-32-be"
    if head.startswith(b"\xff\xfe"):
        return "utf-16-le"
    if head.startswith(b"\xfe\xff"):
        return "utf-16-be"
    return None

def _looks_binary(head: bytes) -> bool:
    if b"\x00" in head:
        return True
    # Consider control chars (excluding \t, \n, \r, \f) as "weird"
    weird = sum(1 for b in head if (b < 32 and b not in (9,10,13,12)))
    # If > 30% are weird control bytes, likely binary
    return (len(head) > 0) and (weird / len(head) > 0.30)

def is_text_file(path: Path, sample_bytes: int = 4096) -> bool:
    # 1) Obvious by extension
    if path.suffix.lower() in TEXT_EXTS:
        return True
    # 2) BOM presence indicates text
    try:
        with path.open("rb") as f:
            head = f.read(sample_bytes)
    except Exception:
        return False
    if _has_bom(head):
        return True
    # 3) MIME hint
    mt, _ = mimetypes.guess_type(path.as_posix())
    if mt and (mt.startswith(TEXT_MIME_PREFIXES) or mt in TEXT_MIME_EXTRAS):
        return True
    # 4) Heuristic on bytes
    return not _looks_binary(head)

def read_text_preserve(path: Path) -> str:
    """Read text preserving original characters as closely as possible."""
    # Respect PEP 263 for Python files
    if path.suffix.lower() == ".py":
        with tokenize.open(path) as f:
            return f.read()
    # BOM-aware for common Unicode encodings
    with path.open("rb") as fb:
        head = fb.read(4)
    enc = _has_bom(head)
    if enc:
        return path.read_text(encoding=enc)
    # Try UTF-8, then Latin-1 (lossless mapping of bytes 0–255)
    try:
        return path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return path.read_text(encoding="latin-1")

def write_header(out, rel_path: Path, size_bytes: int | None, marker: str | None = None):
    out.write(f"{HEADER_LINE}\n")
    out.write(f"FILE: {rel_path.as_posix()}")
    if size_bytes is not None:
        out.write(f"  (size: {size_bytes} bytes)")
    if marker:
        out.write(f"  [{marker}]")
    out.write("\n")
    out.write(f"{HEADER_LINE}\n")

def iter_all_files(root: Path, followlinks: bool, exclude_dirs: set[str]) -> list[Path]:
    files: list[Path] = []
    for dirpath, dirnames, filenames in os.walk(root, followlinks=followlinks):
        # prune
        if exclude_dirs:
            dirnames[:] = [d for d in dirnames if d not in exclude_dirs]
        for fn in filenames:
            files.append(Path(dirpath) / fn)
    files.sort(key=lambda p: p.as_posix().lower())
    return files

def tree_lines(root: Path, exclude_dirs: set[str], followlinks: bool) -> list[str]:
    """Produce an ASCII tree (dirs then files, sorted)."""
    lines: list[str] = [f"{root.name}/"]
    def walk(d: Path, prefix: str):
        try:
            entries = sorted(
                [e for e in d.iterdir() if e.name not in exclude_dirs],
                key=lambda p: (not p.is_dir(), p.name.lower())
            )
        except PermissionError:
            return
        for i, e in enumerate(entries):
            last = (i == len(entries) - 1)
            conn = "└── " if last else "├── "
            if e.is_dir():
                lines.append(f"{prefix}{conn}{e.name}/")
                walk(e, prefix + ("    " if last else "│   "))
            else:
                lines.append(f"{prefix}{conn}{e.name}")
    walk(root, "")
    return lines

# ---------- Main logic ----------

def collect(root: Path, out_path: Path, followlinks: bool, exclude_dirs: set[str]) -> int:
    root = root.resolve()
    out_path = out_path.resolve()

    if not root.exists() or not root.is_dir():
        print(f"Error: root '{root}' is not a directory.", file=sys.stderr)
        return 2

    files = iter_all_files(root, followlinks, exclude_dirs)
    if not files:
        print("No files found.", file=sys.stderr)
        return 1

    out_path.parent.mkdir(parents=True, exist_ok=True)

    text_count = 0
    bin_count = 0

    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        for f in files:
            # Don't include the output file itself
            try:
                if f.resolve() == out_path:
                    continue
            except Exception:
                pass

            rel = f.relative_to(root)
            try:
                size_bytes = f.stat().st_size
            except Exception:
                size_bytes = None

            try:
                if is_text_file(f):
                    content = read_text_preserve(f)
                    write_header(out, rel, size_bytes)
                    out.write(content)
                    if not content.endswith("\n"):
                        out.write("\n")
                    out.write("\n")
                    text_count += 1
                else:
                    write_header(out, rel, size_bytes, marker="UNSUPPORTED/NON-TEXT")
                    out.write("(contents omitted)\n\n")
                    bin_count += 1
            except Exception as e:
                write_header(out, rel, size_bytes, marker="READ_ERROR")
                out.write(f"[ERROR] {e}\n\n")
                bin_count += 1

        # ---- Append project tree ----
        out.write(f"{HEADER_LINE}\nPROJECT TREE\n{HEADER_LINE}\n")
        for line in tree_lines(root, exclude_dirs, followlinks):
            out.write(line + "\n")

        # ---- Summary ----
        out.write("\n")
        out.write(f"{HEADER_LINE}\nSUMMARY\n{HEADER_LINE}\n")
        out.write(f"Text files written : {text_count}\n")
        out.write(f"Non-text/omitted   : {bin_count}\n")
        out.write(f"Total files seen   : {len(files)}\n")

    print(f"Done. Text={text_count}  Non-text={bin_count}  Wrote -> '{out_path}'.")
    return 0

def parse_excludes(argv_excludes: list[str]) -> set[str]:
    # Accept bare directory names (top-level names) to prune while walking
    return set(argv_excludes or [])

def main():
    ap = argparse.ArgumentParser(description="Write all text files, list non-text files, then append project tree.")
    ap.add_argument("root", type=Path, help="Root directory to scan")
    ap.add_argument("output", type=Path, help="Output .txt file")
    ap.add_argument("--exclude", nargs="*", default=[], help="Directory names to exclude (space-separated)")
    ap.add_argument("--followlinks", action="store_true", help="Follow symlinked directories")
    args = ap.parse_args()

    exclude_dirs = parse_excludes(args.exclude)
    rc = collect(args.root, args.output, followlinks=args.followlinks, exclude_dirs=exclude_dirs)
    sys.exit(rc)

if __name__ == "__main__":
    main()

================================================================================
FILE: core/modules/common/designsystem/AppBackground.kt  (size: 3102 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.blur
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.R
import com.bankingsystem.mobile.core.modules.common.designsystem.theme.AppBg
import com.bankingsystem.mobile.core.modules.common.designsystem.theme.BrandIndigo
import com.bankingsystem.mobile.core.modules.common.designsystem.theme.BrandRose
import kotlin.math.min

@Composable
fun AppBackground(modifier: Modifier = Modifier) {
    var size by remember { mutableStateOf(IntSize.Zero) }

    Box(
        modifier = modifier
            .fillMaxSize()
            .onSizeChanged { size = it }
    ) {
        Box(Modifier.fillMaxSize().background(AppBg))

        Image(
            painter = painterResource(id = R.drawable.bg_bank),
            contentDescription = null,
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .fillMaxSize()
                .blur(24.dp)
        )

        Box(Modifier.fillMaxSize().background(AppBg.copy(alpha = 0.65f)))

        if (size.width > 0 && size.height > 0) {
            val w = size.width.toFloat()
            val h = size.height.toFloat()
            val minDim = min(w, h)

            val glowIndigo = Brush.radialGradient(
                colors = listOf(BrandIndigo.copy(alpha = 0.12f), Color.Transparent),
                center = Offset(w * 0.18f, h * 0.18f),
                radius = minDim * 0.9f
            )
            val glowRose = Brush.radialGradient(
                colors = listOf(BrandRose.copy(alpha = 0.08f), Color.Transparent),
                center = Offset(w * 0.88f, h * 0.62f),
                radius = minDim
            )
            val topHighlight = Brush.verticalGradient(
                colors = listOf(BrandIndigo.copy(alpha = 0.08f), Color.Transparent),
                startY = 0f,
                endY = h * 0.32f
            )
            val vignette = Brush.radialGradient(
                colors = listOf(Color.Transparent, AppBg.copy(alpha = 0.78f)),
                center = Offset(w * 0.5f, h * 0.55f),
                radius = minDim * 0.95f
            )

            Box(Modifier.fillMaxSize().background(glowIndigo).blur(2.dp))
            Box(Modifier.fillMaxSize().background(glowRose).blur(2.dp))
            Box(Modifier.fillMaxSize().background(topHighlight))
            Box(Modifier.fillMaxSize().background(vignette))
        }
    }
}

================================================================================
FILE: core/modules/common/designsystem/Button.kt  (size: 1568 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun ButtonPrimary(
    modifier: Modifier = Modifier,
    onClick: () -> Unit,
    enabled: Boolean = true,
    content: @Composable RowScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Button(
        onClick = onClick,
        enabled = enabled,
        modifier = modifier,
        shape = MaterialTheme.shapes.large,
        border = BorderStroke(1.dp, cs.primary.copy(alpha = 0.35f)),
        elevation = ButtonDefaults.buttonElevation(
            defaultElevation = 6.dp,
            pressedElevation = 2.dp,
            focusedElevation = 8.dp,
            hoveredElevation = 8.dp,
            disabledElevation = 0.dp
        ),
        colors = ButtonDefaults.buttonColors(
            containerColor = cs.primary,
            contentColor = cs.onPrimary,
            disabledContainerColor = cs.primary.copy(alpha = 0.5f),
            disabledContentColor = cs.onPrimary.copy(alpha = 0.7f)
        ),
        contentPadding = PaddingValues(horizontal = 18.dp, vertical = 14.dp),
        content = content
    )
}

================================================================================
FILE: core/modules/common/designsystem/FadingAppBackground.kt  (size: 2128 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.EaseOutCubic
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.core.modules.common.designsystem.theme.BrandIndigo
import kotlinx.coroutines.launch

@Composable
fun FadingAppBackground() {
    val alpha = remember { Animatable(0f) }
    val scale = remember { Animatable(1.02f) }
    val lift = remember { Animatable(12f) }
    val overlay = remember { Animatable(0.22f) }
    val density = LocalDensity.current

    LaunchedEffect(Unit) {
        launch { alpha.animateTo(1f, tween(900, easing = EaseOutCubic)) }
        launch { scale.animateTo(1f, tween(900, easing = EaseOutCubic)) }
        launch { lift.animateTo(0f, tween(900, easing = EaseOutCubic)) }
        launch { overlay.animateTo(0f, tween(1200)) }
    }

    Box(Modifier.fillMaxSize()) {
        AppBackground(
            modifier = Modifier.graphicsLayer(
                alpha = alpha.value,
                scaleX = scale.value,
                scaleY = scale.value,
                translationY = with(density) { lift.value.dp.toPx() }
            )
        )
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(
                    Brush.verticalGradient(
                        0f to BrandIndigo.copy(alpha = overlay.value),
                        1f to Color.Transparent
                    )
                )
        )
    }
}

================================================================================
FILE: core/modules/common/designsystem/InputField.kt  (size: 4314 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation

@Composable
fun InputField(
    modifier: Modifier = Modifier,
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String = "",
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    isPassword: Boolean = false,
    isError: Boolean = false,
    supportingText: @Composable (() -> Unit)? = null,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    leadingIcon: (@Composable () -> Unit)? = null,
    trailingIcon: (@Composable () -> Unit)? = null
) {
    var passwordVisible by remember { mutableStateOf(false) }
    val cs = MaterialTheme.colorScheme

    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        label = { Text(label) },
        placeholder = { Text(placeholder) },
        singleLine = true,
        modifier = modifier,
        keyboardOptions = keyboardOptions,
        isError = isError,
        enabled = enabled,
        readOnly = readOnly,
        visualTransformation = if (isPassword && !passwordVisible) PasswordVisualTransformation() else VisualTransformation.None,
        leadingIcon = leadingIcon,
        trailingIcon = if (isPassword) {
            {
                val image = if (passwordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff
                IconButton(onClick = { passwordVisible = !passwordVisible }) {
                    Icon(
                        imageVector = image,
                        contentDescription = if (passwordVisible) "Hide password" else "Show password"
                    )
                }
            }
        } else trailingIcon,
        supportingText = supportingText,
        shape = MaterialTheme.shapes.medium,
        colors = TextFieldDefaults.colors(
            focusedTextColor = cs.onSurface,
            unfocusedTextColor = cs.onSurface,
            disabledTextColor = cs.onSurface.copy(alpha = 0.5f),
            errorTextColor = cs.onErrorContainer,
            focusedContainerColor = cs.surface,
            unfocusedContainerColor = cs.surface,
            disabledContainerColor = cs.surface.copy(alpha = 0.6f),
            errorContainerColor = cs.surface,
            cursorColor = cs.primary,
            focusedIndicatorColor = cs.primary,
            unfocusedIndicatorColor = cs.outline.copy(alpha = 0.6f),
            disabledIndicatorColor = cs.outline.copy(alpha = 0.3f),
            errorIndicatorColor = cs.error,
            focusedLabelColor = cs.primary,
            unfocusedLabelColor = cs.onSurfaceVariant,
            disabledLabelColor = cs.onSurfaceVariant.copy(alpha = 0.6f),
            errorLabelColor = cs.error,
            focusedPlaceholderColor = cs.onSurfaceVariant,
            unfocusedPlaceholderColor = cs.onSurfaceVariant,
            focusedLeadingIconColor = cs.onSurfaceVariant,
            unfocusedLeadingIconColor = cs.onSurfaceVariant,
            disabledLeadingIconColor = cs.onSurfaceVariant.copy(alpha = 0.5f),
            errorLeadingIconColor = cs.error,
            focusedTrailingIconColor = cs.onSurfaceVariant,
            unfocusedTrailingIconColor = cs.onSurfaceVariant,
            disabledTrailingIconColor = cs.onSurfaceVariant.copy(alpha = 0.5f),
            errorTrailingIconColor = cs.error
        )
    )
}

================================================================================
FILE: core/modules/common/designsystem/PasswordTextField.kt  (size: 2047 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import android.annotation.SuppressLint
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation

@Composable
fun PasswordTextField(
    value: String,
    onValueChange: (String) -> Unit,
    label: String,
    isError: Boolean,
    supportingText: @Composable (() -> Unit)? = null,
    @SuppressLint("ModifierParameter") modifier: Modifier = Modifier
) {
    var passwordVisible by rememberSaveable { mutableStateOf(false) }

    ValidatedTextField(
        value = value,
        onValueChange = onValueChange,
        label = label,
        isError = isError,
        modifier = modifier,
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
        visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
        trailingIcon = {
            val image = if (passwordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff
            IconButton(onClick = { passwordVisible = !passwordVisible }) {
                Icon(
                    imageVector = image,
                    contentDescription = if (passwordVisible) "Hide password" else "Show password"
                )
            }
        },
        supportingText = supportingText
    )
}

================================================================================
FILE: core/modules/common/designsystem/PrimaryButton.kt  (size: 2386 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import android.annotation.SuppressLint
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.width
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun PrimaryButton(
    onClick: () -> Unit,
    enabled: Boolean = true,
    @SuppressLint("ModifierParameter") modifier: Modifier = Modifier,
    text: String,
    loading: Boolean = false,
    leadingIcon: (@Composable () -> Unit)? = null,
    trailingIcon: (@Composable () -> Unit)? = null
) {
    val cs = MaterialTheme.colorScheme
    Button(
        onClick = onClick,
        enabled = enabled && !loading,
        modifier = modifier.fillMaxWidth(),
        shape = MaterialTheme.shapes.large,
        elevation = ButtonDefaults.buttonElevation(
            defaultElevation = 2.dp,
            pressedElevation = 6.dp,
            disabledElevation = 0.dp
        ),
        colors = ButtonDefaults.buttonColors(
            containerColor = cs.primary,
            contentColor = cs.onPrimary,
            disabledContainerColor = cs.primary.copy(alpha = 0.5f),
            disabledContentColor = cs.onPrimary.copy(alpha = 0.7f)
        ),
        content = {
            if (loading) {
                CircularProgressIndicator(strokeWidth = 2.dp)
            } else {
                Row(horizontalArrangement = Arrangement.Center) {
                    if (leadingIcon != null) {
                        leadingIcon()
                        Spacer(Modifier.width(8.dp))
                    }
                    Text(text = text, style = MaterialTheme.typography.labelLarge)
                    if (trailingIcon != null) {
                        Spacer(Modifier.width(8.dp))
                        trailingIcon()
                    }
                }
            }
        }
    )
}

================================================================================
FILE: core/modules/common/designsystem/QuickAction.kt  (size: 2926 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsPressedAsState
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.FilledTonalButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.unit.dp

@Composable
fun QuickAction(
    text: String,
    icon: ImageVector,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    loading: Boolean = false
) {
    val cs = MaterialTheme.colorScheme
    val interaction = remember { MutableInteractionSource() }
    val pressed by interaction.collectIsPressedAsState()
    val scale by animateFloatAsState(if (pressed) 0.98f else 1f, tween(120), label = "press-scale")

    FilledTonalButton(
        onClick = onClick,
        enabled = enabled && !loading,
        interactionSource = interaction,
        shape = MaterialTheme.shapes.medium,
        contentPadding = PaddingValues(horizontal = 14.dp, vertical = 12.dp),
        elevation = ButtonDefaults.buttonElevation(
            defaultElevation = 2.dp,
            pressedElevation = 6.dp,
            disabledElevation = 0.dp
        ),
        colors = ButtonDefaults.filledTonalButtonColors(
            containerColor = cs.secondaryContainer,
            contentColor = cs.onSecondaryContainer,
            disabledContainerColor = cs.secondaryContainer.copy(alpha = 0.55f),
            disabledContentColor = cs.onSecondaryContainer.copy(alpha = 0.6f)
        ),
        modifier = modifier
            .fillMaxWidth()
            .height(54.dp)
            .graphicsLayer {
                scaleX = scale
                scaleY = scale
            }
    ) {
        Icon(icon, contentDescription = null)
        Spacer(Modifier.width(10.dp))
        Text(text, style = MaterialTheme.typography.labelLarge)
        if (loading) {
            Spacer(Modifier.width(10.dp))
            CircularProgressIndicator(strokeWidth = 2.dp)
        }
    }
}

================================================================================
FILE: core/modules/common/designsystem/SelectionCard.kt  (size: 3258 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.DividerDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun SectionCard(
    title: String,
    subtitle: String? = null,
    modifier: Modifier = Modifier,
    showDivider: Boolean = true,
    headerAction: (@Composable () -> Unit)? = null,
    contentPadding: PaddingValues = PaddingValues(16.dp),
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    val shape = RoundedCornerShape(20.dp)
    val borderBrush = Brush.linearGradient(
        listOf(
            cs.primary.copy(alpha = 0.25f),
            cs.primary.copy(alpha = 0.10f),
            cs.primary.copy(alpha = 0.04f)
        )
    )
    val tintBrush = Brush.linearGradient(
        listOf(
            cs.primary.copy(alpha = 0.06f),
            cs.primary.copy(alpha = 0.00f)
        )
    )

    Surface(
        modifier = modifier
            .border(BorderStroke(1.dp, borderBrush), shape)
            .background(tintBrush, shape),
        shape = shape,
        tonalElevation = 1.dp,
        shadowElevation = 10.dp,
        color = MaterialTheme.colorScheme.surface
    ) {
        Column(Modifier.padding(contentPadding)) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.SemiBold,
                color = cs.onSurface
            )
            if (subtitle != null) {
                Spacer(Modifier.height(2.dp))
                Text(
                    text = subtitle,
                    style = MaterialTheme.typography.bodyMedium,
                    color = cs.onSurface.copy(alpha = 0.7f)
                )
            }
            if (showDivider) {
                Spacer(Modifier.height(10.dp))
                HorizontalDivider(
                    thickness = DividerDefaults.Thickness,
                    color = cs.outlineVariant.copy(alpha = 0.7f)
                )
                Spacer(Modifier.height(10.dp))
            } else {
                Spacer(Modifier.height(8.dp))
            }
            if (headerAction != null) {
                headerAction()
                Spacer(Modifier.height(8.dp))
            }
            content()
        }
    }
}

================================================================================
FILE: core/modules/common/designsystem/Sidebar.kt  (size: 8707 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsPressedAsState
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ExitToApp
import androidx.compose.material.icons.filled.AccountBalance
import androidx.compose.material.icons.filled.AddCircle
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Payment
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Verified
import androidx.compose.material.icons.filled.Wallet
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.NavigationDrawerItem
import androidx.compose.material3.NavigationDrawerItemDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun Sidebar(
    menuItems: List<Pair<String, ImageVector>> = listOf(
        "Home" to Icons.Filled.Home,
        "Wallet" to Icons.Filled.CreditCard,
        "My Accounts" to Icons.Filled.AccountBalance,
        "Open Account" to Icons.Filled.AddCircle,
        "Payments" to Icons.Filled.Payment,
        "Verify Identity" to Icons.Filled.Verified,
        "KYC Status" to Icons.Filled.Verified,
        "Profile" to Icons.Filled.Person,
        "Settings" to Icons.Filled.Settings,
        "Logout" to Icons.AutoMirrored.Filled.ExitToApp
    ),
    selectedItem: String = "Home",
    onItemClick: (String) -> Unit = {},
    userName: String? = null
) {
    val cs = MaterialTheme.colorScheme
    val panelGradient = Brush.verticalGradient(listOf(Color(0xFF0E1020), Color(0xFF0C0F1A)))
    val lightIndigo = Color(0xFFA5B4FC)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(panelGradient)
            .padding(horizontal = 14.dp, vertical = 18.dp)
    ) {
        SidebarHeader(userName = userName)
        Spacer(Modifier.height(12.dp))

        val itemShape = RoundedCornerShape(12.dp)
        val colors = NavigationDrawerItemDefaults.colors(
            selectedContainerColor = Color.Transparent,
            unselectedContainerColor = Color.Transparent,
            selectedIconColor = Color.White,
            unselectedIconColor = lightIndigo.copy(alpha = 0.95f),
            selectedTextColor = Color.White,
            unselectedTextColor = lightIndigo
        )

        menuItems.forEach { (title, icon) ->
            val selected = title == selectedItem
            val interaction = remember { MutableInteractionSource() }
            val pressed = interaction.collectIsPressedAsState().value

            val selectedBrush = Brush.linearGradient(
                listOf(cs.primary.copy(alpha = 0.16f), cs.primary.copy(alpha = 0.08f))
            )
            val border = if (selected)
                BorderStroke(1.dp, Brush.linearGradient(listOf(cs.primary.copy(0.35f), cs.primary.copy(0.12f))))
            else null

            Surface(
                modifier = Modifier
                    .fillMaxWidth()
                    .graphicsLayer {
                        val s = if (pressed) 0.98f else 1f
                        scaleX = s; scaleY = s
                    }
                    .padding(vertical = 3.dp),
                shape = itemShape,
                tonalElevation = 0.dp,
                shadowElevation = if (selected) 10.dp else 0.dp,
                border = border,
                color = Color.Transparent
            ) {
                Box(
                    modifier = Modifier.background(
                        brush = if (selected) selectedBrush else SolidColor(Color.Transparent),
                        shape = itemShape
                    )
                ) {
                    if (selected) {
                        Box(
                            Modifier
                                .padding(vertical = 10.dp)
                                .width(3.dp)
                                .height(24.dp)
                                .align(Alignment.CenterStart)
                                .background(cs.primary)
                        )
                    }
                    NavigationDrawerItem(
                        label = { Text(title, style = MaterialTheme.typography.bodyLarge) },
                        selected = selected,
                        onClick = { onItemClick(title) },
                        icon = {
                            val isLogout = title.equals("Logout", true)
                            val iconBg =
                                if (isLogout) cs.tertiary.copy(alpha = 0.15f)
                                else if (selected) cs.primary.copy(alpha = 0.12f)
                                else Color.Transparent
                            Box(
                                modifier = Modifier
                                    .size(34.dp)
                                    .clip(CircleShape)
                                    .background(iconBg),
                                contentAlignment = Alignment.Center
                            ) {
                                val tint =
                                    if (isLogout) cs.tertiary
                                    else if (selected) Color.White
                                    else lightIndigo
                                Icon(icon, contentDescription = title, tint = tint)
                            }
                        },
                        colors = colors,
                        shape = itemShape,
                        interactionSource = interaction,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(52.dp)
                            .padding(horizontal = 6.dp)
                    )
                }
            }
        }

        Spacer(Modifier.weight(1f))
        Text("© 2025 MyBank Inc.", color = cs.onSurfaceVariant, style = MaterialTheme.typography.bodySmall)
    }
}

@Composable
private fun SidebarHeader(userName: String?) {
    val cs = MaterialTheme.colorScheme
    val gradient = Brush.linearGradient(listOf(cs.primary, cs.primaryContainer))

    Surface(shape = RoundedCornerShape(16.dp), tonalElevation = 0.dp, shadowElevation = 8.dp) {
        Row(
            Modifier
                .background(gradient)
                .padding(horizontal = 14.dp, vertical = 16.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(RoundedCornerShape(12.dp))
                    .background(cs.onPrimary.copy(alpha = 0.18f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(Icons.Filled.AccountBalance, contentDescription = null, tint = cs.onPrimary)
            }
            Spacer(Modifier.width(10.dp))
            Column {
                Text(
                    "MyBank",
                    color = cs.onPrimary,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Text(
                    if (userName.isNullOrBlank()) "Secure Banking Panel" else "Hi, $userName",
                    color = cs.onPrimary.copy(alpha = 0.85f),
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

================================================================================
FILE: core/modules/common/designsystem/theme/Color.kt  (size: 1400 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem.theme

import androidx.compose.ui.graphics.Color

val PrimaryBlue = Color(0xFF393854)
val PrimaryLightBlue = Color(0xFF545287)
val SecondaryBlue = Color(0xFF282747)

val SecondaryYellow = Color(0xFFFFD75A)
val SecondaryLightYellow = Color(0xFFFFC107)

val PrimaryRed = Color(0xFFFF0056)

val White = Color(0xFFFFFFFF)
val Black = Color(0xFF000000)

val NeutralGray = Color(0xFF6B7280)
val LightGray = Color(0xFFF3F4F6)

val LightBackground = Color(0xFFF6F7FF)
val LightSurface = Color(0xFFFFFFFF)

val DarkBackground = Color(0xFF121212)
val DarkSurface = Color(0xFF1E1E1E)
val DarkPrimary = Color(0xFF90CAF9)
val DarkOnPrimary = Color(0xFF0D253F)

val PinkContainerLight = Color(0xFFFFE0E7)
val PinkOnContainerLight = Color(0xFF5D0B22)

val SurfaceVariantDark = Color(0xFF2A2A2A)
val OnSurfaceVariantDark = Color(0xFFB9B9B9)

val PrimaryContainerLight = Color(0xFFE0E7FF)
val OnPrimaryContainerLight = Color(0xFF1B1F54)
val SurfaceVariantLight = Color(0xFFECEEF8)

val AppBg = Color(0xFF0B0B12)
val BrandIndigo = Color(0xFF6366F1)
val BrandRose = Color(0xFFEF4444)
val Glass = Color(0x14FFFFFF)
val GlassStrong = Color(0x26FFFFFF)
val OnGlass = Color(0xFFEFF1FF)
val Border = Color(0x1AFFFFFF)

val PrimaryContainerDark = Color(0xFF2D2F6A)
val OnPrimaryContainerDark = Color(0xFFE0E7FF)

================================================================================
FILE: core/modules/common/designsystem/theme/Fonts.kt  (size: 1063 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem.theme

import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.googlefonts.Font
import androidx.compose.ui.text.googlefonts.GoogleFont
import androidx.compose.ui.text.googlefonts.GoogleFont.Provider
import com.bankingsystem.mobile.R

val GoogleFontsProvider = Provider(
    providerAuthority = "com.google.android.gms.fonts",
    providerPackage = "com.google.android.gms",
    certificates = R.array.com_google_android_gms_fonts_certs
)

private val Manrope = GoogleFont("Manrope")

val AppFontFamily = FontFamily(
    Font(googleFont = Manrope, fontProvider = GoogleFontsProvider, weight = FontWeight.Normal),
    Font(googleFont = Manrope, fontProvider = GoogleFontsProvider, weight = FontWeight.Medium),
    Font(googleFont = Manrope, fontProvider = GoogleFontsProvider, weight = FontWeight.SemiBold),
    Font(googleFont = Manrope, fontProvider = GoogleFontsProvider, weight = FontWeight.Bold),
)

================================================================================
FILE: core/modules/common/designsystem/theme/Theme.kt  (size: 4543 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Shapes
import androidx.compose.material3.Typography
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

private val LightColors = lightColorScheme(
    primary = BrandIndigo,
    onPrimary = White,
    primaryContainer = PrimaryContainerLight,
    onPrimaryContainer = OnPrimaryContainerLight,
    secondary = BrandIndigo,
    onSecondary = White,
    secondaryContainer = PrimaryContainerLight,
    onSecondaryContainer = OnPrimaryContainerLight,
    tertiary = BrandRose,
    onTertiary = White,
    tertiaryContainer = PinkContainerLight,
    onTertiaryContainer = PinkOnContainerLight,
    background = LightBackground,
    onBackground = Color(0xFF14151A),
    surface = LightSurface,
    onSurface = Color(0xFF14151A),
    surfaceVariant = SurfaceVariantLight,
    onSurfaceVariant = NeutralGray,
    outline = NeutralGray,
    outlineVariant = NeutralGray.copy(alpha = 0.45f),
    error = Color(0xFFB00020),
    onError = White,
    errorContainer = Color(0xFFFCDADA),
    onErrorContainer = Color(0xFF410002),
    inverseSurface = Color(0xFF2E2F36),
    inverseOnSurface = White,
    inversePrimary = BrandIndigo,
    scrim = Color(0x99000000),
    surfaceTint = BrandIndigo
)

private val DarkColors = darkColorScheme(
    primary = BrandIndigo,
    onPrimary = White,
    primaryContainer = PrimaryContainerDark,
    onPrimaryContainer = OnPrimaryContainerDark,
    secondary = BrandIndigo,
    onSecondary = White,
    secondaryContainer = PrimaryContainerDark,
    onSecondaryContainer = OnPrimaryContainerDark,
    tertiary = BrandRose,
    onTertiary = White,
    tertiaryContainer = BrandRose,
    onTertiaryContainer = White,
    background = AppBg,
    onBackground = OnGlass,
    surface = Glass,
    onSurface = OnGlass,
    surfaceVariant = GlassStrong,
    onSurfaceVariant = OnGlass,
    outline = Border,
    outlineVariant = Border,
    error = Color(0xFFCF6679),
    onError = Black,
    errorContainer = Color(0xFF8C1D18),
    onErrorContainer = Color(0xFFFFDAD6),
    inverseSurface = OnGlass,
    inverseOnSurface = AppBg,
    inversePrimary = BrandIndigo,
    scrim = Color(0x99000000),
    surfaceTint = BrandIndigo
)

val BankTypography = Typography(
    headlineMedium = TextStyle(fontWeight = FontWeight.SemiBold, fontSize = 26.sp, fontFamily = AppFontFamily),
    titleLarge = TextStyle(fontWeight = FontWeight.SemiBold, fontSize = 22.sp, fontFamily = AppFontFamily),
    titleMedium = TextStyle(fontWeight = FontWeight.Medium, fontSize = 18.sp, letterSpacing = 0.15.sp, fontFamily = AppFontFamily),
    bodyLarge = TextStyle(fontWeight = FontWeight.Normal, fontSize = 16.sp, letterSpacing = 0.4.sp, fontFamily = AppFontFamily),
    bodyMedium = TextStyle(fontWeight = FontWeight.Normal, fontSize = 14.sp, letterSpacing = 0.25.sp, fontFamily = AppFontFamily),
    labelLarge = TextStyle(fontWeight = FontWeight.SemiBold, fontSize = 14.sp, fontFamily = AppFontFamily)
)

val BankShapes = Shapes(
    small = RoundedCornerShape(10.dp),
    medium = RoundedCornerShape(16.dp),
    large = RoundedCornerShape(24.dp)
)

@Composable
fun BankAppTheme(
    useDarkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = false,
    content: @Composable () -> Unit
) {
    val colors =
        if (dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val ctx = LocalContext.current
            if (useDarkTheme) dynamicDarkColorScheme(ctx) else dynamicLightColorScheme(ctx)
        } else {
            if (useDarkTheme) DarkColors else LightColors
        }

    MaterialTheme(
        colorScheme = colors,
        typography = BankTypography,
        shapes = BankShapes,
        content = content
    )
}

================================================================================
FILE: core/modules/common/designsystem/ValidatedTextField.kt  (size: 2610 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.designsystem

import android.annotation.SuppressLint
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.VisualTransformation

@Composable
fun ValidatedTextField(
    value: String,
    onValueChange: (String) -> Unit,
    label: String,
    isError: Boolean,
    keyboardOptions: KeyboardOptions,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    trailingIcon: @Composable (() -> Unit)? = null,
    supportingText: @Composable (() -> Unit)? = null,
    leadingIcon: @Composable (() -> Unit)? = null,
    placeholder: String = "",
    enabled: Boolean = true,
    readOnly: Boolean = false,
    singleLine: Boolean = true,
    maxLines: Int = 1,
    @SuppressLint("ModifierParameter") modifier: Modifier = Modifier
) {
    val cs = MaterialTheme.colorScheme
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        label = { Text(label) },
        placeholder = if (placeholder.isNotEmpty()) { { Text(placeholder) } } else null,
        isError = isError,
        enabled = enabled,
        readOnly = readOnly,
        singleLine = singleLine,
        maxLines = maxLines,
        modifier = modifier.fillMaxWidth(),
        keyboardOptions = keyboardOptions,
        visualTransformation = visualTransformation,
        leadingIcon = leadingIcon,
        trailingIcon = trailingIcon,
        supportingText = supportingText,
        shape = MaterialTheme.shapes.medium,
        colors = TextFieldDefaults.colors(
            focusedIndicatorColor = cs.primary,
            unfocusedIndicatorColor = cs.outline,
            disabledIndicatorColor = cs.outline.copy(alpha = 0.4f),
            errorIndicatorColor = cs.error,
            cursorColor = cs.primary,
            focusedLabelColor = cs.primary,
            unfocusedLabelColor = cs.onSurfaceVariant,
            focusedTrailingIconColor = cs.primary,
            unfocusedTrailingIconColor = cs.onSurfaceVariant,
            errorTrailingIconColor = cs.error,
            focusedPlaceholderColor = cs.onSurfaceVariant,
            unfocusedPlaceholderColor = cs.onSurfaceVariant
        )
    )
}

================================================================================
FILE: core/modules/common/network/AuthErrorInterceptor.kt  (size: 448 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.network

import okhttp3.Interceptor
import okhttp3.Response
class AuthErrorInterceptor(
    private val onUnauthorized: () -> Unit = {}
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val response = chain.proceed(chain.request())
        if (response.code == 401) {
            onUnauthorized()
        }
        return response
    }
}

================================================================================
FILE: core/modules/common/network/AuthInterceptor.kt  (size: 852 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.network

import com.bankingsystem.mobile.core.modules.common.storage.AuthStore
import kotlinx.coroutines.runBlocking
import okhttp3.Interceptor
import okhttp3.Response

class AuthInterceptor(
    private val store: AuthStore
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val original = chain.request()

        if (original.header("Authorization") != null) {
            return chain.proceed(original)
        }

        val token = runBlocking { store.getToken() }
        val req = if (!token.isNullOrBlank()) {
            original.newBuilder()
                .addHeader("Authorization", "Bearer $token")
                .build()
        } else {
            original
        }

        return chain.proceed(req)
    }
}

================================================================================
FILE: core/modules/common/security/EncryptionHelper.kt  (size: 1620 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.security

import android.util.Base64
import java.nio.ByteBuffer
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec

object EncryptionHelper {
    private const val TRANSFORMATION = "AES/GCM/NoPadding"
    private const val IV_SIZE = 12
    private const val TAG_SIZE = 128

    fun encrypt(plainText: String, secretKey: SecretKey): String {
        val cipher = Cipher.getInstance(TRANSFORMATION)
        cipher.init(Cipher.ENCRYPT_MODE, secretKey)

        val iv = cipher.iv
        val encryptedBytes = cipher.doFinal(plainText.toByteArray(Charsets.UTF_8))

        val byteBuffer = ByteBuffer.allocate(iv.size + encryptedBytes.size)
        byteBuffer.put(iv)
        byteBuffer.put(encryptedBytes)
        val cipherMessage = byteBuffer.array()

        return Base64.encodeToString(cipherMessage, Base64.NO_WRAP)
    }

    fun decrypt(cipherText: String, secretKey: SecretKey): String {
        val cipherMessage = Base64.decode(cipherText, Base64.NO_WRAP)

        val byteBuffer = ByteBuffer.wrap(cipherMessage)
        val iv = ByteArray(IV_SIZE)
        byteBuffer.get(iv)
        val encryptedBytes = ByteArray(byteBuffer.remaining())
        byteBuffer.get(encryptedBytes)

        val cipher = Cipher.getInstance(TRANSFORMATION)
        val spec = GCMParameterSpec(TAG_SIZE, iv)
        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)

        val decryptedBytes = cipher.doFinal(encryptedBytes)
        return String(decryptedBytes, Charsets.UTF_8)
    }
}

================================================================================
FILE: core/modules/common/security/KeyStoreManager.kt  (size: 1311 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.security

import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import java.security.KeyStore
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey

object KeyStoreManager {
    private const val ANDROID_KEY_STORE = "AndroidKeyStore"
    private const val KEY_ALIAS = "token_encryption_key"

    fun getSecretKey(): SecretKey {
        val keyStore = KeyStore.getInstance(ANDROID_KEY_STORE).apply { load(null) }

        val existingKey = keyStore.getKey(KEY_ALIAS, null) as? SecretKey
        if (existingKey != null) {
            return existingKey
        }

        val keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE)
        val keyGenParameterSpec = KeyGenParameterSpec.Builder(
            KEY_ALIAS,
            KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
        ).apply {
            setBlockModes(KeyProperties.BLOCK_MODE_GCM)
            setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
            setKeySize(256)
            setUserAuthenticationRequired(false)
        }.build()

        keyGenerator.init(keyGenParameterSpec)
        return keyGenerator.generateKey()
    }
}

================================================================================
FILE: core/modules/common/storage/AuthStore.kt  (size: 200 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.storage

interface AuthStore {
    suspend fun getToken(): String?
    suspend fun saveAuth(token: String, username: String, role: String)
}

================================================================================
FILE: core/modules/common/storage/AuthStoreImpl.kt  (size: 354 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.storage

class AuthStoreImpl(
    private val tokenManager: TokenManager
) : AuthStore {
    override suspend fun getToken(): String? = tokenManager.getToken()

    override suspend fun saveAuth(token: String, username: String, role: String) {
        tokenManager.saveToken(token)
    }
}

================================================================================
FILE: core/modules/common/storage/DefaultAccountStore.kt  (size: 1282 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.storage

import android.content.Context
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject

interface DefaultAccountStore {
    val defaultAccountId: Flow<String?>
    suspend fun setDefaultAccountId(id: String)
    suspend fun clear()
}
private val Context.defaultAccountDataStore by preferencesDataStore(name = "default_account")

class DefaultAccountStoreImpl @Inject constructor(
    @ApplicationContext private val context: Context
) :DefaultAccountStore {
    private val KEY_DEFAULT_ID = stringPreferencesKey("default_account_id")

    override val defaultAccountId: Flow<String?> =
        context.defaultAccountDataStore.data.map { it[KEY_DEFAULT_ID] }

    override suspend fun setDefaultAccountId(id: String) {
        context.defaultAccountDataStore.edit { it[KEY_DEFAULT_ID] = id }
    }

    override suspend fun clear() {
        context.defaultAccountDataStore.edit { it.remove(KEY_DEFAULT_ID) }
    }
}

================================================================================
FILE: core/modules/common/storage/LockPreferences.kt  (size: 922 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.storage

import android.content.Context
import androidx.core.content.edit

class LockPreferences(private val context: Context) {

    private val prefs = context.getSharedPreferences("app_lock_prefs", Context.MODE_PRIVATE)

    companion object {
        private const val KEY_LOCK_ENABLED = "lock_enabled"
        private const val KEY_LOCK_PIN = "lock_pin"
    }

    fun isLockEnabled(): Boolean = prefs.getBoolean(KEY_LOCK_ENABLED, false)

    fun setLockEnabled(enabled: Boolean) {
        prefs.edit { putBoolean(KEY_LOCK_ENABLED, enabled) }
    }

    fun savePin(pin: String) {
        prefs.edit { putString(KEY_LOCK_PIN, pin) }
        setLockEnabled(true)
    }

    fun getPin(): String? = prefs.getString(KEY_LOCK_PIN, null)

    fun clearLock() {
        prefs.edit { remove(KEY_LOCK_ENABLED).remove(KEY_LOCK_PIN) }
    }
}

================================================================================
FILE: core/modules/common/storage/TokenManager.kt  (size: 1843 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.storage

import android.content.Context
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import com.bankingsystem.mobile.core.modules.common.security.EncryptionHelper
import com.bankingsystem.mobile.core.modules.common.security.KeyStoreManager
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import javax.crypto.SecretKey

private val Context.dataStore by preferencesDataStore(name = "secure_prefs")

class TokenManager(private val context: Context) {

    private val TOKEN_KEY = stringPreferencesKey("encrypted_token")
    private val secretKey: SecretKey by lazy { KeyStoreManager.getSecretKey() }

    suspend fun saveToken(token: String) {
        val encryptedToken = EncryptionHelper.encrypt(token, secretKey)
        context.dataStore.edit { prefs -> prefs[TOKEN_KEY] = encryptedToken }
    }

    suspend fun getToken(): String? {
        val prefs = context.dataStore.data.first()
        val encrypted = prefs[TOKEN_KEY] ?: return null
        return try {
            EncryptionHelper.decrypt(encrypted, secretKey)
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    val tokenFlow: Flow<String?> = context.dataStore.data.map { prefs ->
        prefs[TOKEN_KEY]?.let { encrypted ->
            try {
                EncryptionHelper.decrypt(encrypted, secretKey)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }

    suspend fun clearToken() {
        context.dataStore.edit { prefs -> prefs.remove(TOKEN_KEY) }
    }
}

================================================================================
FILE: core/modules/common/util/BiometricHelper.kt  (size: 1702 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.util

import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity

fun showBiometricPrompt(
    activity: FragmentActivity,
    onSuccess: () -> Unit,
    onFailure: () -> Unit,
    onError: (String) -> Unit
) {
    val biometricManager = BiometricManager.from(activity)
    if (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_WEAK or BiometricManager.Authenticators.DEVICE_CREDENTIAL) != BiometricManager.BIOMETRIC_SUCCESS) {
        onError("Biometric authentication not available")
        return
    }

    val executor = ContextCompat.getMainExecutor(activity)
    val prompt = BiometricPrompt(
        activity, executor,
        object : BiometricPrompt.AuthenticationCallback() {
            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                onSuccess()
            }

            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                onError(errString.toString())
            }

            override fun onAuthenticationFailed() {
                onFailure()
            }
        })

    val promptInfo = BiometricPrompt.PromptInfo.Builder()
        .setTitle("Unlock App")
        .setSubtitle("Authenticate to continue")
        .setAllowedAuthenticators(
            BiometricManager.Authenticators.BIOMETRIC_STRONG or
                    BiometricManager.Authenticators.DEVICE_CREDENTIAL
        )
        .build()

    prompt.authenticate(promptInfo)
}

================================================================================
FILE: core/modules/common/util/PasswordUtils.kt  (size: 2177 bytes)
================================================================================
package com.bankingsystem.mobile.core.modules.common.util

/**
 * Represents the result of a password strength check.
 *
 * @property score An integer score indicating the strength of the password. Higher is better.
 * @property issues A list of strings, where each string describes a weakness found in the password.
 */
data class PasswordStrengthResult(val score: Int, val issues: List<String>)

/**
 * Checks the strength of a given password based on a set of predefined criteria.
 *
 * The criteria for a strong password include:
 * - Minimum length of 8 characters.
 * - At least one uppercase letter.
 * - At least one digit.
 * - At least one special character from the set "!@#$%^&*(),.?\":{}|<>".
 *
 * @param password The password string to evaluate.
 * @return A [PasswordStrengthResult] object containing the strength score and a list of any issues found.
 */
fun checkPasswordStrength(password: String): PasswordStrengthResult {
    var score = 0
    val issues = mutableListOf<String>()

    if (password.length >= 8) score++ else issues.add("Password must be at least 8 characters long")
    if (password.any { it.isUpperCase() }) score++ else issues.add("Must include at least one uppercase letter")
    if (password.any { it.isDigit() }) score++ else issues.add("Must include at least one number")
    if (password.any { "!@#$%^&*(),.?\":{}|<>".contains(it) }) score++ else issues.add("Must include at least one special character")

    return PasswordStrengthResult(score, issues)
}

/**
 * Compares two password strings to see if they match.
 *
 * @param password The first password string.
 * @param confirmPassword The second password string to compare against the first.
 * @return `true` if the passwords match, `false` otherwise.
 */
fun doPasswordsMatch(password: String, confirmPassword: String) = password == confirmPassword

/**
 * Validates an email address string using a regular expression.
 * @param email The email string to validate.
 * @return `true` if the email format is valid, `false` otherwise.
 */
fun isValidEmail(email: String) = Regex("^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$").matches(email)

================================================================================
FILE: features/accounts/domain/errors/ApiCallException.kt  (size: 128 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.domain.errors
class ApiCallException(message: String) : Exception(message)

================================================================================
FILE: features/accounts/domain/errors/CustomerMissingException.kt  (size: 165 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.domain.errors
class CustomerMissingException(message: String = "Customer profile missing") : Exception(message)

================================================================================
FILE: features/accounts/domain/model/Account.kt  (size: 275 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.domain.model

data class Account(
    val accountId: String,
    val accountNumber: String,
    val accountType: String,
    val accountStatus: String,
    val balance: Double,
    val branchName: String? = null
)

================================================================================
FILE: features/accounts/domain/model/Branch.kt  (size: 145 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.domain.model

data class Branch(
    val branchId: String,
    val branchName: String
)

================================================================================
FILE: features/accounts/domain/model/Transaction.kt  (size: 295 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.domain.model

data class Transaction(
    val transactionId: String,
    val accountId: String,
    val type: String,
    val amount: Double,
    val balanceAfter: Double,
    val description: String?,
    val createdAt: List<Int>
)

================================================================================
FILE: features/accounts/domain/repository/AccountRepository.kt  (size: 480 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.domain.repository

import com.bankingsystem.mobile.features.accounts.domain.model.*

interface AccountRepository {
    suspend fun getBranches(): List<Branch>
    suspend fun openAccount(
        accountType: String,
        initialDeposit: Double,
        branchId: String
    ): Account
    suspend fun getAccountTransactions(accountId: String): List<Transaction>
    suspend fun getMyAccounts(): List<Account>
}

================================================================================
FILE: features/accounts/integration/remote/api/AccountsApi.kt  (size: 625 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.integration.remote.api

import com.bankingsystem.mobile.features.accounts.integration.remote.dto.*
import retrofit2.http.*

interface AccountsApi {
    @GET("api/v1/branches")
    suspend fun getBranches(): List<BranchNet>

    @POST("api/v1/accounts")
    suspend fun openAccount(@Body body: AccountOpenRequest): AccountResponseNet

    @GET("api/v1/accounts/{id}/transactions")
    suspend fun getAccountTransactions(@Path("id") accountId: String): List<TransactionNet>

    @GET("api/v1/accounts/my")
    suspend fun getMyAccounts(): List<AccountNet>
}

================================================================================
FILE: features/accounts/integration/remote/dto/AccountNet.kt  (size: 1384 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.integration.remote.dto

import com.google.gson.annotations.SerializedName

data class AccountNet(
    @SerializedName("accountId")      val accountId: String,
    @SerializedName("accountNumber")  val accountNumber: String,
    @SerializedName("accountType")    val accountType: String,
    @SerializedName("accountStatus")  val accountStatus: String,
    @SerializedName("balance")        val balance: Double,

    @SerializedName("branchName")     val branchName: String? = null,
    @SerializedName("branchId")       val branchId: String? = null,

    @SerializedName("createdAt")      val createdAt: String? = null,
    @SerializedName("updatedAt")      val updatedAt: String? = null
)

data class BranchNet(
    val branchId: String,
    val branchName: String
)

data class AccountOpenRequest(
    val accountType: String,
    val initialDeposit: Double,
    val branchId: String
)

data class AccountResponseNet(
    val accountId: String,
    val accountNumber: String,
    val accountType: String,
    val accountStatus: String,
    val balance: Double
)

data class TransactionNet(
    val transactionId: String,
    val accountId: String,
    val type: String,
    val amount: Double,
    val balanceAfter: Double,
    val description: String?,
    val createdAt: List<Int>
)

================================================================================
FILE: features/accounts/integration/repository/AccountRepositoryImpl.kt  (size: 3495 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.integration.repository

import com.bankingsystem.mobile.features.accounts.domain.errors.ApiCallException
import com.bankingsystem.mobile.features.accounts.domain.errors.CustomerMissingException
import com.bankingsystem.mobile.features.accounts.domain.model.*
import com.bankingsystem.mobile.features.accounts.domain.repository.AccountRepository
import com.bankingsystem.mobile.features.accounts.integration.remote.api.AccountsApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import retrofit2.HttpException
import javax.inject.Inject

class AccountRepositoryImpl @Inject constructor(
    private val api: AccountsApi
) : AccountRepository {

    override suspend fun getBranches(): List<Branch> = ioWrap {
        api.getBranches().map { Branch(it.branchId, it.branchName) }
    }

    override suspend fun openAccount(
        accountType: String,
        initialDeposit: Double,
        branchId: String
    ): Account = ioWrap {
        val res = api.openAccount(
            com.bankingsystem.mobile.features.accounts.integration.remote.dto.AccountOpenRequest(
                accountType = accountType,
                initialDeposit = initialDeposit,
                branchId = branchId
            )
        )
        Account(
            accountId = res.accountId,
            accountNumber = res.accountNumber,
            accountType = res.accountType,
            accountStatus = res.accountStatus,
            balance = res.balance
        )
    }

    override suspend fun getAccountTransactions(accountId: String): List<Transaction> = ioWrap {
        api.getAccountTransactions(accountId).map {
            Transaction(
                transactionId = it.transactionId,
                accountId = it.accountId,
                type = it.type,
                amount = it.amount,
                balanceAfter = it.balanceAfter,
                description = it.description,
                createdAt = it.createdAt
            )
        }
    }

    override suspend fun getMyAccounts(): List<Account> = ioWrap {
        api.getMyAccounts().map {
            Account(
                accountId = it.accountId,
                accountNumber = it.accountNumber,
                accountType = it.accountType,
                accountStatus = it.accountStatus,
                balance = it.balance,
                branchName = it.branchName
            )
        }
    }

    private suspend inline fun <T> ioWrap(crossinline block: suspend () -> T): T =
        withContext(Dispatchers.IO) {
            try {
                block()
            } catch (e: HttpException) {
                val code = e.code()
                val raw = e.response()?.errorBody()?.string().orEmpty()
                val msg = runCatching { JSONObject(raw).optString("message") }.getOrNull().orEmpty()

                if (code == 404 && msg.contains("Customer not found", true)) {
                    throw CustomerMissingException(
                        "We couldn’t find your customer profile yet. Please create it to view or open accounts."
                    )
                }
                throw ApiCallException(msg.ifBlank { "Network error ($code)" })
            } catch (e: Exception) {
                throw ApiCallException(e.message ?: "Unexpected error")
            }
        }
}

================================================================================
FILE: features/accounts/interfaces/ui/AccountMappers.kt  (size: 1183 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import com.bankingsystem.mobile.features.accounts.domain.model.Account
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.*

fun toOpenRequestFields(
    type: AccountType,
    initialDeposit: String,
    branchId: String
): Triple<String, Double, String> {
    val amount = initialDeposit.toDoubleOrNull() ?: 0.0
    return Triple(type.name, amount, branchId)
}

private fun String.toAccountType(): AccountType = when (uppercase()) {
    "SAVINGS" -> AccountType.SAVINGS
    "CHECKING" -> AccountType.CHECKING
    "FIXED_DEPOSIT" -> AccountType.FIXED_DEPOSIT
    else -> AccountType.SAVINGS
}

private fun String.toAccountStatus(): AccountStatus = when (uppercase()) {
    "ACTIVE" -> AccountStatus.ACTIVE
    "FROZEN" -> AccountStatus.FROZEN
    "CLOSED" -> AccountStatus.CLOSED
    else -> AccountStatus.ACTIVE
}

fun Account.toUi(): AccountUi = AccountUi(
    accountId = accountId,
    accountNumber = accountNumber,
    type = accountType.toAccountType(),
    status = accountStatus.toAccountStatus(),
    balance = balance,
    branchName = branchName
)

================================================================================
FILE: features/accounts/interfaces/ui/AccountsRoute.kt  (size: 7685 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import android.annotation.SuppressLint
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel   // <-- add this
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar
import com.bankingsystem.mobile.app.navigation.Routes
import kotlinx.coroutines.launch

@SuppressLint("ConfigurationScreenWidthHeight")
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AccountsRoute(
    userName: String,
    onNavigate: (String) -> Unit
) {
    val config = LocalConfiguration.current
    val isCompact = config.screenWidthDp < 600

    val vm: OpenAccountViewModel = hiltViewModel()
    val ui by vm.ui.collectAsState()
    val events = vm.events
    val snackbarHost = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    LaunchedEffect(events) {
        events.collect { ev ->
            when (ev) {
                is OpenAccountEvent.Created -> {
                    scope.launch {
                        snackbarHost.showSnackbar(
                            message = "Account ${ev.accountNumber} created",
                            duration = SnackbarDuration.Short
                        )
                    }
                    onNavigate(Routes.accountTx(ev.accountId, ev.accountNumber))
                }
                is OpenAccountEvent.NeedsCustomerProfile -> {
                    val result = snackbarHost.showSnackbar(
                        message = "We need to verify your identity before opening an account.",
                        actionLabel = "Start KYC",
                        withDismissAction = true,
                        duration = SnackbarDuration.Short
                    )
                    if (result == SnackbarResult.ActionPerformed) onNavigate(Routes.KYC)
                }
                is OpenAccountEvent.Error -> {
                    scope.launch {
                        snackbarHost.showSnackbar(
                            message = ev.message,
                            duration = SnackbarDuration.Short
                        )
                    }
                }
            }
        }
    }

    if (isCompact) {
        val drawerState = rememberDrawerState(DrawerValue.Closed)
        val scope = rememberCoroutineScope()

        ModalNavigationDrawer(
            drawerState = drawerState,
            drawerContent = {
                ModalDrawerSheet(drawerContainerColor = Color(0xFF0B0B12)) {
                    Sidebar(
                        selectedItem = "Open Accounts",
                        onItemClick = { label ->
                            scope.launch { drawerState.close() }
                            onNavigate(label)
                        },
                        userName = userName
                    )
                }
            }
        ) {
            Box(Modifier.fillMaxSize()) {
                FadingAppBackground()
                Scaffold(
                    containerColor = Color.Transparent,
                    topBar = {
                        TopAppBar(
                            title = { Text("Open Account") },
                            navigationIcon = {
                                IconButton(onClick = { scope.launch { drawerState.open() } }) {
                                    Icon(Icons.Default.Menu, contentDescription = "Menu", tint = Color.White)
                                }
                            },
                            colors = TopAppBarDefaults.topAppBarColors(
                                containerColor = Color.Transparent,
                                scrolledContainerColor = Color.Transparent,
                                titleContentColor = Color.White,
                                navigationIconContentColor = Color.White
                            )
                        )
                    },
                    snackbarHost = { SnackbarHost(snackbarHost) }
                ) { padding ->
                    OpenAccountScreen(
                        accountType = ui.accountType,
                        onAccountTypeChange = vm::onAccountTypeChange,
                        initialDeposit = ui.initialDeposit,
                        onInitialDepositChange = vm::onInitialDepositChange,
                        selectedBranchId = ui.selectedBranchId,
                        onBranchChange = vm::onBranchChange,
                        branches = ui.branches,
                        loadingBranches = ui.loadingBranches,
                        depositError = ui.depositError,
                        branchError = ui.branchError,
                        submitting = ui.submitting,
                        onCancel = { onNavigate("Home") },
                        onCreateClick = { vm.submit() },
                        modifier = Modifier.padding(padding)
                    )
                }
            }
        }
    } else {
        Row(Modifier.fillMaxSize()) {
            Surface(
                modifier = Modifier
                    .fillMaxHeight()
                    .width(300.dp),
                tonalElevation = 0.dp,
                shadowElevation = 16.dp
            ) {
                Sidebar(
                    selectedItem = "Open Accounts",
                    onItemClick = onNavigate,
                    userName = userName
                )
            }
            Box(Modifier.weight(1f).fillMaxHeight()) {
                FadingAppBackground()
                Scaffold(
                    containerColor = Color.Transparent,
                    topBar = {
                        TopAppBar(
                            title = { Text("Open Account") },
                            colors = TopAppBarDefaults.topAppBarColors(
                                containerColor = Color.Transparent,
                                titleContentColor = Color.White
                            )
                        )
                    },
                    snackbarHost = { SnackbarHost(snackbarHost) }
                ) { padding ->
                    OpenAccountScreen(
                        accountType = ui.accountType,
                        onAccountTypeChange = vm::onAccountTypeChange,
                        initialDeposit = ui.initialDeposit,
                        onInitialDepositChange = vm::onInitialDepositChange,
                        selectedBranchId = ui.selectedBranchId,
                        onBranchChange = vm::onBranchChange,
                        branches = ui.branches,
                        loadingBranches = ui.loadingBranches,
                        depositError = ui.depositError,
                        branchError = ui.branchError,
                        submitting = ui.submitting,
                        onCancel = { onNavigate("Home") },
                        onCreateClick = { vm.submit() },
                        modifier = Modifier.padding(padding)
                    )
                }
            }
        }
    }
}

================================================================================
FILE: features/accounts/interfaces/ui/AccountTransactionsRoute.kt  (size: 5897 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import android.annotation.SuppressLint
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar
import kotlinx.coroutines.launch

@SuppressLint("ConfigurationScreenWidthHeight")
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AccountTransactionsRoute(
    userName: String,
    accountId: String,
    accountNumber: String?,
    onNavigate: (String) -> Unit,
    onBack: () -> Unit = {}
) {
    val config = LocalConfiguration.current
    val isCompact = config.screenWidthDp < 600

    val vm: AccountTransactionsViewModel = hiltViewModel()

    LaunchedEffect(accountId) { vm.load(accountId) }

    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    var showFull by rememberSaveable { mutableStateOf(false) }

    val secondaryTitle = remember(accountId, accountNumber, showFull) {
        accountNumber?.let { no ->
            "Account • " + if (showFull) formatAccNo(no) else maskAccNo(no)
        } ?: "Account • ${accountId.take(8)}…${accountId.takeLast(6)}"
    }

    val topBar: @Composable () -> Unit = {
        TopAppBar(
            title = {
                Column {
                    Text("Transactions", color = Color.White)
                    Text(
                        secondaryTitle,
                        color = Color.White.copy(alpha = 0.8f),
                        style = MaterialTheme.typography.labelLarge
                    )
                }
            },
            navigationIcon = {
                IconButton(onClick = onBack) {
                    Icon(
                        Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            },
            actions = {
                if (!accountNumber.isNullOrBlank()) {
                    IconButton(onClick = { showFull = !showFull }) {
                        Icon(
                            if (showFull) Icons.Filled.VisibilityOff else Icons.Filled.Visibility,
                            contentDescription = if (showFull) "Hide full number" else "Show full number",
                            tint = Color.White
                        )
                    }
                }
                if (isCompact) {
                    IconButton(onClick = { scope.launch { drawerState.open() } }) {
                        Icon(Icons.Filled.Menu, contentDescription = "Menu", tint = Color.White)
                    }
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = Color.Transparent,
                scrolledContainerColor = Color.Transparent,
                titleContentColor = Color.White,
                navigationIconContentColor = Color.White,
                actionIconContentColor = Color.White
            )
        )
    }

    val content: @Composable (PaddingValues) -> Unit = { padding ->
        Box(Modifier.fillMaxSize().padding(padding)) {
            AccountTransactionsScreen(
                accountId = accountId,
                accountNumber = accountNumber,
            )
        }
    }

    if (isCompact) {
        ModalNavigationDrawer(
            drawerState = drawerState,
            drawerContent = {
                ModalDrawerSheet(drawerContainerColor = Color(0xFF0B0B12)) {
                    Sidebar(
                        selectedItem = "My Accounts",
                        onItemClick = { label ->
                            scope.launch { drawerState.close() }
                            onNavigate(label)
                        },
                        userName = userName
                    )
                }
            }
        ) {
            Box(Modifier.fillMaxSize()) {
                FadingAppBackground()
                Scaffold(containerColor = Color.Transparent, topBar = topBar, content = content)
            }
        }
    } else {
        Row(Modifier.fillMaxSize()) {
            Surface(
                modifier = Modifier
                    .fillMaxHeight()
                    .width(300.dp),
                tonalElevation = 0.dp,
                shadowElevation = 16.dp
            ) {
                Sidebar(
                    selectedItem = "My Accounts",
                    onItemClick = onNavigate,
                    userName = userName
                )
            }
            Box(Modifier.weight(1f).fillMaxHeight()) {
                FadingAppBackground()
                Scaffold(containerColor = Color.Transparent, topBar = topBar, content = content)
            }
        }
    }
}

/* ---- helpers ---- */

private fun formatAccNo(no: String): String =
    no.filter { it.isDigit() }.chunked(4).joinToString(" ")

private fun maskAccNo(no: String): String {
    val last4 = no.takeLast(4)
    return "•••• $last4"
}

================================================================================
FILE: features/accounts/interfaces/ui/AccountTransactionsScreen.kt  (size: 6725 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.features.accounts.domain.model.Transaction
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import java.util.TimeZone
import kotlin.math.abs

@Composable
fun AccountTransactionsScreen(
    accountId: String,
    accountNumber: String?,
) {
    val vm: AccountTransactionsViewModel = hiltViewModel()
    LaunchedEffect(accountId) { vm.load(accountId) }

    val ui by vm.ui.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {

        GlassPanel {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Activity", style = MaterialTheme.typography.titleLarge, color = Color.White)
                TextButton(onClick = { vm.refresh() }, enabled = !ui.loading) {
                    Text(if (ui.loading) "Refreshing…" else "Refresh")
                }
            }
            Spacer(Modifier.height(8.dp))

            when {
                ui.loading -> repeat(5) { SkeletonRow() }
                ui.error != null -> Text(ui.error!!, color = MaterialTheme.colorScheme.error)
                ui.items.isEmpty() -> Text("No transactions yet.", color = Color.White.copy(0.9f))
                else -> {
                    LazyColumn(verticalArrangement = Arrangement.spacedBy(10.dp)) {
                        items(ui.items, key = { it.transactionId }) { tx -> TxRow(tx) }
                    }
                }
            }
        }
    }
}

/* ---- Rows & helpers ---- */

@Composable
private fun TxRow(tx: Transaction) {
    val (badgeText, badgeBg, amountColor) = when (tx.type) {
        "DEPOSIT"       -> Triple("Deposit",      Color(0xFF065F46), Color(0xFF34D399))
        "WITHDRAWAL"    -> Triple("Withdrawal",   Color(0xFF7F1D1D), Color(0xFFFCA5A5))
        "TRANSFER_IN"   -> Triple("Transfer In",  Color(0xFF0C4A6E), Color(0xFF93C5FD))
        "TRANSFER_OUT"  -> Triple("Transfer Out", Color(0xFF78350F), Color(0xFFFCD34D))
        else            -> Triple(tx.type,        Color(0xFF334155), Color(0xFFCBD5E1))
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 6.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                @Suppress("DEPRECATION")
                Surface(
                    color = badgeBg.copy(alpha = 0.25f),
                    shape = RoundedCornerShape(8.dp),
                    border = ButtonDefaults.outlinedButtonBorder
                ) {
                    Text(
                        badgeText,
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                        color = Color.White,
                        style = MaterialTheme.typography.labelMedium
                    )
                }
                Text(
                    humanDate(tx.createdAt),
                    style = MaterialTheme.typography.labelMedium,
                    color = Color.White.copy(0.75f)
                )
            }
            if (!tx.description.isNullOrBlank()) {
                Text(
                    tx.description,
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.White,
                    modifier = Modifier.padding(top = 4.dp)
                )
            }
        }
        Column(horizontalAlignment = Alignment.End) {
            Text(
                formatAmount(tx.amount),
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold),
                color = amountColor
            )
            Text(
                "Bal ${formatAmount(tx.balanceAfter)}",
                style = MaterialTheme.typography.labelMedium,
                color = Color.White.copy(0.7f)
            )
        }
    }
}

@Composable
private fun SkeletonRow() {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Surface(color = Color.White.copy(0.08f), shape = RoundedCornerShape(8.dp)) {
            Spacer(Modifier.height(18.dp).width(180.dp))
        }
        Surface(color = Color.White.copy(0.08f), shape = RoundedCornerShape(8.dp)) {
            Spacer(Modifier.height(18.dp).width(90.dp))
        }
    }
}

private fun humanDate(parts: List<Int>): String {
    val y  = parts.getOrNull(0) ?: return "—"
    val mo = (parts.getOrNull(1) ?: 1) - 1
    val d  = parts.getOrNull(2) ?: 1
    val h  = parts.getOrNull(3) ?: 0
    val m  = parts.getOrNull(4) ?: 0
    val s  = parts.getOrNull(5) ?: 0

    val cal = Calendar.getInstance(TimeZone.getDefault(), Locale.getDefault()).apply {
        set(Calendar.YEAR, y)
        set(Calendar.MONTH, mo)
        set(Calendar.DAY_OF_MONTH, d)
        set(Calendar.HOUR_OF_DAY, h)
        set(Calendar.MINUTE, m)
        set(Calendar.SECOND, s)
        set(Calendar.MILLISECOND, 0)
    }
    val out = SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault())
    return out.format(cal.time)
}

private fun formatAmount(v: Double): String =
    (if (v >= 0) "+ " else "− ") + "%,.2f".format(abs(v))

@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(24.dp),
        color = cs.surface.copy(alpha = 0.10f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp
    ) {
        Column(Modifier.padding(16.dp), content = content)
    }
}

================================================================================
FILE: features/accounts/interfaces/ui/AccountTransactionsViewModel.kt  (size: 1600 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.accounts.domain.model.Transaction
import com.bankingsystem.mobile.features.accounts.domain.repository.AccountRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class AccountTxUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val items: List<Transaction> = emptyList()
)

@HiltViewModel
class AccountTransactionsViewModel @Inject constructor(
    private val repo: AccountRepository
) : ViewModel() {

    private val _ui = MutableStateFlow(AccountTxUiState(loading = true))
    val ui: StateFlow<AccountTxUiState> = _ui.asStateFlow()

    private var currentAccountId: String? = null

    fun load(accountId: String) {
        if (currentAccountId == accountId && _ui.value.items.isNotEmpty()) return
        currentAccountId = accountId
        refresh()
    }

    fun refresh() {
        val id = currentAccountId ?: return
        viewModelScope.launch {
            _ui.update { it.copy(loading = true, error = null) }
            runCatching { repo.getAccountTransactions(id) }
                .onSuccess { list -> _ui.value = AccountTxUiState(loading = false, items = list) }
                .onFailure { e -> _ui.value = AccountTxUiState(loading = false, error = e.message ?: "Failed to load transactions") }
        }
    }
}

================================================================================
FILE: features/accounts/interfaces/ui/models/AccountUi.kt  (size: 458 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui.models

enum class AccountStatus { ACTIVE, FROZEN, CLOSED }
enum class AccountType { SAVINGS, CHECKING, FIXED_DEPOSIT }

data class AccountUi(
    val accountId: String,
    val accountNumber: String,
    val type: AccountType,
    val status: AccountStatus,
    val balance: Double,
    val branchName: String? = null
)
data class BranchOption(val id: String, val name: String)

================================================================================
FILE: features/accounts/interfaces/ui/MyAccountsRoute.kt  (size: 5760 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import android.annotation.SuppressLint
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.DrawerState
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material3.rememberDrawerState
import androidx.compose.material3.rememberTopAppBarState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.app.navigation.Routes
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@SuppressLint("UnusedMaterial3ScaffoldPaddingParameter")
@Composable
fun MyAccountsRoute(
    userName: String,
    onNavigate: (String) -> Unit
) {
    val vm: MyAccountsViewModel = hiltViewModel()
    val ui by vm.ui.collectAsState()

    val config = LocalConfiguration.current
    val isCompact = config.screenWidthDp < 900
    val drawerState: DrawerState = rememberDrawerState(initialValue = androidx.compose.material3.DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    val topBar: @Composable () -> Unit = {
        TopAppBar(
            title = { Text("Accounts", color = Color.White) },
            navigationIcon = {
                if (isCompact) {
                    IconButton(onClick = { scope.launch { drawerState.open() } }) {
                        Icon(Icons.Filled.Menu, contentDescription = "Menu", tint = Color.White)
                    }
                }
            },
            actions = {
                TextButton(onClick = vm::refresh, enabled = !ui.loading) {
                    Text(if (ui.loading) "Refreshing…" else "Refresh")
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = Color.Transparent,
                titleContentColor = Color.White,
                navigationIconContentColor = Color.White,
                actionIconContentColor = Color.White
            ),
            scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior(rememberTopAppBarState())
        )
    }

    val content: @Composable (PaddingValues) -> Unit = { padding ->
        Box(Modifier.fillMaxSize().padding(padding)) {
            MyAccountsScreen(
                accounts = ui.accounts,
                loading = ui.loading,
                error = ui.error,
                onRefresh = vm::refresh,
                onOpenAccount = { onNavigate(Routes.ACCOUNTS_OPEN) },
                onAccountClick = { id, number -> onNavigate(Routes.accountTx(id, number)) },
                defaultAccountId = ui.defaultAccountId,
                onSetDefault = vm::setDefault,
                customerMissing = ui.customerMissing,
                customerMessage = ui.customerMessage,
                onStartKyc = { onNavigate(Routes.KYC) },
                onFixCustomer = { onNavigate(Routes.PROFILE) },
                // NEW ↓
                kycApproved = ui.kycApproved,
                onRegisterCustomer = { onNavigate(Routes.CUSTOMER_REG) }
            )
        }
    }

    if (isCompact) {
        ModalNavigationDrawer(
            drawerState = drawerState,
            drawerContent = {
                ModalDrawerSheet(drawerContainerColor = Color(0xFF0B0B12)) {
                    Sidebar(
                        selectedItem = "My Accounts",
                        onItemClick = onNavigate,
                        userName = userName
                    )
                }
            }
        ) {
            Box(Modifier.fillMaxSize()) {
                FadingAppBackground()
                Scaffold(containerColor = Color.Transparent, topBar = topBar, content = content)
            }
        }
    } else {
        androidx.compose.foundation.layout.Row(Modifier.fillMaxSize()) {
            ModalDrawerSheet(
                drawerContainerColor = Color(0xFF0B0B12),
                modifier = Modifier.weight(0.28f)
            ) {
                Sidebar(
                    selectedItem = "My Accounts",
                    onItemClick = onNavigate,
                    userName = userName
                )
            }
            Box(Modifier.weight(0.72f).fillMaxSize()) {
                FadingAppBackground()
                Scaffold(containerColor = Color.Transparent, topBar = topBar, content = content)
            }
        }
    }
}

================================================================================
FILE: features/accounts/interfaces/ui/MyAccountsScreen.kt  (size: 10480 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccountBalance
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.outlined.Star
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.ExtendedFloatingActionButton
import androidx.compose.material3.FilledTonalButton
import androidx.compose.material3.Icon
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.AccountUi

@Composable
fun MyAccountsScreen(
    modifier: Modifier = Modifier,
    accounts: List<AccountUi>,
    loading: Boolean,
    error: String?,
    onRefresh: () -> Unit,
    onOpenAccount: () -> Unit,
    onAccountClick: (String, String) -> Unit,
    defaultAccountId: String?,
    onSetDefault: (String) -> Unit,
    customerMissing: Boolean = false,
    customerMessage: String? = null,
    onStartKyc: () -> Unit = {},
    onFixCustomer: () -> Unit = {},
    kycApproved: Boolean? = null,
    onRegisterCustomer: () -> Unit = {},
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Row(verticalAlignment = Alignment.CenterVertically) {
            Icon(Icons.Filled.AccountBalance, null, tint = Color.White)
            Spacer(Modifier.width(10.dp))
            Text("My Accounts", style = MaterialTheme.typography.titleLarge, color = Color.White)
            Spacer(Modifier.weight(1f))
            TextButton(onClick = onRefresh, enabled = !loading) {
                Text(if (loading) "Refreshing…" else "Refresh")
            }
        }

        OpenAnotherAccountCTA(onOpenAccount = onOpenAccount)

        when {
            loading -> repeat(3) { AccountSkeleton() }
            error != null -> ErrorPanel(error, onRefresh)

            customerMissing -> CustomerMissingPanel(
                message = customerMessage
                    ?: "We need to verify your identity and create your profile before you can view or open accounts.",
                kycApproved = kycApproved,
                onStartKyc = onStartKyc,
                onGoRegister = onRegisterCustomer
            )

            accounts.isEmpty() -> EmptyAccounts(onOpenAccount)
            else -> {
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    contentPadding = PaddingValues(bottom = 72.dp)
                ) {
                    items(accounts) { acc ->
                        AccountRow(
                            ui = acc,
                            isDefault = acc.accountId == defaultAccountId,
                            onClick = { onAccountClick(acc.accountId, acc.accountNumber) },
                            onSetDefault = { onSetDefault(acc.accountId) }
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun OpenAnotherAccountCTA(onOpenAccount: () -> Unit) {
    Surface(
        shape = RoundedCornerShape(16.dp),
        color = Color(0x14222A2E),
        shadowElevation = 0.dp,
        border = ButtonDefaults.outlinedButtonBorder(true).copy(width = 1.dp)
    ) {
        Row(
            Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            ExtendedFloatingActionButton(
                onClick = onOpenAccount,
                containerColor = Color(0xFF7C3AED),
                contentColor = Color.White,
                icon = { Icon(Icons.Filled.Add, contentDescription = null) },
                text = { Text("Open Account") }
            )
        }
    }
}

@Composable
private fun AccountRow(
    ui: AccountUi,
    isDefault: Boolean,
    onClick: () -> Unit,
    onSetDefault: () -> Unit
) {
    Surface(
        shape = RoundedCornerShape(16.dp),
        color = Color(0x14222A2E),
        border = ButtonDefaults.outlinedButtonBorder(true).copy(width = 1.dp)
    ) {
        Row(
            Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(Modifier.weight(1f)) {
                Text(
                    ui.accountNumber,
                    color = Color.White,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                val subtitle = buildString {
                    append(ui.type.name.lowercase().replaceFirstChar { it.uppercase() })
                    append(" • ")
                    append(ui.status.name.lowercase().replaceFirstChar { it.uppercase() })
                    ui.branchName?.let { append(" • ").append(it) }
                }
                Text(subtitle, color = Color.White.copy(alpha = 0.8f))
            }
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                if (!isDefault) {
                    OutlinedButton(onClick = onSetDefault, shape = RoundedCornerShape(12.dp)) {
                        Icon(Icons.Outlined.Star, contentDescription = null)
                        Spacer(Modifier.width(6.dp))
                        Text("Make Default")
                    }
                } else {
                    FilledTonalButton(onClick = onClick, shape = RoundedCornerShape(12.dp)) {
                        Icon(Icons.Filled.Star, contentDescription = null)
                        Spacer(Modifier.width(6.dp))
                        Text("Default")
                    }
                }
                Button(onClick = onClick, shape = RoundedCornerShape(12.dp)) { Text("View") }
            }
        }
    }
}

@Composable
private fun AccountSkeleton() {
    LinearProgressIndicator(modifier = Modifier.fillMaxWidth())
}

@Composable
private fun ErrorPanel(message: String, onRetry: () -> Unit) {
    Surface(
        shape = RoundedCornerShape(16.dp),
        color = Color(0x33FF6B6B),
    ) {
        Column(
            Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                "Something went wrong",
                color = Color.White,
                style = MaterialTheme.typography.titleMedium
            )
            Spacer(Modifier.height(8.dp))
            Text(message, color = Color.White.copy(alpha = 0.9f))
            Spacer(Modifier.height(12.dp))
            Button(onClick = onRetry, shape = RoundedCornerShape(12.dp)) { Text("Retry") }
        }
    }
}

@Composable
private fun EmptyAccounts(onOpenAccount: () -> Unit) {
    Surface(
        shape = RoundedCornerShape(16.dp),
        color = Color(0x14222A2E)
    ) {
        Column(
            Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                "No accounts yet",
                color = Color.White,
                style = MaterialTheme.typography.titleMedium
            )
            Spacer(Modifier.height(8.dp))
            Text("Open your first account to get started.", color = Color.White.copy(alpha = 0.9f))
            Spacer(Modifier.height(12.dp))
            Button(
                onClick = onOpenAccount,
                shape = RoundedCornerShape(12.dp)
            ) { Text("Open Account") }
        }
    }
}

/**
 * If [kycApproved] == true, show "Register as Customer".
 * Otherwise show "Start Verification".
 * (No "Go to Profile" link anymore.)
 */
@Composable
fun CustomerMissingPanel(
    message: String,
    kycApproved: Boolean?,
    onStartKyc: () -> Unit,
    onGoRegister: () -> Unit
) {
    Surface(
        shape = RoundedCornerShape(22.dp),
        color = Color(0xFF7C3AED).copy(alpha = 0.18f)
    ) {
        Column(
            Modifier
                .fillMaxWidth()
                .padding(18.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text("Almost there!", color = Color.White, style = MaterialTheme.typography.titleMedium)
            Spacer(Modifier.height(6.dp))
            Text(message, color = Color.White.copy(alpha = 0.9f))
            Spacer(Modifier.height(12.dp))

            if (kycApproved == true) {
                Button(
                    onClick = onGoRegister,
                    shape = RoundedCornerShape(12.dp)
                ) { Text("Register as Customer") }
            } else {
                Button(
                    onClick = onStartKyc,
                    shape = RoundedCornerShape(12.dp)
                ) { Text("Start Verification") }
            }
        }
    }
}

================================================================================
FILE: features/accounts/interfaces/ui/MyAccountsViewModel.kt  (size: 3530 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.core.modules.common.storage.DefaultAccountStore
import com.bankingsystem.mobile.features.accounts.domain.errors.CustomerMissingException
import com.bankingsystem.mobile.features.accounts.domain.repository.AccountRepository
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.AccountUi
import com.bankingsystem.mobile.features.kyc.domain.repository.KycRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

data class MyAccountsUiState(
    val loading: Boolean = true,
    val error: String? = null,
    val accounts: List<AccountUi> = emptyList(),
    val defaultAccountId: String? = null,
    val customerMissing: Boolean = false,
    val customerMessage: String? = null,
    /** null = unknown/not fetched; true = APPROVED; false = not approved */
    val kycApproved: Boolean? = null
)

@HiltViewModel
class MyAccountsViewModel @Inject constructor(
    private val repo: AccountRepository,
    private val defaults: DefaultAccountStore,
    private val kyc: KycRepository
) : ViewModel() {

    private val _ui = MutableStateFlow(MyAccountsUiState())
    val ui: StateFlow<MyAccountsUiState> = _ui.asStateFlow()

    init {
        viewModelScope.launch {
            defaults.defaultAccountId.collect { id ->
                _ui.update { it.copy(defaultAccountId = id) }
            }
        }
        refresh()
    }

    fun refresh() {
        viewModelScope.launch {
            _ui.update {
                it.copy(
                    loading = true,
                    error = null,
                    customerMissing = false,
                    customerMessage = null,
                    // keep prior value until we know otherwise
                    kycApproved = it.kycApproved
                )
            }
            try {
                val list = repo.getMyAccounts().map { acc -> acc.toUi() }
                _ui.update { it.copy(loading = false, accounts = list) }
            } catch (e: CustomerMissingException) {
                // Customer profile not created yet — look up KYC status
                val approved: Boolean? = try {
                    val status = kyc.myCase().status
                    status.equals("APPROVED", ignoreCase = true)
                } catch (_: Exception) {
                    null // unknown
                }
                _ui.update {
                    it.copy(
                        loading = false,
                        accounts = emptyList(),
                        customerMissing = true,
                        customerMessage = e.message,
                        kycApproved = approved
                    )
                }
            } catch (e: Exception) {
                _ui.update {
                    it.copy(
                        loading = false,
                        error = e.message ?: "Failed to load accounts"
                    )
                }
            }
        }
    }

    fun setDefault(id: String) {
        viewModelScope.launch { defaults.setDefaultAccountId(id) }
    }
}

================================================================================
FILE: features/accounts/interfaces/ui/OpenAccountScreen.kt  (size: 12176 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccountBalance
import androidx.compose.material.icons.filled.AddCircle
import androidx.compose.material.icons.filled.Business
import androidx.compose.material3.*
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.AccountType
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.BranchOption

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OpenAccountScreen(
    accountType: AccountType,
    onAccountTypeChange: (AccountType) -> Unit,
    initialDeposit: String,
    onInitialDepositChange: (String) -> Unit,
    selectedBranchId: String?,
    onBranchChange: (String?) -> Unit,

    branches: List<BranchOption>,
    loadingBranches: Boolean,
    depositError: String?,
    branchError: String?,

    submitting: Boolean,
    onCancel: () -> Unit,
    onCreateClick: () -> Unit,

    kycRequired: Boolean = false,
    onStartKyc: () -> Unit = {},

    modifier: Modifier = Modifier,
) {
    var accountTypeExpanded by remember { mutableStateOf(false) }
    var branchExpanded by remember { mutableStateOf(false) }
    val scroll = rememberScrollState()
    val cs = MaterialTheme.colorScheme

    val selectedBranchName = remember(branches, selectedBranchId) {
        branches.firstOrNull { it.id == selectedBranchId }?.name ?: ""
    }

    val canCreate = !submitting &&
            selectedBranchId != null &&
            depositError == null &&
            initialDeposit.isNotBlank()

    Column(
        modifier = modifier
            .fillMaxSize()
            .verticalScroll(scroll)
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(20.dp)
    ) {
        Column {
            Text(
                text = "Open a New Account",
                style = MaterialTheme.typography.headlineMedium,
                color = Color.White
            )
            Text(
                text = "Choose type, deposit, and branch. Your account number will be generated automatically.",
                style = MaterialTheme.typography.bodyMedium,
                color = Color.White.copy(alpha = 0.8f),
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
        }

        /* 🔹 KYC banner (only if kycRequired = true) */
        if (kycRequired) {
            Surface(
                shape = RoundedCornerShape(16.dp),
                color = Color(0xFF7C3AED).copy(alpha = 0.18f),
                tonalElevation = 0.dp,
                shadowElevation = 8.dp
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(14.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(Modifier.weight(1f)) {
                        Text(
                            "Identity verification required",
                            color = Color.White,
                            style = MaterialTheme.typography.titleMedium
                        )
                        Spacer(Modifier.height(4.dp))
                        Text(
                            "Verify your identity to open an account.",
                            color = Color.White.copy(alpha = 0.9f)
                        )
                    }
                    Spacer(Modifier.width(12.dp))
                    TextButton(onClick = onStartKyc) { Text("Start KYC") }
                }
            }
        }

        GlassPanel {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Filled.AccountBalance, null, tint = Color.White)
                Spacer(Modifier.width(10.dp))
                Text("Account Details", style = MaterialTheme.typography.titleLarge, color = Color.White)
            }
            Spacer(Modifier.height(14.dp))

            ExposedDropdownMenuBox(
                expanded = accountTypeExpanded,
                onExpandedChange = { accountTypeExpanded = !accountTypeExpanded }
            ) {
                OutlinedTextField(
                    value = accountType.name.replace('_',' ').lowercase().replaceFirstChar { it.uppercase() },
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Account Type") },
                    leadingIcon = { Icon(Icons.Filled.AccountBalance, null) },
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(accountTypeExpanded) },
                    modifier = Modifier.menuAnchor().fillMaxWidth(),
                    singleLine = true,
                    shape = RoundedCornerShape(14.dp),
                    colors = lightFieldColors()
                )
                ExposedDropdownMenu(
                    expanded = accountTypeExpanded,
                    onDismissRequest = { accountTypeExpanded = false }
                ) {
                    AccountType.entries.forEach { type ->
                        DropdownMenuItem(
                            text = { Text(type.name.replace('_',' ').lowercase().replaceFirstChar { it.uppercase() }) },
                            onClick = { onAccountTypeChange(type); accountTypeExpanded = false }
                        )
                    }
                }
            }

            Spacer(Modifier.height(12.dp))

            OutlinedTextField(
                value = initialDeposit,
                onValueChange = onInitialDepositChange,
                label = { Text("Initial Deposit") },
                placeholder = { Text("0.00") },
                singleLine = true,
                isError = depositError != null,
                supportingText = { depositError?.let { Text(it, color = MaterialTheme.colorScheme.error) } },
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Number,
                    imeAction = ImeAction.Done
                ),
                keyboardActions = KeyboardActions(onDone = { /* no-op */ }),
                leadingIcon = { Icon(Icons.Filled.AddCircle, null) },
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(14.dp),
                colors = lightFieldColors()
            )
            if (depositError == null) {
                Text(
                    text = "Minimum deposit for ${accountType.pretty()}: ${accountType.minDeposit()}",
                    style = MaterialTheme.typography.bodySmall,
                    color = Color(0xFFCBD5E1)
                )
            }
        }

        GlassPanel {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Filled.Business, null, tint = Color.White)
                Spacer(Modifier.width(10.dp))
                Text("Branch", style = MaterialTheme.typography.titleLarge, color = Color.White)
            }
            Spacer(Modifier.height(14.dp))

            ExposedDropdownMenuBox(
                expanded = branchExpanded,
                onExpandedChange = { branchExpanded = !branchExpanded }
            ) {
                OutlinedTextField(
                    value = selectedBranchName,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Branch") },
                    placeholder = { Text(if (loadingBranches) "Loading…" else "Select a branch") },
                    isError = branchError != null,
                    supportingText = { branchError?.let { Text(it, color = MaterialTheme.colorScheme.error) } },
                    leadingIcon = { Icon(Icons.Filled.Business, null) },
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(branchExpanded) },
                    modifier = Modifier.menuAnchor().fillMaxWidth(),
                    singleLine = true,
                    shape = RoundedCornerShape(14.dp),
                    colors = lightFieldColors()
                )
                ExposedDropdownMenu(
                    expanded = branchExpanded,
                    onDismissRequest = { branchExpanded = false }
                ) {
                    when {
                        loadingBranches -> DropdownMenuItem(text = { Text("Loading…") }, onClick = { }, enabled = false)
                        branches.isEmpty() -> DropdownMenuItem(text = { Text("No branches available") }, onClick = { }, enabled = false)
                        else -> branches.forEach { b ->
                            DropdownMenuItem(
                                text = { Text(b.name) },
                                onClick = { onBranchChange(b.id); branchExpanded = false }
                            )
                        }
                    }
                }
            }
        }

        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
            TextButton(onClick = onCancel, enabled = !submitting) { Text("Cancel") }
            Spacer(Modifier.width(12.dp))
            Button(
                onClick = onCreateClick,
                enabled = canCreate,
                shape = RoundedCornerShape(12.dp),
                colors = ButtonDefaults.buttonColors(containerColor = cs.primary, contentColor = cs.onPrimary),
                modifier = Modifier.height(48.dp)
            ) { Text(if (submitting) "Creating…" else "Create Account") }
        }
    }
}

/* Shared visuals */

@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(24.dp),
        color = cs.surface.copy(alpha = 0.10f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp
    ) {
        Column(
            modifier = Modifier
                .border(1.dp, cs.outline.copy(alpha = 0.35f), RoundedCornerShape(24.dp))
                .padding(16.dp),
            content = content
        )
    }
}

private fun AccountType.pretty() =
    name.replace('_',' ').lowercase().replaceFirstChar { it.uppercase() }

private fun AccountType.minDeposit() = when (this) {
    AccountType.SAVINGS -> "1000.00"
    AccountType.CHECKING -> "0.00"
    AccountType.FIXED_DEPOSIT -> "5000.00"
}

@Composable
private fun lightFieldColors() = OutlinedTextFieldDefaults.colors(
    focusedContainerColor = Color(0xFFF0F4FF),
    unfocusedContainerColor = Color(0xFFEFF3FB),
    disabledContainerColor = Color(0xFFE5E7EB),
    focusedTextColor = Color(0xFF0F172A),
    unfocusedTextColor = Color(0xFF111827),
    focusedBorderColor = Color(0xFF4F46E5),
    unfocusedBorderColor = Color(0xFFCBD5E1),
    focusedLabelColor = Color(0xFF4F46E5),
    unfocusedLabelColor = Color(0xFF475569),
    cursorColor = Color(0xFF4F46E5),
)

================================================================================
FILE: features/accounts/interfaces/ui/OpenAccountViewModel.kt  (size: 5283 bytes)
================================================================================
package com.bankingsystem.mobile.features.accounts.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.accounts.domain.errors.ApiCallException
import com.bankingsystem.mobile.features.accounts.domain.errors.CustomerMissingException
import com.bankingsystem.mobile.features.accounts.domain.repository.AccountRepository
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.AccountType
import com.bankingsystem.mobile.features.accounts.interfaces.ui.models.BranchOption
import dagger.hilt.android.lifecycle.HiltViewModel
import jakarta.inject.Inject
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

data class OpenAccountUiState (
    val accountType: AccountType = AccountType.SAVINGS,
    val initialDeposit: String = "",
    val selectedBranchId: String? = null,
    val branches: List<BranchOption> = emptyList(),
    val loadingBranches: Boolean = false,
    val submitting: Boolean = false,
    val depositError: String? = null,
    val branchError: String? = null
)

sealed interface OpenAccountEvent {
    data class Created(val accountId: String, val accountNumber: String) : OpenAccountEvent
    data class Error(val message: String) : OpenAccountEvent
    data object NeedsCustomerProfile : OpenAccountEvent
}

@HiltViewModel
class OpenAccountViewModel @Inject constructor(
    private val repo: AccountRepository
) : ViewModel() {

    private val _ui = MutableStateFlow(OpenAccountUiState())
    val ui: StateFlow<OpenAccountUiState> = _ui.asStateFlow()

    private val _events = MutableSharedFlow<OpenAccountEvent>(extraBufferCapacity = 1)
    val events: SharedFlow<OpenAccountEvent> = _events.asSharedFlow()

    private val minDeposit = mapOf(
        AccountType.SAVINGS to 1000.0,
        AccountType.CHECKING to 0.0,
        AccountType.FIXED_DEPOSIT to 5000.0
    )

    init { loadBranches() }

    fun onAccountTypeChange(type: AccountType) =
        _ui.update { it.copy(accountType = type, depositError = null) }

    fun onInitialDepositChange(value: String) =
        _ui.update { it.copy(initialDeposit = value, depositError = null) }

    fun onBranchChange(id: String?) =
        _ui.update { it.copy(selectedBranchId = id, branchError = null) }

    fun loadBranches() = viewModelScope.launch {
        _ui.update { it.copy(loadingBranches = true) }
        try {
            val branches = repo.getBranches()
            val options = branches.map { BranchOption(id = it.branchId, name = it.branchName) }
            _ui.update { st ->
                st.copy(
                    branches = options,
                    loadingBranches = false,
                    selectedBranchId = st.selectedBranchId?.takeIf { id -> options.any { it.id == id } }
                )
            }
        } catch (_: Exception) {
            _ui.update { it.copy(loadingBranches = false) }
            _events.tryEmit(OpenAccountEvent.Error("Failed to load branches"))
        }
    }

    fun submit() = viewModelScope.launch {
        val st = _ui.value
        var depositErr: String? = null
        var branchErr: String? = null

        val amount = st.initialDeposit.toDoubleOrNull()
        if (amount == null || amount < 0.0) {
            depositErr = "Enter a valid non-negative amount"
        } else {
            val min = minDeposit[st.accountType]!!
            if (amount < min) depositErr = "Minimum for ${st.accountType.pretty()} is ${"%,.2f".format(min)}"
        }
        if (st.selectedBranchId.isNullOrBlank()) branchErr = "Select a branch"

        if (depositErr != null || branchErr != null) {
            _ui.update { it.copy(depositError = depositErr, branchError = branchErr) }
            return@launch
        }

        _ui.update { it.copy(submitting = true, depositError = null, branchError = null) }
        try {
            val res = repo.openAccount(
                accountType = st.accountType.name,
                initialDeposit = st.initialDeposit.toDouble(),
                branchId = st.selectedBranchId!!
            )
            _events.tryEmit(OpenAccountEvent.Created(res.accountId, res.accountNumber))
            _ui.update { it.copy(accountType = AccountType.SAVINGS, initialDeposit = "", selectedBranchId = null, submitting = false) }
        } catch (e: Exception) {
            _ui.update { it.copy(submitting = false) }
            when (e) {
                is CustomerMissingException -> _events.tryEmit(OpenAccountEvent.NeedsCustomerProfile)
                is ApiCallException -> _events.tryEmit(OpenAccountEvent.Error(e.message ?: "Failed to open account"))
                else -> _events.tryEmit(OpenAccountEvent.Error("Failed to open account"))
            }
        }
    }
}

private fun AccountType.pretty() =
    name.replace('_', ' ').lowercase().replaceFirstChar { it.uppercase() }

================================================================================
FILE: features/auth/domain/model/ValidateTokenResponse.kt  (size: 148 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.domain.model

data class ValidateTokenResponse(
    val username: String,
    val role: String
)

================================================================================
FILE: features/auth/domain/repository/UserRepository.kt  (size: 726 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.domain.repository

import com.bankingsystem.mobile.features.auth.domain.model.ValidateTokenResponse
import com.bankingsystem.mobile.features.auth.integration.remote.dto.LoginResponse
import kotlinx.coroutines.flow.Flow

interface UserRepository {
    suspend fun login(username: String, password: String): Result<LoginResponse>
    suspend fun logout()
    suspend fun checkUsernameAvailability(username: String): Boolean
    suspend fun registerUser(username: String, email: String, password: String): Boolean
    suspend fun forgotPassword(email: String): Boolean
    suspend fun validateToken(): Result<ValidateTokenResponse>
    val tokenFlow: Flow<String?>
}

================================================================================
FILE: features/auth/integration/remote/api/AuthApi.kt  (size: 1234 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.integration.remote.api

import com.bankingsystem.mobile.features.auth.domain.model.ValidateTokenResponse
import com.bankingsystem.mobile.features.auth.integration.remote.dto.LoginRequest
import com.bankingsystem.mobile.features.auth.integration.remote.dto.LoginResponse
import com.bankingsystem.mobile.features.auth.integration.remote.dto.RegisterRequest
import retrofit2.Response
import retrofit2.http.*

interface AuthApi {

    @GET("api/v1/auth/available")
    suspend fun checkUsernameAvailability(
        @Query("username") username: String
    ): Response<Unit>

    @POST("api/v1/auth/register")
    suspend fun registerUser(
        @Body registerRequest: RegisterRequest
    ): Response<Unit>

    @POST("api/v1/auth/login")
    suspend fun loginUser(
        @Body loginRequest: LoginRequest
    ): Response<LoginResponse>

    @POST("api/v1/auth/forgot-password")
    suspend fun forgotPassword(
        @Query("email") email: String
    ): Response<Unit>

    @GET("api/v1/auth/validate-token")
    suspend fun validateToken(): Response<ValidateTokenResponse>

    @POST("api/v1/auth/logout")
    suspend fun logout(): Response<Unit>
}

================================================================================
FILE: features/auth/integration/remote/dto/LoginRequest.kt  (size: 153 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.integration.remote.dto

data class LoginRequest(
    val username: String,
    val password: String
)

================================================================================
FILE: features/auth/integration/remote/dto/LoginResponse.kt  (size: 174 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.integration.remote.dto

data class LoginResponse(
    val token: String,
    val username: String,
    val role: String
)

================================================================================
FILE: features/auth/integration/remote/dto/RegisterRequest.kt  (size: 180 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.integration.remote.dto

data class RegisterRequest(
    val username: String,
    val email: String,
    val password: String
)

================================================================================
FILE: features/auth/integration/repository/UserRepositoryImpl.kt  (size: 3216 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.integration.repository

import com.bankingsystem.mobile.core.modules.common.storage.TokenManager
import com.bankingsystem.mobile.features.auth.domain.model.ValidateTokenResponse
import com.bankingsystem.mobile.features.auth.domain.repository.UserRepository
import com.bankingsystem.mobile.features.auth.integration.remote.api.AuthApi
import com.bankingsystem.mobile.features.auth.integration.remote.dto.LoginRequest
import com.bankingsystem.mobile.features.auth.integration.remote.dto.LoginResponse
import com.bankingsystem.mobile.features.auth.integration.remote.dto.RegisterRequest
import kotlinx.coroutines.flow.Flow
import retrofit2.HttpException
import java.io.IOException
import javax.inject.Inject

class UserRepositoryImpl @Inject constructor(
    private val api: AuthApi,
    private val tokenManager: TokenManager
) : UserRepository {

    override suspend fun login(username: String, password: String): Result<LoginResponse> = try {
        val response = api.loginUser(LoginRequest(username, password))
        if (response.isSuccessful) {
            response.body()?.let { body ->
                tokenManager.saveToken(body.token)
                Result.success(body)
            } ?: Result.failure(IllegalStateException("Empty response body"))
        } else {
            val error = response.errorBody()?.string() ?: "Unknown error"
            Result.failure(IllegalStateException("Login failed: $error"))
        }
    } catch (e: IOException) {
        Result.failure(IOException("Network error: ${e.message}"))
    } catch (e: HttpException) {
        Result.failure(IllegalStateException("Server error: ${e.message}"))
    } catch (e: Exception) {
        Result.failure(IllegalStateException("Unexpected error: ${e.message}"))
    }

    override suspend fun logout() {
        try { api.logout() } catch (_: Exception) {}
        finally { tokenManager.clearToken() }
    }

    override suspend fun checkUsernameAvailability(username: String): Boolean {
        if (username.length < 3) return false
        return try {
            val res = api.checkUsernameAvailability(username)
            when {
                res.isSuccessful -> true
                res.code() == 409 -> false
                else -> false
            }
        } catch (_: Exception) { false }
    }

    override suspend fun registerUser(username: String, email: String, password: String): Boolean = try {
        api.registerUser(RegisterRequest(username, email, password)).isSuccessful
    } catch (_: Exception) { false }

    override suspend fun forgotPassword(email: String): Boolean = try {
        api.forgotPassword(email).isSuccessful
    } catch (_: Exception) { false }

    override suspend fun validateToken(): Result<ValidateTokenResponse> = try {
        val res = api.validateToken()
        if (res.isSuccessful && res.body() != null) Result.success(res.body()!!)
        else Result.failure(IllegalStateException("Invalid or expired token"))
    } catch (e: Exception) {
        Result.failure(e)
    }

    override val tokenFlow: Flow<String?> = tokenManager.tokenFlow
}

================================================================================
FILE: features/auth/interfaces/ui/LoginScreen.kt  (size: 9168 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.interfaces.ui

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.core.modules.common.designsystem.ButtonPrimary
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.InputField
import kotlinx.coroutines.launch

@Composable
fun LoginScreen(
    onNavigate: (String) -> Unit,
    onNavigateToRegister: () -> Unit
) {
    val viewModel: LoginViewModel = hiltViewModel()

    var username by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var forgotOpen by remember { mutableStateOf(false) }
    var forgotEmail by remember { mutableStateOf("") }

    val loginState by viewModel.loginState.collectAsState()
    val forgotPasswordState by viewModel.forgotPasswordState.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }
    val coroutineScope = rememberCoroutineScope()
    val cs = MaterialTheme.colorScheme

    LaunchedEffect(loginState) {
        when (loginState) {
            is LoginState.Success -> {
                val role = (loginState as LoginState.Success).role
                onNavigate(
                    when (role) {
                        "CUSTOMER" -> "/customer/home"
                        "ADMIN"    -> "/admin/home"
                        "TELLER"   -> "/teller/home"
                        "MANAGER"  -> "/manager/home"
                        else       -> "/"
                    }
                )
                viewModel.resetLoginState()
            }
            is LoginState.Error -> {
                coroutineScope.launch {
                    snackbarHostState.showSnackbar((loginState as LoginState.Error).error)
                    viewModel.resetLoginState()
                }
            }
            else -> {}
        }
    }

    LaunchedEffect(forgotPasswordState) {
        when (forgotPasswordState) {
            is ForgotPasswordState.Success -> {
                coroutineScope.launch {
                    snackbarHostState.showSnackbar((forgotPasswordState as ForgotPasswordState.Success).message)
                }
                forgotOpen = false
                forgotEmail = ""
                viewModel.resetForgotPasswordState()
            }
            is ForgotPasswordState.Error -> {
                coroutineScope.launch {
                    snackbarHostState.showSnackbar((forgotPasswordState as ForgotPasswordState.Error).error)
                    viewModel.resetForgotPasswordState()
                }
            }
            else -> {}
        }
    }

    fun validate() = username.trim().isNotEmpty() && password.trim().isNotEmpty()

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            snackbarHost = { SnackbarHost(snackbarHostState) },
            containerColor = Color.Transparent
        ) { padding ->
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding),
                contentAlignment = Alignment.Center
            ) {
                GlassPanel(
                    modifier = Modifier
                        .fillMaxWidth()
                        .widthIn(max = 420.dp)
                        .padding(24.dp)
                ) {
                    Text(
                        "Log In",
                        style = MaterialTheme.typography.headlineMedium,
                        color = Color.White
                    )

                    Spacer(Modifier.height(14.dp))

                    InputField(
                        label = "User Name",
                        value = username,
                        onValueChange = { username = it },
                        placeholder = "ex: Gimesha_13",
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(Modifier.height(16.dp))

                    InputField(
                        label = "Password",
                        value = password,
                        onValueChange = { password = it },
                        placeholder = "••••••••",
                        isPassword = true,
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(Modifier.height(8.dp))

                    TextButton(
                        onClick = { forgotOpen = true },
                        modifier = Modifier.align(Alignment.End)
                    ) { Text("Forgot Password?", color = cs.primary) }

                    Spacer(Modifier.height(20.dp))

                    ButtonPrimary(
                        onClick = { viewModel.loginUser(username.trim(), password) },
                        enabled = validate() && loginState != LoginState.Loading,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        if (loginState == LoginState.Loading) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(20.dp),
                                color = cs.onPrimary,
                                strokeWidth = 2.dp
                            )
                        } else {
                            Text("Log In")
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    TextButton(
                        onClick = onNavigateToRegister,
                        modifier = Modifier.fillMaxWidth()
                    ) { Text("Don't have an account? Register") }
                }
            }

            if (forgotOpen) {
                ForgotPasswordDialog(
                    email = forgotEmail,
                    onEmailChange = { forgotEmail = it },
                    onSubmit = { viewModel.forgotPassword(forgotEmail) },
                    onDismiss = {
                        forgotOpen = false
                        forgotEmail = ""
                        viewModel.resetForgotPasswordState()
                    },
                    isLoading = forgotPasswordState == ForgotPasswordState.Loading
                )
            }
        }
    }
}

@Composable
fun ForgotPasswordDialog(
    email: String,
    onEmailChange: (String) -> Unit,
    onSubmit: () -> Unit,
    onDismiss: () -> Unit,
    isLoading: Boolean = false
) {
    val cs = MaterialTheme.colorScheme
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Forgot Password", color = cs.onSurface) },
        text = {
            Column {
                Text("Enter your email address to reset your password.", color = cs.onSurface)
                Spacer(Modifier.height(8.dp))
                InputField(
                    label = "Email",
                    value = email,
                    onValueChange = onEmailChange,
                    placeholder = "you@example.com",
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                    modifier = Modifier.fillMaxWidth()
                )
            }
        },
        confirmButton = {
            TextButton(onClick = onSubmit, enabled = !isLoading && email.isNotBlank()) {
                if (isLoading) {
                    CircularProgressIndicator(modifier = Modifier.size(20.dp), strokeWidth = 2.dp)
                } else {
                    Text("Submit")
                }
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss, enabled = !isLoading) { Text("Cancel") }
        }
    )
}

@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier,
        shape = MaterialTheme.shapes.large,
        color = cs.surface.copy(alpha = 0.20f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp
    ) {
        Box(
            Modifier
                .border(1.dp, cs.outline.copy(alpha = 0.15f), MaterialTheme.shapes.medium)
                .padding(24.dp)
        ) {
            Column(
                modifier = Modifier.fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center,
                content = content
            )
        }
    }
}

================================================================================
FILE: features/auth/interfaces/ui/LoginViewModel.kt  (size: 4620 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.auth.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

sealed class LoginState {
    object Idle : LoginState()
    object Loading : LoginState()
    data class Success(val token: String, val username: String, val role: String) : LoginState()
    data class Error(val error: String) : LoginState()
}

sealed class ForgotPasswordState {
    object Idle : ForgotPasswordState()
    object Loading : ForgotPasswordState()
    data class Success(val message: String) : ForgotPasswordState()
    data class Error(val error: String) : ForgotPasswordState()
}

@HiltViewModel
class LoginViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {

    private val _loginState = MutableStateFlow<LoginState>(LoginState.Idle)
    val loginState: StateFlow<LoginState> = _loginState

    private val _forgotPasswordState = MutableStateFlow<ForgotPasswordState>(ForgotPasswordState.Idle)
    val forgotPasswordState: StateFlow<ForgotPasswordState> = _forgotPasswordState

    fun loginUser(username: String, password: String) {
        if (username.isBlank() || password.isBlank()) {
            _loginState.value = LoginState.Error("Username or password cannot be blank")
            return
        }

        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            val result = userRepository.login(username.trim(), password)
            result.fold(
                onSuccess = { loginResponse ->
                    _loginState.value = LoginState.Success(
                        token = loginResponse.token,
                        username = loginResponse.username,
                        role = loginResponse.role
                    )
                },
                onFailure = { error ->
                    _loginState.value = LoginState.Error(error.message ?: "Login failed")
                }
            )
        }
    }

    fun autoLogin() {
        viewModelScope.launch {
            userRepository.tokenFlow.collect { token ->
                if (!token.isNullOrBlank()) {
                    _loginState.value = LoginState.Loading
                    val result = userRepository.validateToken()
                    result.fold(
                        onSuccess = { validated ->
                            _loginState.value = LoginState.Success(
                                token = token,
                                username = validated.username,
                                role = validated.role
                            )
                        },
                        onFailure = {
                            userRepository.logout()
                            _loginState.value = LoginState.Idle
                        }
                    )
                } else {
                    _loginState.value = LoginState.Idle
                }
            }
        }
    }

    fun forgotPassword(email: String) {
        if (email.isBlank() || !email.contains("@")) {
            _forgotPasswordState.value = ForgotPasswordState.Error("Invalid email address")
            return
        }

        viewModelScope.launch {
            _forgotPasswordState.value = ForgotPasswordState.Loading
            try {
                val ok = userRepository.forgotPassword(email.trim())
                if (ok) {
                    _forgotPasswordState.value = ForgotPasswordState.Success("Password reset email sent successfully")
                } else {
                    _forgotPasswordState.value = ForgotPasswordState.Error("Failed to send reset email")
                }
            } catch (e: Exception) {
                _forgotPasswordState.value = ForgotPasswordState.Error(e.message ?: "Network error occurred")
            }
        }
    }

    fun logoutUser() {
        viewModelScope.launch {
            try { userRepository.logout() } catch (_: Exception) {}
            _loginState.value = LoginState.Idle
        }
    }

    fun logout() = logoutUser()
    fun resetLoginState() { _loginState.value = LoginState.Idle }
    fun resetForgotPasswordState() { _forgotPasswordState.value = ForgotPasswordState.Idle }
}

================================================================================
FILE: features/auth/interfaces/ui/RegisterScreen.kt  (size: 8275 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.interfaces.ui

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.PasswordTextField
import com.bankingsystem.mobile.core.modules.common.designsystem.ValidatedTextField
import com.bankingsystem.mobile.core.modules.common.util.checkPasswordStrength
import com.bankingsystem.mobile.core.modules.common.util.doPasswordsMatch
import com.bankingsystem.mobile.core.modules.common.util.isValidEmail

@Composable
fun RegisterScreen(
    onRegisterSuccess: () -> Unit,
    onNavigateToLogin: () -> Unit,
) {
    val viewModel: RegisterViewModel = hiltViewModel()

    var username by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var confirmPassword by remember { mutableStateOf("") }

    val usernameAvailable by viewModel.usernameAvailable.collectAsState()
    val registerState by viewModel.registerState.collectAsState()

    val passwordStrength = checkPasswordStrength(password)
    val passwordsMatch = doPasswordsMatch(password, confirmPassword)
    val emailValid = isValidEmail(email)
    val cs = MaterialTheme.colorScheme

    LaunchedEffect(username) { viewModel.checkUsernameAvailability(username) }

    LaunchedEffect(registerState) {
        if (registerState is RegisterState.Success) {
            onRegisterSuccess()
            viewModel.resetRegisterState()
        }
    }

    fun validate(): Boolean =
        username.isNotBlank() &&
                usernameAvailable == true &&
                emailValid &&
                passwordStrength.score >= 4 &&
                passwordsMatch

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            contentAlignment = Alignment.Center
        ) {
            GlassPanel(
                modifier = Modifier
                    .fillMaxWidth()
                    .widthIn(max = 420.dp)
            ) {
                Text(
                    text = "Create Your Account",
                    style = MaterialTheme.typography.headlineMedium,
                    color = Color.White
                )

                Spacer(modifier = Modifier.height(16.dp))

                ValidatedTextField(
                    value = username,
                    onValueChange = { username = it },
                    label = "Username",
                    isError = username.isNotBlank() && usernameAvailable == false,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
                    supportingText = {
                        when {
                            username.isBlank() -> Text("Username is required", color = Color.White.copy(alpha = 0.7f))
                            usernameAvailable == null -> Text("Checking availability...", color = Color.White.copy(alpha = 0.7f))
                            usernameAvailable == true -> Text("Username is available", color = Color.Green)
                            else -> Text("Username is taken or too short", color = cs.error)
                        }
                    }
                )

                Spacer(modifier = Modifier.height(16.dp))

                ValidatedTextField(
                    value = email,
                    onValueChange = { email = it },
                    label = "Email",
                    isError = email.isNotBlank() && !emailValid,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                    supportingText = {
                        if (email.isNotBlank() && !emailValid) {
                            Text("Invalid email address", color = cs.error)
                        }
                    }
                )

                Spacer(modifier = Modifier.height(16.dp))

                PasswordTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = "Password",
                    isError = password.isNotBlank() && passwordStrength.score < 4,
                    supportingText = {
                        if (password.isNotBlank()) {
                            if (passwordStrength.issues.isEmpty()) {
                                Text("Strong password!", color = Color.Green)
                            } else {
                                Column { passwordStrength.issues.forEach { Text(it, color = cs.error) } }
                            }
                        }
                    }
                )

                Spacer(modifier = Modifier.height(16.dp))

                PasswordTextField(
                    value = confirmPassword,
                    onValueChange = { confirmPassword = it },
                    label = "Confirm Password",
                    isError = confirmPassword.isNotBlank() && !passwordsMatch,
                    supportingText = {
                        if (confirmPassword.isNotBlank()) {
                            if (passwordsMatch) Text("Passwords match", color = cs.primary)
                            else Text("Passwords do not match", color = cs.error)
                        }
                    }
                )

                Spacer(modifier = Modifier.height(22.dp))

                Button(
                    onClick = { viewModel.registerUser(username.trim(), email.trim(), password) },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = validate() && registerState != RegisterState.Loading
                ) {
                    if (registerState == RegisterState.Loading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            color = cs.onPrimary,
                            strokeWidth = 2.dp
                        )
                    } else {
                        Text("Register")
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))

                TextButton(onClick = onNavigateToLogin, modifier = Modifier.fillMaxWidth()) {
                    Text("Already have an account? Log In")
                }

                Spacer(modifier = Modifier.height(8.dp))

                when (registerState) {
                    is RegisterState.Error -> Text(
                        text = (registerState as RegisterState.Error).error,
                        color = cs.error
                    )
                    is RegisterState.Success -> Text(
                        text = (registerState as RegisterState.Success).message,
                        color = cs.primary
                    )
                    else -> {}
                }
            }
        }
    }
}

@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier,
        shape = MaterialTheme.shapes.large,
        color = cs.surface.copy(alpha = 0.20f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp
    ) {
        Column(
            modifier = Modifier
                .border(1.dp, cs.outline.copy(alpha = 0.35f), MaterialTheme.shapes.large)
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            content = content
        )
    }
}

================================================================================
FILE: features/auth/interfaces/ui/RegisterViewModel.kt  (size: 2238 bytes)
================================================================================
package com.bankingsystem.mobile.features.auth.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.auth.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

sealed class RegisterState {
    object Idle : RegisterState()
    object Loading : RegisterState()
    data class Success(val message: String) : RegisterState()
    data class Error(val error: String) : RegisterState()
}

@HiltViewModel
class RegisterViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel() {

    private val _usernameAvailable = MutableStateFlow<Boolean?>(null)
    val usernameAvailable: StateFlow<Boolean?> = _usernameAvailable

    private val _registerState = MutableStateFlow<RegisterState>(RegisterState.Idle)
    val registerState: StateFlow<RegisterState> = _registerState

    private var checkUsernameJob: Job? = null

    fun checkUsernameAvailability(username: String) {
        checkUsernameJob?.cancel()
        _usernameAvailable.value = null
        if (username.length < 3) {
            _usernameAvailable.value = false
            return
        }
        checkUsernameJob = viewModelScope.launch {
            delay(500)
            val available = repository.checkUsernameAvailability(username)
            _usernameAvailable.value = available
        }
    }

    fun registerUser(username: String, email: String, password: String) {
        viewModelScope.launch {
            _registerState.value = RegisterState.Loading
            val success = repository.registerUser(username, email, password)
            _registerState.value = if (success) {
                RegisterState.Success("Registration successful")
            } else {
                RegisterState.Error("Registration failed, please try again")
            }
        }
    }

    fun resetRegisterState() { _registerState.value = RegisterState.Idle }
}

================================================================================
FILE: features/customer/domain/model/CustomerRequest.kt  (size: 432 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.domain.model

data class CustomerRequest(
    val firstName: String,
    val lastName: String,
    val gender: String,
    val email: String,
    val phone: String,
    val address: String?,
    val dateOfBirth: String,
    val status: String = "ACTIVE",
    val userId: String? = null
)

data class CustomerResult(
    val id: String?,
    val status: String?
)

================================================================================
FILE: features/customer/domain/repository/CustomerRepository.kt  (size: 342 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.domain.repository

import com.bankingsystem.mobile.features.customer.domain.model.CustomerRequest
import com.bankingsystem.mobile.features.customer.domain.model.CustomerResult

interface CustomerRepository {
    suspend fun upsertSelf(req: CustomerRequest): Result<CustomerResult>
}

================================================================================
FILE: features/customer/integration/remote/api/CustomerApi.kt  (size: 651 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.integration.remote.api

import com.bankingsystem.mobile.features.customer.integration.remote.dto.CustomerRequestBody
import com.bankingsystem.mobile.features.customer.integration.remote.dto.CustomerResponseDto
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.POST
import retrofit2.http.PUT

interface CustomerApi {

    @PUT("api/v1/customers/me")
    suspend fun upsertMe(@Body body: CustomerRequestBody): Response<CustomerResponseDto>

    @POST("api/v1/customers")
    suspend fun create(@Body body: CustomerRequestBody): Response<CustomerResponseDto>
}

================================================================================
FILE: features/customer/integration/remote/dto/CustomerDtos.kt  (size: 672 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.integration.remote.dto

import com.bankingsystem.mobile.features.customer.domain.model.CustomerRequest

data class CustomerRequestBody(
    val firstName: String,
    val lastName: String,
    val gender: String,
    val email: String,
    val phone: String,
    val address: String?,
    val dateOfBirth: String,
    val status: String,
    val userId: String?
)

fun CustomerRequest.toBody() = CustomerRequestBody(
    firstName, lastName, gender, email, phone, address, dateOfBirth, status, userId
)

data class CustomerResponseDto(
    val id: String? = null,
    val status: String? = null
)

================================================================================
FILE: features/customer/integration/remote/repository/CustomerRepositoryImpl.kt  (size: 2183 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.integration.repository

import com.bankingsystem.mobile.features.customer.domain.model.CustomerRequest
import com.bankingsystem.mobile.features.customer.domain.model.CustomerResult
import com.bankingsystem.mobile.features.customer.domain.repository.CustomerRepository
import com.bankingsystem.mobile.features.customer.integration.remote.api.CustomerApi
import com.bankingsystem.mobile.features.customer.integration.remote.dto.toBody
import com.bankingsystem.mobile.features.profile.domain.repository.ProfileRepository
import retrofit2.HttpException
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CustomerRepositoryImpl @Inject constructor(
    private val api: CustomerApi,
    private val profileRepo: ProfileRepository
) : CustomerRepository {

    override suspend fun upsertSelf(req: CustomerRequest): Result<CustomerResult> = runCatching {
        // 1) Always include userId (backend validates @NotNull, even on /customers/me)
        val userId = req.userId ?: profileRepo.getMe().getOrThrow().userId
        val withUid = req.copy(userId = userId)

        // 2) Try self endpoint first
        val self = api.upsertMe(withUid.toBody())
        when {
            self.isSuccessful -> {
                val dto = self.body()
                return@runCatching CustomerResult(id = dto?.id, status = dto?.status)
            }
            self.code() == 409 -> { // KYC not approved
                throw IllegalStateException(
                    "Your identity verification must be approved before creating a customer profile."
                )
            }
            self.code() in setOf(404, 405, 501) -> {
                // 3) Backend without /me: fall back to staff POST (requires staff token)
                val fb = api.create(withUid.toBody())
                if (!fb.isSuccessful) throw HttpException(fb)
                val dto = fb.body()
                CustomerResult(id = dto?.id, status = dto?.status)
            }
            else -> throw HttpException(self) // e.g., 400 From validation, 403 forbidden, etc.
        }
    }
}

================================================================================
FILE: features/customer/interfaces/ui/CustomerRegistrationScreen.kt  (size: 13934 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.interfaces.ui

import android.os.Build
import androidx.annotation.RequiresApi
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Badge
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Phone
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground

@RequiresApi(Build.VERSION_CODES.O)
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CustomerRegistrationScreen(
    onBack: () -> Unit,
    onDone: () -> Unit,
    vm: CustomerRegistrationViewModel = hiltViewModel()
) {
    val ui by vm.ui.collectAsState()

    var genderMenu by remember { mutableStateOf(false) }
    var showDobPicker by remember { mutableStateOf(false) }

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                TopAppBar(
                    title = { Text("Customer Registration", color = Color.White) },
                    navigationIcon = {
                        IconButton(onClick = onBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White
                    )
                )
            },
            bottomBar = {
                Column(
                    modifier = Modifier
                        .navigationBarsPadding()
                        .imePadding()
                ) {
                    BottomEdgeScrim()
                    Button(
                        onClick = { vm.submit() },
                        enabled = ui.canSubmit && !ui.submitting,
                        modifier = Modifier
                            .padding(horizontal = 20.dp, vertical = 12.dp)
                            .fillMaxWidth(),
                        shape = RoundedCornerShape(16.dp)
                    ) { Text(if (ui.submitting) "Submitting…" else "Submit") }
                }
            }
        ) { pv ->
            Column(
                modifier = Modifier
                    .padding(pv)
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(20.dp)
            ) {
                GlassPanel {
                    Text(
                        "My Profile",
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.SemiBold,
                        color = Color.White
                    )
                    Spacer(Modifier.height(8.dp))

                    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        IconTextField(
                            value = ui.form.firstName,
                            onValueChange = { s -> vm.update { it.copy(firstName = s) } },
                            label = "First name*",
                            leading = Icons.Filled.Person,
                            keyboardType = KeyboardType.Text
                        )

                        IconTextField(
                            value = ui.form.lastName,
                            onValueChange = { s -> vm.update { it.copy(lastName = s) } },
                            label = "Last name*",
                            leading = Icons.Filled.Person,
                            keyboardType = KeyboardType.Text
                        )

                        ExposedDropdownMenuBox(
                            expanded = genderMenu,
                            onExpandedChange = { genderMenu = !genderMenu }
                        ) {
                            OutlinedTextField(
                                value = ui.form.gender,
                                onValueChange = {},
                                readOnly = true,
                                label = { Text("Gender*") },
                                leadingIcon = { Icon(Icons.Filled.Badge, null) },
                                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(genderMenu) },
                                modifier = Modifier.menuAnchor().fillMaxWidth(),
                                singleLine = true,
                                shape = RoundedCornerShape(14.dp),
                                colors = fieldColors()
                            )
                            ExposedDropdownMenu(
                                expanded = genderMenu,
                                onDismissRequest = { genderMenu = false }
                            ) {
                                listOf("MALE", "FEMALE", "OTHER").forEach { opt ->
                                    DropdownMenuItem(
                                        text = { Text(opt.lowercase().replaceFirstChar { it.titlecase() }) },
                                        onClick = {
                                            vm.update { it.copy(gender = opt) }
                                            genderMenu = false
                                        }
                                    )
                                }
                            }
                        }

                        IconTextField(
                            value = ui.form.email,
                            onValueChange = { s -> vm.update { it.copy(email = s) } },
                            label = "Email*",
                            leading = Icons.Filled.Email,
                            keyboardType = KeyboardType.Email
                        )

                        IconTextField(
                            value = ui.form.phone,
                            onValueChange = { s -> vm.update { it.copy(phone = s) } },
                            label = "Phone*",
                            leading = Icons.Filled.Phone,
                            keyboardType = KeyboardType.Phone
                        )

                        IconTextField(
                            value = ui.form.address,
                            onValueChange = { s -> vm.update { it.copy(address = s) } },
                            label = "Address",
                            leading = Icons.Filled.Home,
                            keyboardType = KeyboardType.Text
                        )

                        OutlinedTextField(
                            value = ui.form.dateOfBirth,
                            onValueChange = { /* read-only */ },
                            readOnly = true,
                            label = { Text("Date of birth*") },
                            leadingIcon = { Icon(Icons.Filled.CalendarToday, null) },
                            trailingIcon = {
                                IconButton(onClick = { showDobPicker = true }) {
                                    Icon(Icons.Filled.CalendarToday, contentDescription = "Pick date")
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            shape = RoundedCornerShape(14.dp),
                            colors = fieldColors(),
                            placeholder = { Text("YYYY-MM-DD") }
                        )

                        // Status (read-only)
                        OutlinedTextField(
                            value = ui.form.status,
                            onValueChange = { },
                            readOnly = true,
                            label = { Text("Status") },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            shape = RoundedCornerShape(14.dp),
                            colors = fieldColors()
                        )

                        Text(
                            "* Required fields",
                            style = MaterialTheme.typography.labelSmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }

        // Title contrast
        TopEdgeScrim()
    }

    // Date picker
    if (showDobPicker) {
        val state = rememberDatePickerState()
        DatePickerDialog(
            onDismissRequest = { showDobPicker = false },
            confirmButton = {
                TextButton(onClick = {
                    state.selectedDateMillis?.let { ms ->
                        val local = java.time.Instant.ofEpochMilli(ms)
                            .atZone(java.time.ZoneId.systemDefault())
                            .toLocalDate()
                        vm.update { it.copy(dateOfBirth = local.toString()) }
                    }
                    showDobPicker = false
                }) { Text("OK") }
            },
            dismissButton = { TextButton(onClick = { showDobPicker = false }) { Text("Cancel") } }
        ) { DatePicker(state = state) }
    }

    // Observe success / error
    LaunchedEffect(ui.success) { if (ui.success) onDone() }
    if (ui.error != null) {
        AlertDialog(
            onDismissRequest = vm::clearError,
            confirmButton = { TextButton(onClick = vm::clearError) { Text("OK") } },
            title = { Text("Submission failed") },
            text = { Text(ui.error ?: "") }
        )
    }
}

/* ===== visuals (same helpers you already use) ===== */

@Composable private fun GlassPanel(modifier: Modifier = Modifier, content: @Composable ColumnScope.() -> Unit) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier
            .fillMaxWidth()
            .border(width = 1.dp,
                brush = Brush.linearGradient(listOf(cs.outline.copy(0.45f), cs.outline.copy(0.15f))),
                shape = RoundedCornerShape(24.dp)
            ),
        shape = RoundedCornerShape(24.dp),
        color = cs.surface.copy(alpha = 0.10f),
        tonalElevation = 0.dp,
        shadowElevation = 10.dp
    ) {
        Column(
            modifier = Modifier
                .background(Brush.verticalGradient(listOf(Color.White.copy(alpha = 0.06f), Color.Transparent)))
                .padding(20.dp),
            verticalArrangement = Arrangement.spacedBy(20.dp),
            content = content
        )
    }
}

@Composable private fun IconTextField(
    value: String,
    onValueChange: (String) -> Unit,
    label: String,
    leading: androidx.compose.ui.graphics.vector.ImageVector,
    keyboardType: KeyboardType
) {
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        singleLine = true,
        label = { Text(label) },
        leadingIcon = { Icon(leading, null, tint = MaterialTheme.colorScheme.onSurfaceVariant) },
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(14.dp),
        keyboardOptions = KeyboardOptions(keyboardType = keyboardType),
        colors = fieldColors()
    )
}

@Composable private fun fieldColors() = OutlinedTextFieldDefaults.colors(
    focusedContainerColor = Color.White.copy(alpha = 0.10f),
    unfocusedContainerColor = Color.White.copy(alpha = 0.08f),
    disabledContainerColor = Color.White.copy(alpha = 0.06f),
    focusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.55f),
    unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.35f),
    focusedLabelColor = MaterialTheme.colorScheme.primary,
    cursorColor = MaterialTheme.colorScheme.primary
)

@Composable private fun BoxScope.TopEdgeScrim(height: Int = 56) {
    Box(
        modifier = Modifier
            .align(Alignment.TopCenter)
            .fillMaxWidth()
            .height(height.dp)
            .background(Brush.verticalGradient(listOf(Color.Black.copy(alpha = 0.28f), Color.Transparent)))
    )
}
@Composable private fun BottomEdgeScrim(height: Int = 16) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(height.dp)
            .background(Brush.verticalGradient(listOf(Color.Transparent, Color.Black.copy(alpha = 0.22f))))
    )
}

================================================================================
FILE: features/customer/interfaces/ui/CustomerRegistrationViewModel.kt  (size: 2931 bytes)
================================================================================
package com.bankingsystem.mobile.features.customer.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.customer.domain.model.CustomerRequest
import com.bankingsystem.mobile.features.customer.domain.repository.CustomerRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class CustomerForm(
    val firstName: String = "",
    val lastName: String = "",
    val gender: String = "",
    val email: String = "",
    val phone: String = "",
    val address: String = "",
    val dateOfBirth: String = "",
    val status: String = "ACTIVE"
)

data class CustomerUiState(
    val form: CustomerForm = CustomerForm(),
    val submitting: Boolean = false,
    val error: String? = null,
    val success: Boolean = false
) {
    val canSubmit: Boolean
        get() = form.firstName.isNotBlank() &&
                form.lastName.isNotBlank()  &&
                form.gender.isNotBlank()    &&
                form.email.isNotBlank()     &&
                form.phone.isNotBlank()     &&
                form.dateOfBirth.matches(Regex("""\d{4}-\d{2}-\d{2}"""))
}

@HiltViewModel
class CustomerRegistrationViewModel @Inject constructor(
    private val repo: CustomerRepository
) : ViewModel() {

    private val _ui = MutableStateFlow(CustomerUiState())
    val ui: StateFlow<CustomerUiState> = _ui.asStateFlow()

    fun update(block: (CustomerForm) -> CustomerForm) = _ui.update {
        it.copy(form = block(it.form), error = null)
    }

    fun submit() {
        val f = _ui.value.form
        if (!_ui.value.canSubmit || _ui.value.submitting) return

        _ui.update { it.copy(submitting = true, error = null) }

        viewModelScope.launch {
            val req = CustomerRequest(
                firstName = f.firstName.trim(),
                lastName  = f.lastName.trim(),
                gender    = f.gender.trim().uppercase(),
                email     = f.email.trim(),
                phone     = f.phone.trim(),
                address   = f.address.trim().ifBlank { null },
                dateOfBirth = f.dateOfBirth.trim(),
                status    = f.status
            )

            val result = repo.upsertSelf(req)

            _ui.update { state ->
                result.fold(
                    onSuccess = { _ -> state.copy(submitting = false, success = true) },
                    onFailure = { err -> state.copy(submitting = false, error = err.message ?: "Failed to submit") }
                )
            }
        }
    }


    fun clearError() = _ui.update { it.copy(error = null) }
}

================================================================================
FILE: features/home/interfaces/ui/BalanceCard.kt  (size: 3253 bytes)
================================================================================
package com.bankingsystem.mobile.features.home.interfaces.ui

import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInHorizontally
import androidx.compose.animation.slideOutHorizontally
import androidx.compose.animation.togetherWith
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun BalanceCard(balance: Double, modifier: Modifier = Modifier) {
    val cs = MaterialTheme.colorScheme
    val gradient = Brush.linearGradient(
        listOf(cs.onPrimary, cs.inversePrimary)
    )

    Surface(
        modifier = modifier,
        shape = RoundedCornerShape(24.dp),
        tonalElevation = 0.dp,
        shadowElevation = 8.dp
    ) {
        Box(
            Modifier
                .background(gradient)
                .padding(22.dp)
        ) {
            Column {
                Text(
                    "Account Balance",
                    style = MaterialTheme.typography.titleMedium,
                    color = cs.onPrimaryContainer
                )
                Spacer(Modifier.height(8.dp))
                AnimatedContent(
                    targetState = balance,
                    transitionSpec = {
                        (slideInHorizontally { it / 3 } + fadeIn()) togetherWith
                                (slideOutHorizontally { -it / 3 } + fadeOut())
                    },
                    label = "balance-anim"
                ) { value ->
                    Text(
                        "$${"%,.2f".format(value)}",
                        style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.ExtraBold),
                        color = cs.onPrimaryContainer
                    )
                }
            }
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(22.dp)
                    .align(Alignment.TopEnd)
                    .clip(RoundedCornerShape(bottomStart = 24.dp))
                    .background(Color.White.copy(0.08f))
            )
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(1.dp)
                    .align(Alignment.BottomCenter)
                    .background(Color.Black.copy(0.10f))
            )
        }
    }
}

================================================================================
FILE: features/home/interfaces/ui/BankHomeRoute.kt  (size: 535 bytes)
================================================================================
package com.bankingsystem.mobile.features.home.interfaces.ui

import androidx.compose.runtime.*
import androidx.hilt.navigation.compose.hiltViewModel

@Composable
fun BankHomeRoute(
    userName: String,
    selectedItem: String = "Home",
    onNavigate: (String) -> Unit
) {
    val vm: HomeViewModel = hiltViewModel()
    val ui by vm.ui.collectAsState()

    BankHomeScreen(
        userName = userName,
        balance = ui.balance,
        selectedItem = selectedItem,
        onNavigate = onNavigate
    )
}

================================================================================
FILE: features/home/interfaces/ui/BankHomeScreen.kt  (size: 10151 bytes)
================================================================================
package com.bankingsystem.mobile.features.home.interfaces.ui

import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.spring
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material.icons.filled.AccountBalance
import androidx.compose.material.icons.filled.AddCircle
import androidx.compose.material.icons.filled.Lightbulb
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material.icons.filled.Notifications
import androidx.compose.material.icons.filled.RemoveCircle
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.QuickAction
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar
import com.bankingsystem.mobile.features.home.interfaces.ui.model.UiTransaction

@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class, ExperimentalLayoutApi::class)
@Composable
fun BankHomeScreen(
    userName: String = "Gimesha",
    balance: Double = 3500.0,
    transactions: List<UiTransaction> = listOf(
        UiTransaction ("1", "Starbucks", -5.75, "Aug 12"),
        UiTransaction("2", "Salary", 2000.00, "Aug 10"),
        UiTransaction("3", "Electricity Bill", -120.0, "Aug 08")
    ),
    selectedItem: String = "Home",
    onTransferClick: () -> Unit = {},
    onPayBillClick: () -> Unit = {},
    onDepositClick: () -> Unit = {},
    onNavigate: (String) -> Unit = {}
) {
    val cs = MaterialTheme.colorScheme
    var isSidebarOpen by remember { mutableStateOf(false) }
    val sidebarOffset by animateDpAsState(
        targetValue = if (isSidebarOpen) 0.dp else (-300).dp,
        animationSpec = spring(dampingRatio = Spring.DampingRatioNoBouncy, stiffness = Spring.StiffnessMediumLow),
        label = "sidebar"
    )
    val scrimAlpha by animateFloatAsState(if (isSidebarOpen) 0.5f else 0f, label = "scrim")
    val snackbarHostState = remember { SnackbarHostState() }
    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior()

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
            containerColor = Color.Transparent,
            topBar = {
                LargeTopAppBar(
                    title = {
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Icon(Icons.Filled.AccountBalance, null, tint = Color.White)
                            Spacer(Modifier.width(10.dp))
                            Text(
                                "MyBank",
                                style = MaterialTheme.typography.titleLarge.copy(
                                    fontWeight = FontWeight.SemiBold,
                                    color = Color.White
                                )
                            )
                        }
                    },
                    navigationIcon = {
                        IconButton(onClick = { isSidebarOpen = !isSidebarOpen }) {
                            Icon(Icons.Filled.Menu, contentDescription = "Open navigation", tint = Color.White)
                        }
                    },
                    actions = {
                        IconButton(onClick = {}) {
                            Icon(Icons.Filled.Notifications, contentDescription = "Notifications", tint = Color.White)
                        }
                    },
                    colors = TopAppBarDefaults.largeTopAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    ),
                    scrollBehavior = scrollBehavior
                )
            },
            snackbarHost = { SnackbarHost(snackbarHostState) }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(horizontal = 20.dp, vertical = 16.dp)
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Box(
                        modifier = Modifier
                            .size(56.dp)
                            .clip(RoundedCornerShape(14.dp))
                            .background(cs.primaryContainer),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = userName.firstOrNull()?.uppercase() ?: "?",
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontWeight = FontWeight.Bold,
                                color = cs.onPrimaryContainer
                            )
                        )
                    }
                    Spacer(Modifier.width(14.dp))
                    Column {
                        Text(
                            text = "Welcome back,",
                            style = MaterialTheme.typography.bodyMedium.copy(color = Color.White.copy(alpha = 0.85f))
                        )
                        Text(
                            text = userName,
                            style = MaterialTheme.typography.headlineMedium.copy(
                                fontWeight = FontWeight.Bold,
                                color = Color.White
                            )
                        )
                    }
                }

                Spacer(Modifier.height(18.dp))

                BalanceCard(balance = balance, modifier = Modifier.fillMaxWidth())

                Spacer(Modifier.height(22.dp))

                GlassPanel {
                    Text(
                        text = "Quick Actions",
                        style = MaterialTheme.typography.titleLarge.copy(
                            fontWeight = FontWeight.SemiBold,
                            color = Color.White
                        )
                    )
                    Spacer(Modifier.height(12.dp))
                    FlowRow(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        maxItemsInEachRow = 2
                    ) {
                        QuickAction("Withdraw", Icons.Filled.RemoveCircle, onDepositClick)
                        QuickAction("Pay Bill", Icons.Filled.Lightbulb, onPayBillClick)
                        QuickAction("Transfer", Icons.AutoMirrored.Filled.Send, onTransferClick)
                        QuickAction("Deposit", Icons.Filled.AddCircle, onDepositClick)
                    }
                }

                Spacer(Modifier.height(22.dp))

                GlassPanel {
                    Text(
                        text = "Recent Transactions",
                        style = MaterialTheme.typography.titleLarge.copy(
                            fontWeight = FontWeight.SemiBold,
                            color = Color.White
                        )
                    )
                    Spacer(Modifier.height(8.dp))
                    TransactionListSwipe(transactions = transactions, snackbarHostState = snackbarHostState)
                }
            }
        }

        if (scrimAlpha > 0f) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(cs.scrim.copy(alpha = scrimAlpha))
                    .clickable { isSidebarOpen = false }
            )
        }

        Surface(
            modifier = Modifier
                .fillMaxHeight()
                .width(300.dp)
                .offset(x = sidebarOffset),
            tonalElevation = 0.dp,
            shadowElevation = 16.dp,
            shape = RoundedCornerShape(topEnd = 16.dp, bottomEnd = 16.dp),
        ) {
            Sidebar(
                selectedItem = selectedItem,
                onItemClick = {
                    isSidebarOpen = false
                    onNavigate(it)
                },
                userName = userName
            )
        }
    }
}

@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(24.dp),
        color = cs.surface.copy(alpha = 0.10f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp
    ) {
        Column(
            modifier = Modifier
                .border(1.dp, cs.outline.copy(alpha = 0.35f), RoundedCornerShape(24.dp))
                .padding(16.dp),
            content = content
        )
    }
}

================================================================================
FILE: features/home/interfaces/ui/HomeViewModel.kt  (size: 1871 bytes)
================================================================================
package com.bankingsystem.mobile.features.home.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.core.modules.common.storage.DefaultAccountStore
import com.bankingsystem.mobile.features.accounts.domain.repository.AccountRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class HomeUiState(
    val loading: Boolean = true,
    val error: String? = null,
    val balance: Double = 0.0,
    val defaultAccountId: String? = null
)

@HiltViewModel
class HomeViewModel @Inject constructor(
    private val repo: AccountRepository,
    private val defaults: DefaultAccountStore
) : ViewModel() {

    private val _ui = MutableStateFlow(HomeUiState())
    val ui: StateFlow<HomeUiState> = _ui.asStateFlow()

    init {
        viewModelScope.launch {
            defaults.defaultAccountId.collect { id ->
                _ui.update { it.copy(defaultAccountId = id) }
                refresh()
            }
        }
    }

    fun refresh() {
        viewModelScope.launch {
            _ui.update { it.copy(loading = true, error = null) }
            try {
                val accounts = repo.getMyAccounts()
                val pick = accounts.firstOrNull { it.accountId == _ui.value.defaultAccountId }
                    ?: accounts.firstOrNull()
                _ui.update { it.copy(loading = false, balance = pick?.balance ?: 0.0) }
            } catch (e: Exception) {
                _ui.update { it.copy(loading = false, error = e.message ?: "Failed to load") }
            }
        }
    }
}

================================================================================
FILE: features/home/interfaces/ui/model/UiTransaction.kt  (size: 192 bytes)
================================================================================
package com.bankingsystem.mobile.features.home.interfaces.ui.model

data class UiTransaction(
    val id: String,
    val title: String,
    val amount: Double,
    val date: String
)

================================================================================
FILE: features/home/interfaces/ui/Transactions.kt  (size: 6888 bytes)
================================================================================
package com.bankingsystem.mobile.features.home.interfaces.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Surface
import androidx.compose.material3.SwipeToDismissBox
import androidx.compose.material3.SwipeToDismissBoxValue
import androidx.compose.material3.Text
import androidx.compose.material3.rememberSwipeToDismissBoxState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.home.interfaces.ui.model.UiTransaction
import kotlin.math.abs

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TransactionListSwipe(
    transactions: List<UiTransaction>,
    snackbarHostState: SnackbarHostState
) {
    val list = remember(transactions) { mutableStateListOf(*transactions.toTypedArray()) }

    LazyColumn(
        verticalArrangement = Arrangement.spacedBy(10.dp),
        contentPadding = PaddingValues(vertical = 4.dp)
    ) {
        items(items = list, key = { it.id }) { txn ->
            val dismissState = rememberSwipeToDismissBoxState(
                confirmValueChange = { value ->
                    value == SwipeToDismissBoxValue.EndToStart
                },
                positionalThreshold = { totalDistance -> totalDistance * 0.35f }
            )

            if (dismissState.currentValue == SwipeToDismissBoxValue.EndToStart) {
                LaunchedEffect(txn.id) {
                    val index = list.indexOf(txn)
                    if (index >= 0) {
                        list.removeAt(index)
                        val result = snackbarHostState.showSnackbar(
                            message = "Transaction '${txn.title}' deleted",
                            actionLabel = "Undo",
                            withDismissAction = true,
                            duration = SnackbarDuration.Short
                        )
                        if (result == SnackbarResult.ActionPerformed) {
                            list.add(index.coerceAtMost(list.size), txn)
                        }
                    }
                }
            }

            SwipeToDismissBox(
                state = dismissState,
                enableDismissFromStartToEnd = false,
                enableDismissFromEndToStart = true,
                backgroundContent = {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .heightIn(min = 60.dp)
                            .clip(RoundedCornerShape(12.dp))
                            .background(MaterialTheme.colorScheme.errorContainer),
                        contentAlignment = Alignment.CenterEnd
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Delete,
                            contentDescription = "Delete",
                            tint = MaterialTheme.colorScheme.onErrorContainer,
                            modifier = Modifier.padding(end = 20.dp)
                        )
                    }
                },
                content = {
                    Surface(
                        tonalElevation = 1.dp,
                        shape = RoundedCornerShape(12.dp)
                    ) {
                        TransactionItem(
                            transaction = txn,
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 14.dp, vertical = 12.dp)
                        )
                    }
                }
            )
        }
    }
}

@Composable
private fun TransactionItem(transaction: UiTransaction, modifier: Modifier = Modifier) {
    val isCredit = transaction.amount >= 0
    val dotColor = if (isCredit) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error
    val amountText = (if (isCredit) "+$" else "-$") + "%,.2f".format(abs(transaction.amount))

    Row(
        modifier = modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Row(verticalAlignment = Alignment.CenterVertically) {
            Box(
                Modifier
                    .size(10.dp)
                    .clip(CircleShape)
                    .background(dotColor)
            )
            Spacer(Modifier.width(12.dp))
            Column {
                Text(transaction.title, style = MaterialTheme.typography.bodyLarge, fontWeight = FontWeight.SemiBold)
                Text(transaction.date, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
            }
        }
        Surface(
            shape = RoundedCornerShape(12.dp),
            color = if (isCredit) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.errorContainer
        ) {
            Text(
                amountText,
                modifier = Modifier.padding(horizontal = 10.dp, vertical = 6.dp),
                style = MaterialTheme.typography.labelLarge.copy(fontFeatureSettings = "tnum"),
                color = if (isCredit) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onErrorContainer
            )
        }
    }
}

================================================================================
FILE: features/kyc/domain/model/KycCaseStatus.kt  (size: 180 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.domain.model

data class KycCaseStatus(
    val caseId: String,
    val status: String,
    val decisionReason: String? = null
)

================================================================================
FILE: features/kyc/domain/model/KycCheck.kt  (size: 173 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.domain.model

data class KycCheck(
    val type: String,
    val score: Double? = null,
    val passed: Boolean? = null
)

================================================================================
FILE: features/kyc/domain/model/KycSubmitResponse.kt  (size: 132 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.domain.model

data class KycSubmitResponse(val caseId: String, val status: String)

================================================================================
FILE: features/kyc/domain/model/KycUploadIds.kt  (size: 202 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.domain.model

data class KycUploadIds(
    val docFrontId: String,
    val docBackId: String,
    val selfieId: String,
    val addressId: String
)

================================================================================
FILE: features/kyc/domain/model/UploadedPart.kt  (size: 103 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.domain.model

data class UploadedPart(val id: String)

================================================================================
FILE: features/kyc/domain/repository/KycRepository.kt  (size: 425 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.domain.repository

import android.net.Uri
import com.bankingsystem.mobile.features.kyc.domain.model.*

interface KycRepository {
    suspend fun upload(uri: Uri, type: String): UploadedPart
    suspend fun submit(consent: Boolean, ids: KycUploadIds): KycSubmitResponse
    suspend fun myCase(): KycCaseStatus
    suspend fun myChecks(caseId: String): List<KycCheck>
}

================================================================================
FILE: features/kyc/integration/remote/api/KycApi.kt  (size: 1277 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.remote.api

import com.bankingsystem.mobile.features.kyc.domain.model.KycSubmitResponse
import com.bankingsystem.mobile.features.kyc.domain.model.UploadedPart
import com.bankingsystem.mobile.features.kyc.integration.remote.dto.KycCaseStatusResponse
import com.bankingsystem.mobile.features.kyc.integration.remote.dto.KycCheckDto
import com.bankingsystem.mobile.features.kyc.integration.remote.dto.KycSubmitBody
import okhttp3.MultipartBody
import okhttp3.RequestBody
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.Multipart
import retrofit2.http.POST
import retrofit2.http.Part
import retrofit2.http.Path

interface KycApi {

    @Multipart
    @POST("kyc/upload")
    suspend fun uploadImage(
        @Part file: MultipartBody.Part,
        @Part("type") type: RequestBody // "DOC_FRONT","DOC_BACK","SELFIE","ADDRESS_PROOF"
    ): UploadedPart // { id: String }

    @POST("kyc/submit")
    suspend fun submit(@Body body: KycSubmitBody): Response<KycSubmitResponse>

    @GET("kyc/me")
    suspend fun me(): KycCaseStatusResponse

    @GET("kyc/{id}/checks")
    suspend fun checks(@Path("id") caseId: String): List<KycCheckDto>
}

================================================================================
FILE: features/kyc/integration/remote/dto/KycCaseStatusResponse.kt  (size: 198 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.remote.dto

data class KycCaseStatusResponse(
    val caseId: String,
    val status: String,
    val decisionReason: String? = null
)

================================================================================
FILE: features/kyc/integration/remote/dto/KycCheckDto.kt  (size: 186 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.remote.dto

data class KycCheckDto(
    val type: String,
    val score: Double? = null,
    val passed: Boolean? = null
)

================================================================================
FILE: features/kyc/integration/remote/dto/KycSubmitBody.kt  (size: 238 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.remote.dto

data class KycSubmitBody(
    val docFrontId: String,
    val docBackId: String,
    val selfieId: String,
    val addressId: String,
    val consent: Boolean
)

================================================================================
FILE: features/kyc/integration/remote/dto/KycSubmitResponse.kt  (size: 142 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.remote.dto

data class KycSubmitResponse(val caseId: String, val status: String)

================================================================================
FILE: features/kyc/integration/remote/dto/UploadedPart.kt  (size: 113 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.remote.dto

data class UploadedPart(val id: String)

================================================================================
FILE: features/kyc/integration/repository/KycRepositoryImpl.kt  (size: 2994 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.integration.repository

import android.content.Context
import android.net.Uri
import com.bankingsystem.mobile.features.kyc.domain.model.*
import com.bankingsystem.mobile.features.kyc.domain.repository.KycRepository
import com.bankingsystem.mobile.features.kyc.integration.remote.api.KycApi
import com.bankingsystem.mobile.features.kyc.integration.remote.dto.KycSubmitBody
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.MultipartBody
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import okio.source

@Singleton
class KycRepositoryImpl @Inject constructor(
    private val api: KycApi,
    @ApplicationContext private val ctx: Context
) : KycRepository {

    private fun requestBodyFromUri(uri: Uri): RequestBody {
        val resolver = ctx.contentResolver
        val mime = resolver.getType(uri) ?: "image/jpeg"
        return object : RequestBody() {
            override fun contentType() = mime.toMediaType()
            override fun writeTo(sink: okio.BufferedSink) {
                resolver.openInputStream(uri)?.use { input -> sink.writeAll(input.source()) }
            }
        }
    }

    private fun partFromUri(uri: Uri, name: String): MultipartBody.Part {
        val resolver = ctx.contentResolver
        val mime = resolver.getType(uri)?.lowercase() ?: "image/jpeg"
        val ext = when (mime) { "image/png" -> "png"; "image/webp" -> "webp"; else -> "jpg" }
        val body = requestBodyFromUri(uri)
        return MultipartBody.Part.createFormData("file", "$name.$ext", body)
    }

    override suspend fun upload(uri: Uri, type: String): UploadedPart {
        val dto = api.uploadImage(
            partFromUri(uri, type),
            type.toRequestBody("text/plain".toMediaType())
        )
        return UploadedPart(dto.id)
    }

    override suspend fun submit(consent: Boolean, ids: KycUploadIds): KycSubmitResponse {
        val resp = api.submit(
            KycSubmitBody(
                docFrontId = ids.docFrontId,
                docBackId  = ids.docBackId,
                selfieId   = ids.selfieId,
                addressId  = ids.addressId,
                consent    = consent
            )
        )
        if (!resp.isSuccessful || resp.body() == null) {
            throw IllegalStateException(resp.errorBody()?.string() ?: "Submit failed")
        }
        val body = resp.body()!!
        return KycSubmitResponse(caseId = body.caseId, status = body.status)
    }

    override suspend fun myCase(): KycCaseStatus {
        val d = api.me()
        return KycCaseStatus(d.caseId, d.status, d.decisionReason)
    }

    override suspend fun myChecks(caseId: String): List<KycCheck> =
        api.checks(caseId).map { KycCheck(it.type, it.score, it.passed) }
}

================================================================================
FILE: features/kyc/interfaces/ui/KycCameraHelpers.kt  (size: 1062 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import android.content.Context
import androidx.camera.core.CameraInfoUnavailableException
import androidx.camera.core.CameraSelector
import androidx.camera.lifecycle.ProcessCameraProvider
import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale
import kotlin.math.max
import kotlin.math.min

internal fun ProcessCameraProvider.hasCameraSafe(selector: CameraSelector): Boolean =
    try { hasCamera(selector) } catch (_: CameraInfoUnavailableException) { false }

internal fun createTempImageFile(context: Context): File {
    val dir = File(context.cacheDir, "images").apply { mkdirs() }
    val ts = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(System.currentTimeMillis())
    return File(dir, "selfie_$ts.jpg")
}

internal fun ArrayDeque<Float>.minVal(): Float =
    this.fold(Float.POSITIVE_INFINITY) { acc, v -> min(acc, v) }

internal fun ArrayDeque<Float>.maxVal(): Float =
    this.fold(Float.NEGATIVE_INFINITY) { acc, v -> max(acc, v) }

================================================================================
FILE: features/kyc/interfaces/ui/KycComponents.kt  (size: 4031 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.Face
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.AssistChip
import androidx.compose.material3.AssistChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
internal fun KycPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(24.dp),
        color = cs.surface.copy(alpha = 0.10f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp,
        border = BorderStroke(1.dp, cs.outline.copy(alpha = 0.35f))
    ) {
        Column(modifier = Modifier.padding(16.dp), content = content)
    }
}

@Composable
internal fun StepHeaderRow(current: KycStep, modifier: Modifier = Modifier) {
    val steps = listOf(
        Triple(Icons.Filled.CreditCard, "ID", KycStep.Document),
        Triple(Icons.Filled.Face, "Selfie", KycStep.Selfie),
        Triple(Icons.Filled.Home, "Address", KycStep.Address),
        Triple(Icons.Filled.CheckCircle, "Review", KycStep.Review)
    )
    Row(
        modifier = modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(10.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        steps.forEach { (icon, label, step) ->
            val active = step == current
            AssistChip(
                onClick = { },
                label = {
                    Text(
                        label,
                        color = if (active) MaterialTheme.colorScheme.primary
                        else Color.White.copy(0.70f)
                    )
                },
                leadingIcon = {
                    Icon(
                        imageVector = icon,
                        contentDescription = null,
                        tint = if (active) MaterialTheme.colorScheme.primary
                        else Color.White.copy(0.70f)
                    )
                },
                border = BorderStroke(
                    1.dp,
                    (if (active) MaterialTheme.colorScheme.primary else Color.White).copy(alpha = 0.45f)
                ),
                colors = AssistChipDefaults.assistChipColors(
                    containerColor = Color.White.copy(alpha = if (active) 0.10f else 0.06f)
                )
            )
        }
    }
}

@Composable
internal fun SourceChooserDialog(
    onDismiss: () -> Unit,
    onCamera: () -> Unit,
    onGallery: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Add photo from") },
        text = { Text("Choose a source") },
        confirmButton = { TextButton(onClick = onCamera) { Text("Camera") } },
        dismissButton = { TextButton(onClick = onGallery) { Text("Gallery") } }
    )
}

================================================================================
FILE: features/kyc/interfaces/ui/KycModels.kt  (size: 814 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import android.net.Uri

enum class KycStep { Document, Selfie, Address, Review }

data class DocQuality(
    val blurScore: Float? = null,
    val glareScore: Float? = null,
    val cornerCoverage: Int? = null
)

data class OcrField(
    val label: String,
    val value: String,
    val confidence: Float? = null
)

data class KycUiState(
    val step: KycStep = KycStep.Document,
    val docFront: Uri? = null,
    val docBack: Uri? = null,
    val docQuality: DocQuality = DocQuality(),
    val ocrFields: List<OcrField> = emptyList(),
    val selfie: Uri? = null,
    val livenessScore: Float? = null,
    val faceMatchScore: Float? = null,
    val addressProof: Uri? = null,
    val consentAccepted: Boolean = false
)

================================================================================
FILE: features/kyc/interfaces/ui/KycRoute.kt  (size: 8904 bytes)
================================================================================
@file:Suppress("OPT_IN_IS_NOT_ENABLED", "OPT_IN_USAGE")

package com.bankingsystem.mobile.features.kyc.interfaces.ui

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.app.navigation.Routes
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File

private const val DEV_PREVIEW = false

private enum class PickTarget { NONE, FRONT, BACK, SELFIE, ADDRESS }

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun KycRoute(
    userName: String,
    onNavigate: (String) -> Unit = {}
) {
    val vm: KycViewModel = hiltViewModel()
    val ui by vm.ui.collectAsState()
    val uploading by vm.uploading.collectAsState()
    val ctx = LocalContext.current
    val scope = rememberCoroutineScope()

    LaunchedEffect(ui.docFront, ui.docBack) {
        val q = withContext(Dispatchers.Default) {
            val fronts =
                ui.docFront?.let { decodeBitmapForAnalyze(ctx, it)?.let(::computeDocQuality) }
            val backs =
                ui.docBack?.let { decodeBitmapForAnalyze(ctx, it)?.let(::computeDocQuality) }
            if (fronts == null && backs == null) null
            else DocQuality(
                blurScore = listOfNotNull(fronts?.blurScore, backs?.blurScore).minOrNull(),
                glareScore = listOfNotNull(fronts?.glareScore, backs?.glareScore).minOrNull(),
                cornerCoverage = listOfNotNull(
                    fronts?.cornerCoverage,
                    backs?.cornerCoverage
                ).minOrNull()
            )
        }
        vm.setDocQuality(q ?: DocQuality())
        val d = q ?: DocQuality()
        Log.d(
            "KYC",
            "docFront=${ui.docFront != null}, docBack=${ui.docBack != null}, " +
                    "blur=${d.blurScore}, glare=${d.glareScore}, corners=${d.cornerCoverage}"
        )
    }


    var showChooser by remember { mutableStateOf(false) }
    var target by remember { mutableStateOf(PickTarget.NONE) }

    var pendingCameraUri by remember { mutableStateOf<Uri?>(null) }
    var pendingCameraTarget by remember { mutableStateOf(PickTarget.NONE) }
    var lastRequestedTarget by remember { mutableStateOf(PickTarget.NONE) }

    val takePicture = rememberLauncherForActivityResult(
        ActivityResultContracts.TakePicture()
    ) { ok ->
        if (ok) {
            when (pendingCameraTarget) {
                PickTarget.FRONT -> vm.setDocFront(pendingCameraUri)
                PickTarget.BACK -> vm.setDocBack(pendingCameraUri)
                PickTarget.SELFIE -> {
                    vm.setSelfie(pendingCameraUri)
                    vm.setLiveness(0.9f)
                    vm.setFaceMatch(0.9f)
                }

                PickTarget.ADDRESS -> vm.setAddressProof(pendingCameraUri)
                else -> {}
            }
        }
        pendingCameraTarget = PickTarget.NONE
        pendingCameraUri = null
    }

    val pickVisual = rememberLauncherForActivityResult(
        ActivityResultContracts.PickVisualMedia()
    ) { uri ->
        uri ?: return@rememberLauncherForActivityResult
        when (target) {
            PickTarget.FRONT -> vm.setDocFront(uri)
            PickTarget.BACK -> vm.setDocBack(uri)
            PickTarget.SELFIE -> {
                vm.setSelfie(uri)
                vm.setLiveness(0.9f)
                vm.setFaceMatch(0.9f)
            }

            PickTarget.ADDRESS -> vm.setAddressProof(uri)
            else -> {}
        }
    }

    val requestCameraPerm = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { granted ->
        if (granted && lastRequestedTarget != PickTarget.NONE) {
            pendingCameraUri?.let { takePicture.launch(it) }
        }
    }

    fun createTempImageUri(local: Context): Uri {
        val dir = File(local.cacheDir, "images").apply { mkdirs() }
        val file = File.createTempFile("kyc_", ".jpg", dir)
        return FileProvider.getUriForFile(local, "${local.packageName}.fileprovider", file)
    }

    fun launchCameraFor(local: Context, which: PickTarget) {
        lastRequestedTarget = which
        val uri = createTempImageUri(local)
        pendingCameraUri = uri
        pendingCameraTarget = which
        val granted = ContextCompat.checkSelfPermission(
            local,
            Manifest.permission.CAMERA
        ) == PackageManager.PERMISSION_GRANTED
        if (granted) takePicture.launch(uri) else requestCameraPerm.launch(Manifest.permission.CAMERA)
    }

    fun openGalleryFor(which: PickTarget) {
        target = which
        pickVisual.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
    }

    Box(Modifier.fillMaxSize()) {
        when (ui.step) {
            KycStep.Document -> DocumentCaptureScreen(
                frontUri = ui.docFront,
                backUri = ui.docBack,
                onPickFront = { target = PickTarget.FRONT; showChooser = true },
                onRemoveFront = { vm.setDocFront(null) },
                onPickBack = { target = PickTarget.BACK; showChooser = true },
                onRemoveBack = { vm.setDocBack(null) },
                onBack = { onNavigate("Home") },
                onNext = { if (DEV_PREVIEW || vm.canContinueFromDocument()) vm.next() },
                canContinue = !uploading && (DEV_PREVIEW || vm.canContinueFromDocument())
            )

            KycStep.Selfie -> SelfieLivenessScreen(
                onBack = { vm.back() },
                onNext = { if (DEV_PREVIEW || vm.canContinueFromSelfie()) vm.next() },
                canContinue = !uploading && (DEV_PREVIEW || vm.canContinueFromSelfie()),
                selfieUri = ui.selfie,
                onCaptureSelfie = { target = PickTarget.SELFIE; showChooser = true },
                onPickFromGallery = { target = PickTarget.SELFIE; showChooser = true },
                onSelfieReady = { uri ->
                    vm.setSelfie(uri)
                    vm.setLiveness(0.9f)
                    vm.setFaceMatch(0.9f)
                }
            )

            KycStep.Address -> AddressProofScreen(
                proofUri = ui.addressProof,
                onCapture = { target = PickTarget.ADDRESS; showChooser = true },
                onPickFromGallery = { target = PickTarget.ADDRESS; showChooser = true },
                onRemove = { vm.setAddressProof(null) },
                onBack = { vm.back() },
                onNext = { if (DEV_PREVIEW || vm.canContinueFromAddress()) vm.next() },
                canContinue = !uploading && (DEV_PREVIEW || vm.canContinueFromAddress())
            )

            KycStep.Review -> KycReviewScreen(
                onBack = { vm.back() },
                onSubmit = {
                    Log.d("KYC", "Review: onSubmit tapped")
                    scope.launch {
                        val ok = vm.submit()
                        Log.d("KYC", "Review: submit() returned ok=$ok")
                        if (ok) onNavigate(Routes.KYC_STATUS)else onNavigate(Routes.HOME)
                    }
                },
                canSubmit = !uploading && vm.readyToSubmit(),
                consent = ui.consentAccepted,
                onToggleConsent = vm::setConsent
            )
        }

        if (showChooser && target != PickTarget.NONE) {
            SourceChooserDialog(
                onDismiss = { showChooser = false; target = PickTarget.NONE },
                onCamera = { showChooser = false; launchCameraFor(ctx, target) },
                onGallery = { showChooser = false; openGalleryFor(target) }
            )
        }
    }
}

================================================================================
FILE: features/kyc/interfaces/ui/KycScreens.kt  (size: 26006 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import android.net.Uri
import android.view.Surface
import androidx.camera.core.AspectRatio
import androidx.camera.core.CameraSelector
import androidx.camera.core.ExperimentalGetImage
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBarsPadding
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.AddAPhoto
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.Button
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Checkbox
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedCard
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.compose.LocalLifecycleOwner
import coil.compose.AsyncImage
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.face.Face
import com.google.mlkit.vision.face.FaceDetection
import com.google.mlkit.vision.face.FaceDetectorOptions
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlin.math.abs

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun KycScaffold(
    title: String,
    onBack: () -> Unit,
    bottomBar: @Composable () -> Unit = {},
    content: @Composable (PaddingValues) -> Unit
) {
    Box(Modifier) {
        FadingAppBackground()
        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                TopAppBar(
                    title = { Text(title, color = Color.White) },
                    navigationIcon = {
                        IconButton(onClick = onBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, null, tint = Color.White)
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    )
                )
            },
            bottomBar = {
                Surface(color = Color.Transparent, tonalElevation = 0.dp, shadowElevation = 0.dp) {
                    bottomBar()
                }
            },
            content = content
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DocumentCaptureScreen(
    frontUri: Uri?,
    backUri: Uri?,
    onPickFront: () -> Unit,
    onRemoveFront: () -> Unit,
    onPickBack: () -> Unit,
    onRemoveBack: () -> Unit,
    onBack: () -> Unit,
    onNext: () -> Unit,
    canContinue: Boolean = false
) {
    KycScaffold(
        title = "Verify your ID",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onNext,
                enabled = canContinue,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Continue") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Document)
            KycPanel {
                Text("Capture both sides of your national ID.", style = MaterialTheme.typography.titleMedium, color = Color.White)
                Spacer(Modifier.height(12.dp))
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    DocSlot("Front side", frontUri, onPickFront, onRemoveFront, Modifier.weight(1f))
                    DocSlot("Back side", backUri, onPickBack, onRemoveBack, Modifier.weight(1f))
                }
                Spacer(Modifier.height(12.dp))
                OutlinedButton(onClick = onBack) { Text("Back") }
                Spacer(Modifier.height(10.dp))
                if (canContinue) Text("Looks good • tap Continue", color = Color.White.copy(0.8f))
            }
        }
    }
}

@Composable
private fun DocSlot(
    title: String,
    uri: Uri?,
    onPick: () -> Unit,
    onRemove: () -> Unit,
    modifier: Modifier = Modifier
) {
    val frame = RoundedCornerShape(18.dp)
    val grad = Brush.linearGradient(
        listOf(
            Color(0xFF5B67F3).copy(alpha = 0.22f),
            Color(0xFF5B67F3).copy(alpha = 0.08f)
        )
    )
    Surface(
        modifier = modifier,
        shape = frame,
        tonalElevation = 0.dp,
        border = BorderStroke(1.dp, Color.White.copy(alpha = 0.18f)),
        color = Color.Transparent
    ) {
        Column(
            modifier = Modifier
                .background(grad, frame)
                .padding(14.dp),
            verticalArrangement = Arrangement.spacedBy(10.dp)
        ) {
            Text(title, style = MaterialTheme.typography.titleMedium, color = Color.White)
            if (uri == null) {
                OutlinedCard(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(140.dp),
                    shape = RoundedCornerShape(14.dp),
                    colors = CardDefaults.outlinedCardColors(
                        containerColor = Color.White.copy(alpha = 0.08f),
                        contentColor = Color.White
                    ),
                    border = BorderStroke(1.dp, Color.White.copy(0.15f))
                ) {
                    Box(Modifier.fillMaxWidth().height(140.dp), contentAlignment = Alignment.Center) {
                        OutlinedButton(onClick = onPick) {
                            Icon(Icons.Filled.AddAPhoto, null, tint = Color.White)
                            Spacer(Modifier.width(8.dp))
                            Text("Add photo", color = Color.White)
                        }
                    }
                }
            } else {
                AsyncImage(
                    model = uri,
                    contentDescription = null,
                    contentScale = ContentScale.Crop,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(140.dp)
                        .clip(RoundedCornerShape(14.dp))
                )
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    OutlinedButton(onClick = onRemove) {
                        Icon(Icons.Filled.Delete, null, tint = Color.White)
                        Spacer(Modifier.width(6.dp))
                        Text("Remove", color = Color.White)
                    }
                }
            }
        }
    }
}

@Suppress("OPT_IN_ARGUMENT_IS_NOT_MARKER")
@androidx.annotation.OptIn(ExperimentalGetImage::class)
@OptIn(ExperimentalMaterial3Api::class, ExperimentalGetImage::class)
@Composable
fun SelfieLivenessScreen(
    onBack: () -> Unit,
    onNext: () -> Unit,
    canContinue: Boolean = true,
    selfieUri: Uri? = null,
    onCaptureSelfie: () -> Unit = {},
    onPickFromGallery: () -> Unit = {},
    onSelfieReady: (Uri) -> Unit = {}
) {
    val ctx = LocalContext.current
    val owner = LocalLifecycleOwner.current

    // --- NEW: keep refs so we can unbind on dispose ---
    var cameraProvider by remember { mutableStateOf<ProcessCameraProvider?>(null) }
    var boundPreview by remember { mutableStateOf<Preview?>(null) }
    var boundImageCapture by remember { mutableStateOf<ImageCapture?>(null) }
    var boundAnalysis by remember { mutableStateOf<ImageAnalysis?>(null) }

    var error by remember { mutableStateOf<String?>(null) }
    var progress by remember { mutableFloatStateOf(0f) }
    var capturing by remember { mutableStateOf(false) }
    val needCenteredFrames = 8
    val centerTolX = 0.25f
    val centerTolY = 0.28f
    val blinkCloseThr = 0.45f
    val blinkOpenThr = 0.55f
    val yawWindowSize = 18
    val yawMinRange = 3f
    val yawMaxRange = 35f
    var centeredFrames by remember { mutableIntStateOf(0) }
    var lastLeftOpen by remember { mutableStateOf<Boolean?>(null) }
    var lastRightOpen by remember { mutableStateOf<Boolean?>(null) }
    var blinked by remember { mutableStateOf(false) }
    val yawWindow = remember { ArrayDeque<Float>() }

    val previewView = remember(ctx) { PreviewView(ctx).apply { scaleType = PreviewView.ScaleType.FIT_CENTER } }
    val imageCapture = remember {
        ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .setTargetAspectRatio(AspectRatio.RATIO_16_9)
            .build()
    }
    val detector = remember {
        FaceDetection.getClient(
            FaceDetectorOptions.Builder()
                .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)
                .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)
                .enableTracking()
                .build()
        )
    }

    LaunchedEffect(owner) {
        try {
            val provider = withContext(Dispatchers.Default) { ProcessCameraProvider.getInstance(ctx).get() }
            cameraProvider = provider

            val front = CameraSelector.DEFAULT_FRONT_CAMERA
            val back  = CameraSelector.DEFAULT_BACK_CAMERA
            val selector = if (provider.hasCameraSafe(front)) front else back
            if (!provider.hasCameraSafe(selector)) {
                error = "No available camera can be found"
                return@LaunchedEffect
            }

            val rotation = previewView.display?.rotation ?: Surface.ROTATION_0
            val preview = Preview.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9)
                .setTargetRotation(rotation)
                .build()
                .also { it.setSurfaceProvider(previewView.surfaceProvider) }

            val mainExec = ContextCompat.getMainExecutor(ctx)

            val analyzer = ImageAnalysis.Analyzer { proxy ->
                val media = proxy.image ?: run { proxy.close(); return@Analyzer }
                val image = InputImage.fromMediaImage(media, proxy.imageInfo.rotationDegrees)
                detector.process(image)
                    .addOnSuccessListener(mainExec) { faces: List<Face> ->
                        if (faces.size == 1) {
                            val f = faces[0]
                            val w = image.width.toFloat()
                            val h = image.height.toFloat()
                            val cx = f.boundingBox.centerX() / w
                            val cy = f.boundingBox.centerY() / h
                            val centered = abs(cx - 0.5f) < centerTolX && abs(cy - 0.5f) < centerTolY
                            centeredFrames = if (centered) (centeredFrames + 1).coerceAtMost(60) else (centeredFrames - 2).coerceAtLeast(0)
                            val centerOk = centeredFrames >= needCenteredFrames

                            val le = f.leftEyeOpenProbability
                            val re = f.rightEyeOpenProbability
                            val openNow = (le != null && le > blinkOpenThr) || (re != null && re > blinkOpenThr)
                            val closedNow = (le != null && le < blinkCloseThr) || (re != null && re < blinkCloseThr)
                            val wasOpen = (lastLeftOpen == true) || (lastRightOpen == true)
                            if (!blinked && wasOpen && closedNow) blinked = true
                            lastLeftOpen = le?.let { it > blinkOpenThr }
                            lastRightOpen = re?.let { it > blinkOpenThr }
                            val blinkOk = blinked && openNow

                            val yaw = f.headEulerAngleY
                            yawWindow.addLast(yaw)
                            if (yawWindow.size > yawWindowSize) yawWindow.removeFirst()
                            val minYaw = yawWindow.minOrNull() ?: 0f
                            val maxYaw = yawWindow.maxOrNull() ?: 0f
                            val yawRange = maxYaw - minYaw
                            val moveOk = yawRange in yawMinRange..yawMaxRange

                            val p1 = if (centerOk) 1f else centeredFrames / needCenteredFrames.toFloat()
                            val p2 = if (blinkOk) 1f else 0f
                            val p3 = if (moveOk) 1f else (yawRange / yawMinRange).coerceIn(0f, 1f)
                            progress = (p1 + p2 + p3) / 3f

                            val satisfied = listOf(centerOk, blinkOk, moveOk).count { it } >= 2
                            if (satisfied && !capturing) {
                                capturing = true
                                val out = createTempImageFile(ctx)
                                val opts = ImageCapture.OutputFileOptions.Builder(out).build()
                                imageCapture.takePicture(
                                    opts,
                                    mainExec,
                                    object : ImageCapture.OnImageSavedCallback {
                                        override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                                            onSelfieReady(Uri.fromFile(out))
                                        }
                                        override fun onError(exc: ImageCaptureException) {
                                            error = exc.message
                                            capturing = false
                                        }
                                    }
                                )
                            }
                        }
                    }
                    .addOnFailureListener(mainExec) { e -> error = e.message }
                    .addOnCompleteListener(mainExec) { proxy.close() }
            }

            val analysis = ImageAnalysis.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9)
                .setTargetRotation(rotation)
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also { it.setAnalyzer(mainExec, analyzer) }

            provider.unbindAll()
            provider.bindToLifecycle(owner, selector, preview, imageCapture, analysis)

            // remember bound use cases for cleanup
            boundPreview = preview
            boundImageCapture = imageCapture
            boundAnalysis = analysis

            error = null
        } catch (e: Exception) {
            error = e.message ?: "Failed to start camera"
        }
    }

    // --- NEW: clean up when leaving composition / owner changes / app goes background ---
    DisposableEffect(owner) {
        val obs = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_STOP) {
                cameraProvider?.let { prov ->
                    boundAnalysis?.clearAnalyzer()
                    runCatching { prov.unbindAll() }
                }
            }
        }
        owner.lifecycle.addObserver(obs)

        onDispose {
            owner.lifecycle.removeObserver(obs)
            boundAnalysis?.clearAnalyzer()

            detector.close()

            cameraProvider?.let { prov ->
                val useCases = listOfNotNull(boundPreview, boundImageCapture, boundAnalysis).toTypedArray()
                runCatching {
                    if (useCases.isNotEmpty()) prov.unbind(*useCases) else prov.unbindAll()
                }
            }

            boundPreview = null
            boundImageCapture = null
            boundAnalysis = null
            cameraProvider = null
        }
    }


    KycScaffold(
        title = "Face verification",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onNext,
                enabled = canContinue,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Continue") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Selfie)
            KycPanel {
                AndroidView(
                    factory = { previewView },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(280.dp)
                        .clip(RoundedCornerShape(18.dp))
                )
                LinearProgressIndicator(
                    progress = progress,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 10.dp)
                )
                Text("Center your face in the frame", color = Color.White)
                if (error != null) {
                    Spacer(Modifier.height(6.dp))
                    Text(error!!, color = MaterialTheme.colorScheme.error)
                }
                Spacer(Modifier.height(10.dp))
                Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
                    OutlinedButton(onClick = onPickFromGallery) { Text("Pick from gallery") }
                    OutlinedButton(onClick = onCaptureSelfie, enabled = error == null) { Text("Capture") }
                }
            }
        }
    }
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddressProofScreen(
    proofUri: Uri? = null,
    onCapture: () -> Unit = {},
    onPickFromGallery: () -> Unit = {},
    onRemove: () -> Unit = {},
    onBack: () -> Unit,
    onNext: () -> Unit,
    canContinue: Boolean = true
) {
    KycScaffold(
        title = "Proof of address",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onNext,
                enabled = canContinue,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Continue") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Address)
            KycPanel {
                val grad = Brush.linearGradient(
                    listOf(
                        Color(0xFF5B67F3).copy(alpha = 0.22f),
                        Color(0xFF5B67F3).copy(alpha = 0.08f)
                    )
                )
                Surface(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(180.dp),
                    shape = RoundedCornerShape(18.dp),
                    tonalElevation = 0.dp,
                    border = BorderStroke(1.dp, Color.White.copy(alpha = 0.18f)),
                    color = Color.Transparent
                ) {
                    Box(
                        Modifier
                            .background(grad, RoundedCornerShape(18.dp))
                            .fillMaxWidth()
                            .height(180.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        if (proofUri == null) {
                            Text("Upload / capture utility bill, lease, etc.", color = Color.White)
                        } else {
                            AsyncImage(
                                model = proofUri,
                                contentDescription = null,
                                contentScale = ContentScale.Crop,
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .height(180.dp)
                                    .clip(RoundedCornerShape(18.dp))
                            )
                        }
                    }
                }
                Spacer(Modifier.height(10.dp))
                Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
                    OutlinedButton(onClick = onPickFromGallery) { Text("Pick from gallery") }
                    OutlinedButton(onClick = onCapture) { Text("Capture") }
                    if (proofUri != null) OutlinedButton(onClick = onRemove) { Text("Remove") }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun KycReviewScreen(
    onBack: () -> Unit,
    onSubmit: () -> Unit,
    canSubmit: Boolean,
    consent: Boolean,
    onToggleConsent: (Boolean) -> Unit
) {
    KycScaffold(
        title = "Review & submit",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onSubmit,
                enabled = canSubmit,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Submit") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Review)
            KycPanel {
                Row(
                    Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text("KYC summary", style = MaterialTheme.typography.titleMedium, color = Color.White)
                    Icon(Icons.Filled.CheckCircle, null, tint = Color(0xFF34D399))
                }
                Spacer(Modifier.height(8.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Checkbox(checked = consent, onCheckedChange = onToggleConsent)
                    Text("I confirm the information is accurate and I consent to verification.", color = Color.White)
                }
            }
        }
    }
}

================================================================================
FILE: features/kyc/interfaces/ui/KycStatusRoute.kt  (size: 10452 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.spring
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Badge
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.Face
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.app.navigation.Routes
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar
import com.bankingsystem.mobile.features.kyc.domain.model.KycCheck

@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)
@Composable
fun KycStatusRoute(
    userName: String,
    selectedItem: String = "KYC Status",
    onNavigate: (String) -> Unit = {}
) {
    val vm: KycViewModel = hiltViewModel()
    val status by vm.status.collectAsState()
    val checks by vm.checks.collectAsState()

    val isApproved = status?.status?.equals("APPROVED", ignoreCase = true) == true

    DisposableEffect(Unit) {
        vm.startPollingStatus()
        onDispose { vm.stopPollingStatus() }
    }

    val cs = MaterialTheme.colorScheme
    var isSidebarOpen by remember { mutableStateOf(false) }
    val sidebarWidth by animateDpAsState(
        targetValue = if (isSidebarOpen) 280.dp else 0.dp,
        animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy),
        label = "sidebar"
    )
    val scrimAlpha by animateFloatAsState(if (isSidebarOpen) 0.5f else 0f, label = "scrim")

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                LargeTopAppBar(
                    title = { Text("KYC Status", color = Color.White) },
                    navigationIcon = {
                        IconButton(onClick = { isSidebarOpen = !isSidebarOpen }) {
                            Icon(Icons.Filled.Menu, contentDescription = "Open navigation", tint = Color.White)
                        }
                    },
                    colors = TopAppBarDefaults.largeTopAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    )
                )
            },
            // NEW: show CTA only when approved
            bottomBar = {
                if (isApproved) {
                    Surface(tonalElevation = 1.dp) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Button(
                                onClick = { onNavigate(Routes.CUSTOMER_REG) },
                                modifier = Modifier.fillMaxWidth()
                            ) { Text("Proceed to Customer Registration") }
                        }
                    }
                }
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(horizontal = 20.dp, vertical = 16.dp),
                verticalArrangement = Arrangement.spacedBy(18.dp)
            ) {
                StatusCard(
                    statusText = status?.status,
                    reason = status?.decisionReason
                )

                ChecksCard(checks = checks)
            }
        }

        // Sidebar + scrim
        if (isSidebarOpen) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color.Black.copy(alpha = scrimAlpha))
                    .clickable { isSidebarOpen = false }
            )
        }
        if (isSidebarOpen) {
            Sidebar(
                selectedItem = selectedItem,
                onItemClick = {
                    isSidebarOpen = false
                    onNavigate(it)
                },
                userName = userName
            )
        }
    }
}

/* ---------- Status card ---------- */

@Composable
private fun StatusCard(
    statusText: String?,
    reason: String?
) {
    val st = (statusText ?: "UNDER_REVIEW").uppercase()
    val terminal = st == "APPROVED" || st == "REJECTED"

    KycPanel {
        Row(
            Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(
                "Current status",
                style = MaterialTheme.typography.titleMedium,
                color = Color.White
            )
            StatusPill(text = st)
        }

        if (!terminal) {
            Spacer(Modifier.height(10.dp))
            LinearProgressIndicator(modifier = Modifier.fillMaxWidth())
            Spacer(Modifier.height(4.dp))
            Text(
                "We’re reviewing your documents. You can keep using the app.",
                color = Color.White.copy(alpha = 0.85f),
                style = MaterialTheme.typography.bodyMedium
            )
        }

        ReasonList(reason)
    }
}

/* ---------- Checks card ---------- */

@Composable
private fun ChecksCard(checks: List<KycCheck>?) {
    if (checks.isNullOrEmpty()) return
    KycPanel {
        Column(Modifier.fillMaxWidth(), verticalArrangement = Arrangement.spacedBy(8.dp)) {
            Text("Checks", color = Color.White, style = MaterialTheme.typography.titleMedium)
            LazyColumn(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                items(checks) { c -> CheckRow(c) }
            }
        }
    }
}

@Composable
private fun CheckRow(c: KycCheck) {
    val icon = when (c.type.uppercase()) {
        "FACE_MATCH" -> Icons.Filled.Face
        "OCR_ID", "DOC_CLASS" -> Icons.Filled.CreditCard
        else -> Icons.Filled.Badge
    }
    val color = if (c.passed == true) Color(0xFF4CAF50) else Color(0xFFE53935)

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(14.dp))
            .background(Color.White.copy(alpha = 0.06f))
            .padding(12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(icon, contentDescription = null, tint = color)
        Spacer(Modifier.width(10.dp))
        Column(Modifier.weight(1f)) {
            Text(c.type.prettyLabel(), color = Color.White)
            Text(
                "Score: ${"%.2f".format(c.score)}",
                color = Color.White.copy(alpha = 0.85f),
                style = MaterialTheme.typography.bodySmall
            )
        }
        StatusPill(if (c.passed == true) "PASS" else "FAIL")
    }
}

/* ---------- small components ---------- */

@Composable
private fun StatusPill(text: String) {
    val color = when (text.uppercase()) {
        "APPROVED", "PASS" -> Color(0xFF2E7D32)
        "REJECTED", "FAIL" -> Color(0xFFC62828)
        else -> Color(0xFF1976D2)
    }
    Surface(
        color = color.copy(alpha = 0.18f),
        contentColor = Color.White,
        border = BorderStroke(1.dp, color),
        shape = RoundedCornerShape(999.dp)
    ) {
        Text(
            text = text,
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),
            style = MaterialTheme.typography.labelMedium
        )
    }
}

@Composable
private fun KycPanel(content: @Composable ColumnScope.() -> Unit) {
    Surface(
        modifier = Modifier.fillMaxWidth(),
        color = Color.White.copy(alpha = 0.07f),
        contentColor = Color.White,
        shape = RoundedCornerShape(18.dp),
        tonalElevation = 1.dp,
        border = BorderStroke(1.dp, Color.White.copy(alpha = 0.06f))
    ) {
        Column(modifier = Modifier.padding(16.dp), content = content)
    }
}

@Composable
private fun ReasonList(reason: String?) {
    val items = reason
        ?.split(';')
        ?.map { it.trim() }
        ?.filter { it.isNotBlank() }
        ?.map { it.replace('_', ' ').lowercase().replaceFirstChar { ch -> ch.titlecase() } }
        .orEmpty()

    if (items.isNotEmpty()) {
        Spacer(Modifier.height(12.dp))
        Text("Reason:", color = Color.White, style = MaterialTheme.typography.titleSmall)
        Spacer(Modifier.height(6.dp))
        Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
            items.forEach {
                Text("• $it", color = Color.White.copy(alpha = 0.92f), style = MaterialTheme.typography.bodyMedium)
            }
        }
    }
}

/* ---------- tiny helpers ---------- */

private fun String.prettyLabel(): String =
    trim().replace('_', ' ').lowercase().replaceFirstChar { it.titlecase() }

================================================================================
FILE: features/kyc/interfaces/ui/KycUtils.kt  (size: 4687 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.net.Uri
import androidx.core.content.FileProvider
import androidx.exifinterface.media.ExifInterface
import java.io.File
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sqrt

internal fun createImageUri(ctx: Context, name: String): Uri {
    val dir = File(ctx.cacheDir, "images").apply { mkdirs() }
    val file = File(dir, "${name}_${System.currentTimeMillis()}.jpg")
    return FileProvider.getUriForFile(ctx, "${ctx.packageName}.fileprovider", file)
}

fun decodeBitmapForAnalyze(context: Context, uri: Uri, maxDim: Int = 1024): Bitmap? {
    val resolver = context.contentResolver
    val opts = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    resolver.openInputStream(uri)?.use { BitmapFactory.decodeStream(it, null, opts) }
    val w = opts.outWidth
    val h = opts.outHeight
    if (w <= 0 || h <= 0) return null
    var sample = 1
    var largest = max(w, h)
    while (largest / sample > maxDim) sample *= 2
    val opts2 = BitmapFactory.Options().apply { inSampleSize = sample }
    val bmp = resolver.openInputStream(uri)?.use { BitmapFactory.decodeStream(it, null, opts2) } ?: return null
    val rotated = try {
        val orientation = resolver.openInputStream(uri)?.use { ins ->
            ExifInterface(ins).getAttributeInt(
                ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL
            )
        } ?: ExifInterface.ORIENTATION_NORMAL
        val matrix = Matrix().apply {
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> postRotate(270f)
            }
        }
        if (!matrix.isIdentity) Bitmap.createBitmap(bmp, 0, 0, bmp.width, bmp.height, matrix, true) else bmp
    } catch (_: Exception) {
        bmp
    }
    return rotated
}

fun computeDocQuality(bmp: Bitmap): DocQuality {
    val w = bmp.width
    val h = bmp.height
    val px = IntArray(w * h)
    bmp.getPixels(px, 0, w, 0, 0, w, h)
    val g = IntArray(px.size)
    for (i in px.indices) {
        val p = px[i]
        val r = (p shr 16) and 0xFF
        val gch = (p shr 8) and 0xFF
        val b = p and 0xFF
        g[i] = (0.299 * r + 0.587 * gch + 0.114 * b).toInt()
    }
    val blurScore = laplacianVarianceScore(g, w, h)
    val glareScore = 1f - brightFraction(g, threshold = 240)
    val corners = cornerCoverageCount(g, w, h)
    return DocQuality(
        blurScore = blurScore,
        glareScore = glareScore.coerceIn(0f, 1f),
        cornerCoverage = corners
    )
}

private fun laplacianVarianceScore(gray: IntArray, w: Int, h: Int): Float {
    var sum = 0.0
    var sumSq = 0.0
    var n = 0
    for (y in 1 until h - 1) {
        val yi = y * w
        for (x in 1 until w - 1) {
            val i = yi + x
            val v = (-4 * gray[i] +
                    gray[i - 1] + gray[i + 1] +
                    gray[i - w] + gray[i + w]).toDouble()
            sum += v
            sumSq += v * v
            n++
        }
    }
    if (n == 0) return 0f
    val mean = sum / n
    val variance = (sumSq / n) - mean * mean
    val norm = (variance / 2500.0).coerceIn(0.0, 1.0)
    return norm.toFloat()
}

private fun brightFraction(gray: IntArray, threshold: Int): Float {
    var bright = 0
    for (v in gray) if (v >= threshold) bright++
    return bright.toFloat() / gray.size.toFloat()
}

private fun cornerCoverageCount(gray: IntArray, w: Int, h: Int): Int {
    val pw = max(4, (w * 0.15f).toInt())
    val ph = max(4, (h * 0.15f).toInt())
    fun stddev(x0: Int, y0: Int): Double {
        var sum = 0.0
        var sumSq = 0.0
        var n = 0
        for (y in y0 until min(h, y0 + ph)) {
            var i = y * w + x0
            for (x in x0 until min(w, x0 + pw)) {
                val v = gray[i].toDouble()
                sum += v
                sumSq += v * v
                n++
                i++
            }
        }
        if (n == 0) return 0.0
        val mean = sum / n
        val varc = (sumSq / n) - mean * mean
        return sqrt(max(0.0, varc))
    }
    var count = 0
    if (stddev(0, 0) > 12) count++
    if (stddev(w - pw, 0) > 12) count++
    if (stddev(0, h - ph) > 12) count++
    if (stddev(w - pw, h - ph) > 12) count++
    return count
}

================================================================================
FILE: features/kyc/interfaces/ui/KycViewModel.kt  (size: 7350 bytes)
================================================================================
package com.bankingsystem.mobile.features.kyc.interfaces.ui

import android.net.Uri
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.kyc.domain.model.KycCaseStatus
import com.bankingsystem.mobile.features.kyc.domain.model.KycCheck
import com.bankingsystem.mobile.features.kyc.domain.model.KycUploadIds
import com.bankingsystem.mobile.features.kyc.domain.repository.KycRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class KycViewModel @Inject constructor(
    private val repo: KycRepository
) : ViewModel() {

    private val _ui = MutableStateFlow(KycUiState())
    val ui: StateFlow<KycUiState> = _ui.asStateFlow()

    private val _uploadedIds = MutableStateFlow<Map<String, String>>(emptyMap())
    val uploadedIds: StateFlow<Map<String, String>> = _uploadedIds.asStateFlow()

    private val _uploading = MutableStateFlow(false)
    val uploading: StateFlow<Boolean> = _uploading.asStateFlow()

    private val _status = MutableStateFlow<KycCaseStatus?>(null)
    val status: StateFlow<KycCaseStatus?> = _status.asStateFlow()

    private val _checks = MutableStateFlow<List<KycCheck>>(emptyList())
    val checks: StateFlow<List<KycCheck>> = _checks.asStateFlow()

    fun refreshStatusOnce() = viewModelScope.launch {
        val st = runCatching { repo.myCase() }.getOrNull()
        _status.value = st
        if (st != null) _checks.value = runCatching { repo.myChecks(st.caseId) }.getOrElse { emptyList() }
    }

    private var pollJob: Job? = null

    fun startPollingStatus(intervalMs: Long = 3000L) {
        if (pollJob?.isActive == true) return
        pollJob = viewModelScope.launch {
            while (isActive) {
                val st = runCatching { repo.myCase() }.getOrNull()
                _status.value = st
                if (st != null) {
                    val ch = runCatching { repo.myChecks(st.caseId) }.getOrElse { emptyList() }
                    _checks.value = ch
                }

                val s = _status.value?.status
                if (s == "APPROVED" || s == "REJECTED" || s == "NEEDS_MORE_INFO") break
                delay(intervalMs)
            }
        }
    }

    fun stopPollingStatus() {
        pollJob?.cancel()
        pollJob = null
    }

    fun pollStatusUntilTerminal(intervalMs: Long = 3000L) = startPollingStatus(intervalMs)


    fun go(step: KycStep) = _ui.update { it.copy(step = step) }

    fun next() = _ui.update {
        val s = when (it.step) {
            KycStep.Document -> KycStep.Selfie
            KycStep.Selfie -> KycStep.Address
            KycStep.Address -> KycStep.Review
            KycStep.Review -> KycStep.Review
        }
        it.copy(step = s)
    }

    fun back() = _ui.update {
        val s = when (it.step) {
            KycStep.Document -> KycStep.Document
            KycStep.Selfie -> KycStep.Document
            KycStep.Address -> KycStep.Selfie
            KycStep.Review -> KycStep.Address
        }
        it.copy(step = s)
    }

    fun setDocFront(uri: Uri?) { _ui.update { it.copy(docFront = uri) }; if (uri != null) upload("DOC_FRONT", uri) }
    fun setDocBack(uri: Uri?)  { _ui.update { it.copy(docBack = uri)  }; if (uri != null) upload("DOC_BACK", uri)  }
    fun setSelfie(uri: Uri?)   { _ui.update { it.copy(selfie = uri)   }; if (uri != null) upload("SELFIE", uri)    }
    fun setAddressProof(uri: Uri?) { _ui.update { it.copy(addressProof = uri) }; if (uri != null) upload("ADDRESS_PROOF", uri) }

    fun setDocQuality(q: DocQuality) = _ui.update { it.copy(docQuality = q) }
    fun setOcrFields(fields: List<OcrField>) = _ui.update { it.copy(ocrFields = fields) }
    fun setLiveness(score: Float?) = _ui.update { it.copy(livenessScore = score) }
    fun setFaceMatch(score: Float?) = _ui.update { it.copy(faceMatchScore = score) }
    fun setConsent(accepted: Boolean) = _ui.update { it.copy(consentAccepted = accepted) }

    private fun upload(type: String, uri: Uri) {
        viewModelScope.launch {
            _uploading.value = true
            runCatching { repo.upload(uri, type) }
                .onSuccess { part -> _uploadedIds.update { it + (type to part.id) } }
            _uploading.value = false
        }
    }

    fun canContinueFromDocument(): Boolean {
        val ok = ui.value.docFront != null && ui.value.docBack != null
        val q = ui.value.docQuality
        val blurOk = (q.blurScore ?: 1f) >= 0.10f
        val glareOk = (q.glareScore ?: 1f) >= 0.60f
        val cornersOk = (q.cornerCoverage ?: 0) >= 3
        return ok && blurOk && glareOk && cornersOk
    }

    fun canContinueFromSelfie(): Boolean {
        val liveOk = (ui.value.livenessScore ?: 0f) >= 0.60f
        val matchOk = (ui.value.faceMatchScore ?: 0f) >= 0.60f
        return ui.value.selfie != null && liveOk && matchOk
    }

    fun canContinueFromAddress(): Boolean = ui.value.addressProof != null
    fun canSubmit(): Boolean = ui.value.consentAccepted

    fun docsOk() = ui.value.docFront != null && ui.value.docBack != null
    fun selfieOk(): Boolean {
        val liveOk = (ui.value.livenessScore ?: 1f) >= 0.60f
        val matchOk = (ui.value.faceMatchScore ?: 1f) >= 0.60f
        return ui.value.selfie != null && liveOk && matchOk
    }
    fun addressOk() = ui.value.addressProof != null

    fun readyToSubmit(strict: Boolean = true): Boolean =
        if (strict) {
            docsOk() && selfieOk() && addressOk() && ui.value.consentAccepted
        } else {
            listOf(docsOk(), selfieOk(), addressOk()).count { it } >= 2 && ui.value.consentAccepted
        }

    suspend fun submit(): Boolean {
        Log.d("KYC", "submit(): invoked")

        if (!readyToSubmit(strict = true)) {
            Log.w("KYC", "submit(): not ready.")
            return false
        }
        val idsMap = uploadedIds.value
        val missing = listOf("DOC_FRONT","DOC_BACK","SELFIE","ADDRESS_PROOF").filterNot { it in idsMap }
        if (missing.isNotEmpty()) {
            Log.w("KYC", "submit(): missing upload ids: $missing")
            return false
        }

        return try {
            val ids = KycUploadIds(
                docFrontId = idsMap.getValue("DOC_FRONT"),
                docBackId  = idsMap.getValue("DOC_BACK"),
                selfieId   = idsMap.getValue("SELFIE"),
                addressId  = idsMap.getValue("ADDRESS_PROOF")
            )
            val result = repo.submit(consent = ui.value.consentAccepted, ids = ids)
            val okStatuses = setOf("PENDING","AUTO_REVIEW","UNDER_REVIEW","APPROVED","REJECTED","NEEDS_MORE_INFO")
            okStatuses.contains(result.status.trim().uppercase())
        } catch (e: Exception) {
            Log.e("KYC", "submit(): exception", e)
            false
        }
    }



}

================================================================================
FILE: features/lock/interfaces/ui/AppLocker.kt  (size: 710 bytes)
================================================================================
package com.bankingsystem.mobile.features.lock.interfaces.ui

import androidx.compose.runtime.*

@Composable
fun AppLocker(
    correctPin: String,
    onAuthenticated: () -> Unit
) {
    var usePin by remember { mutableStateOf(false) }
    var isAuthenticated by remember { mutableStateOf(false) }

    if (isAuthenticated) {
        onAuthenticated()
    } else {
        if (usePin) {
            PinUnlockScreen(correctPin = correctPin) {
                isAuthenticated = true
            }
        } else {
            LockScreen(
                onAuthenticated = { isAuthenticated = true },
                onFallbackToPin = { usePin = true }
            )
        }
    }
}

================================================================================
FILE: features/lock/interfaces/ui/LockScreen.kt  (size: 4245 bytes)
================================================================================
package com.bankingsystem.mobile.features.lock.interfaces.ui

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Fingerprint
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.fragment.app.FragmentActivity
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.util.showBiometricPrompt

@Composable
fun LockScreen(
    onAuthenticated: () -> Unit,
    onFallbackToPin: () -> Unit
) {
    val activity = (LocalContext.current as? FragmentActivity)
    var errorMessage by remember { mutableStateOf<String?>(null) }

    LaunchedEffect(Unit) {
        activity?.let {
            showBiometricPrompt(
                activity = it,
                onSuccess = { onAuthenticated() },
                onFailure = {
                    errorMessage = "Biometric failed. Try PIN."
                    onFallbackToPin()
                },
                onError = { error ->
                    errorMessage = error
                    onFallbackToPin()
                }
            )
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        FadingAppBackground()

        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            contentAlignment = Alignment.Center
        ) {
            Card(
                shape = MaterialTheme.shapes.large,
                elevation = CardDefaults.cardElevation(defaultElevation = 10.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.padding(24.dp)
                ) {
                    Surface(
                        color = MaterialTheme.colorScheme.primary.copy(alpha = 0.14f),
                        shape = CircleShape,
                        tonalElevation = 0.dp
                    ) {
                        Icon(
                            imageVector = Icons.Default.Fingerprint,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier
                                .size(72.dp)
                                .padding(14.dp)
                                .clip(CircleShape)
                        )
                    }

                    Text(
                        "Authenticate to Continue",
                        style = MaterialTheme.typography.titleLarge.copy(
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    )

                    if (errorMessage != null) {
                        Text(
                            errorMessage!!,
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }

                    OutlinedButton(
                        onClick = onFallbackToPin,
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = MaterialTheme.colorScheme.onSurface
                        ),
                        border = BorderStroke(1.dp, MaterialTheme.colorScheme.outline)
                    ) {
                        Text("Use PIN Instead")
                    }
                }
            }
        }
    }
}

================================================================================
FILE: features/lock/interfaces/ui/LockSetupScreen.kt  (size: 5411 bytes)
================================================================================
package com.bankingsystem.mobile.features.lock.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground

@Composable
fun LockSetupScreen(
    initialPin: String?,
    onSavePin: (String) -> Unit,
    onLockEnabledChange: (Boolean) -> Unit,
    onCancel: () -> Unit
) {
    var pin by remember { mutableStateOf(initialPin ?: "") }
    var confirmPin by remember { mutableStateOf("") }
    var error by remember { mutableStateOf<String?>(null) }

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            contentAlignment = Alignment.Center
        ) {
            Card(
                shape = MaterialTheme.shapes.large,
                elevation = CardDefaults.cardElevation(defaultElevation = 10.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.padding(24.dp)
                ) {
                    Surface(
                        color = MaterialTheme.colorScheme.primary.copy(alpha = 0.14f),
                        shape = CircleShape,
                        tonalElevation = 0.dp
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Lock,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier
                                .size(64.dp)
                                .padding(12.dp)
                                .clip(CircleShape)
                        )
                    }

                    Text(
                        "Set App Lock PIN",
                        style = MaterialTheme.typography.titleLarge.copy(
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    )

                    OutlinedTextField(
                        value = pin,
                        onValueChange = { pin = it.filter(Char::isDigit) },
                        label = { Text("Enter PIN") },
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.NumberPassword),
                        visualTransformation = PasswordVisualTransformation(),
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth()
                    )

                    OutlinedTextField(
                        value = confirmPin,
                        onValueChange = { confirmPin = it.filter(Char::isDigit) },
                        label = { Text("Confirm PIN") },
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.NumberPassword),
                        visualTransformation = PasswordVisualTransformation(),
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth()
                    )

                    if (error != null) {
                        Text(
                            error!!,
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }

                    Button(
                        onClick = {
                            when {
                                pin.length < 4 -> error = "PIN must be at least 4 digits"
                                pin != confirmPin -> error = "PINs do not match"
                                else -> {
                                    error = null
                                    onSavePin(pin)
                                    onLockEnabledChange(true)
                                }
                            }
                        },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Save PIN & Enable Lock")
                    }

                    OutlinedButton(
                        onClick = {
                            onLockEnabledChange(false)
                            onCancel()
                        },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Disable Lock")
                    }
                }
            }
        }
    }
}

================================================================================
FILE: features/lock/interfaces/ui/PinUnlockScreen.kt  (size: 3908 bytes)
================================================================================
package com.bankingsystem.mobile.features.lock.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LockOpen
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground

@Composable
fun PinUnlockScreen(
    correctPin: String,
    onAuthenticated: () -> Unit
) {
    var pinInput by remember { mutableStateOf("") }
    var error by remember { mutableStateOf<String?>(null) }

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            contentAlignment = Alignment.Center
        ) {
            Card(
                shape = MaterialTheme.shapes.large,
                elevation = CardDefaults.cardElevation(defaultElevation = 10.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.padding(24.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.LockOpen,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(56.dp)
                    )

                    Text(
                        "Enter your PIN to unlock",
                        style = MaterialTheme.typography.titleLarge.copy(
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    )

                    OutlinedTextField(
                        value = pinInput,
                        onValueChange = {
                            val digits = it.filter(Char::isDigit).take(6)
                            pinInput = digits
                            if (error != null) error = null
                        },
                        label = { Text("PIN") },
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.NumberPassword),
                        visualTransformation = PasswordVisualTransformation(),
                        singleLine = true,
                        isError = error != null,
                        supportingText = {
                            if (error != null) {
                                Text(
                                    text = error!!,
                                    color = MaterialTheme.colorScheme.error,
                                    style = MaterialTheme.typography.bodySmall
                                )
                            }
                        },
                        modifier = Modifier.fillMaxWidth()
                    )

                    Button(
                        onClick = {
                            if (pinInput == correctPin) onAuthenticated() else error = "Incorrect PIN"
                        },
                        enabled = pinInput.isNotEmpty(),
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Unlock")
                    }
                }
            }
        }
    }
}

================================================================================
FILE: features/payments/interfaces/ui/AccountSelector.kt  (size: 852 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType

@Composable
fun AccountSelector(
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        label = { Text(label) },
        singleLine = true,
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number, imeAction = ImeAction.Next),
        modifier = modifier
    )
}

================================================================================
FILE: features/payments/interfaces/ui/common.kt  (size: 448 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.runtime.Immutable

enum class PaymentKind { NONE, TRANSFER, DEPOSIT, WITHDRAW }

@Immutable
data class PaymentDraft(
    val kind: PaymentKind = PaymentKind.NONE,
    val sourceAccount: String = "",
    val destinationAccount: String = "",
    val destinationBank: String = "",
    val amount: String = "",
    val description: String = "",
)

================================================================================
FILE: features/payments/interfaces/ui/DepositScreen.kt  (size: 2689 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CallReceived
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp

@Composable
fun DepositScreen(
    modifier: Modifier = Modifier,
    onReview: (PaymentDraft) -> Unit,
) {
    val cs = MaterialTheme.colorScheme
    var target by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var desc by remember { mutableStateOf("") }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Surface(shape = RoundedCornerShape(16.dp), color = cs.primary.copy(alpha = 0.15f)) {
            Row(Modifier.fillMaxWidth().padding(14.dp), verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Filled.CallReceived, null, tint = Color.White)
                Spacer(Modifier.width(10.dp))
                Text("Deposit to your account", color = Color.White, style = MaterialTheme.typography.titleMedium)
            }
        }

        AccountSelector(label = "To account", value = target, onValueChange = { target = it })

        OutlinedTextField(
            value = amount,
            onValueChange = { amount = it },
            label = { Text("Amount") },
            keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Number, imeAction = ImeAction.Next),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = desc,
            onValueChange = { desc = it },
            label = { Text("Description (optional)") },
            singleLine = false,
            modifier = Modifier.fillMaxWidth()
        )

        Button(modifier = Modifier.fillMaxWidth(), onClick = {
            onReview(
                PaymentDraft(
                    kind = PaymentKind.DEPOSIT,
                    destinationAccount = target,
                    amount = amount,
                    description = desc
                )
            )
        }) { Text("Review deposit") }
    }
}

================================================================================
FILE: features/payments/interfaces/ui/PaymentReceiptScreen.kt  (size: 1351 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun PaymentReceiptScreen(
    modifier: Modifier = Modifier,
    draft: PaymentDraft,
    onDone: () -> Unit,
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(Icons.Default.CheckCircle, contentDescription = null, tint = MaterialTheme.colorScheme.primary, modifier = Modifier.size(64.dp))
        Spacer(Modifier.height(12.dp))
        Text("Payment ready", style = MaterialTheme.typography.titleLarge, color = Color.White)
        Spacer(Modifier.height(6.dp))
        Text("This is a UI-only preview. No money moved.", color = Color.White.copy(0.75f))
        Spacer(Modifier.height(16.dp))
        Button(onClick = onDone) { Text("Done") }
    }
}

================================================================================
FILE: features/payments/interfaces/ui/PaymentReviewScreen.kt  (size: 2125 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun PaymentReviewScreen(
    modifier: Modifier = Modifier,
    draft: PaymentDraft,
    onEdit: () -> Unit,
    onConfirm: () -> Unit,
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Review", style = MaterialTheme.typography.titleLarge, color = Color.White, fontWeight = FontWeight.SemiBold)

        Surface(shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp), color = MaterialTheme.colorScheme.surface.copy(alpha = 0.3f)) {
            Column(Modifier.fillMaxWidth().padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                LabeledValue("Type", draft.kind.name.lowercase().replaceFirstChar { it.uppercase() })
                if (draft.sourceAccount.isNotBlank()) LabeledValue("From", draft.sourceAccount)
                if (draft.destinationAccount.isNotBlank()) LabeledValue("To", draft.destinationAccount)
                if (draft.destinationBank.isNotBlank()) LabeledValue("Bank", draft.destinationBank)
                LabeledValue("Amount", draft.amount)
                if (draft.description.isNotBlank()) LabeledValue("Description", draft.description)
            }
        }

        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = onEdit) { Text("Edit") }
            Button(onClick = onConfirm) { Text("Confirm") }
        }
    }
}

@Composable
private fun LabeledValue(label: String, value: String) {
    Column { Text(label, style = MaterialTheme.typography.labelMedium, color = Color.White.copy(0.75f)); Text(value, color = Color.White) }
}

================================================================================
FILE: features/payments/interfaces/ui/PaymentsPicker.kt  (size: 4245 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material.icons.filled.CallMade
import androidx.compose.material.icons.filled.CallReceived
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun PaymentsPicker(
    modifier: Modifier = Modifier,
    onTransfer: () -> Unit,
    onDeposit: () -> Unit,
    onWithdraw: () -> Unit,
) {
    val cs = MaterialTheme.colorScheme
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header card – a bit darker for contrast
        Surface(
            shape = RoundedCornerShape(20.dp),
            color = cs.primary.copy(alpha = 0.28f),
            tonalElevation = 0.dp,
            shadowElevation = 0.dp
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(18.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(Modifier.weight(1f)) {
                    Text(
                        "Quick Payments",
                        color = Color.White,
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.SemiBold
                    )
                    Spacer(Modifier.height(6.dp))
                    Text(
                        "Transfer, deposit, or withdraw using your linked accounts.",
                        color = Color.White.copy(0.9f)
                    )
                }
            }
        }

        // Action cards – force dark container + white content for readability
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
            ActionCard(
                title = "Transfer",
                icon = Icons.AutoMirrored.Filled.Send,
                onClick = onTransfer,
                modifier = Modifier.weight(1f)
            )
            ActionCard(
                title = "Deposit",
                icon = Icons.Filled.CallReceived,
                onClick = onDeposit,
                modifier = Modifier.weight(1f)
            )
            ActionCard(
                title = "Withdraw",
                icon = Icons.Filled.CallMade,
                onClick = onWithdraw,
                modifier = Modifier.weight(1f)
            )
        }
    }
}

@Composable
private fun ActionCard(
    title: String,
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
) {
    val cs = MaterialTheme.colorScheme
    ElevatedCard(
        onClick = onClick,
        modifier = modifier,
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.elevatedCardColors(
            containerColor = cs.surface.copy(alpha = 0.22f),
            contentColor = Color.White
        ),
        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 0.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(10.dp),
            horizontalAlignment = Alignment.Start
        ) {
            Icon(icon, contentDescription = null, tint = Color.White)
            Text(title, style = MaterialTheme.typography.titleMedium, color = Color.White)
            Text(
                "Send money, top up, or cash out.",
                style = MaterialTheme.typography.bodySmall,
                color = Color.White.copy(0.9f)
            )
        }
    }
}

================================================================================
FILE: features/payments/interfaces/ui/PaymentsRoute.kt  (size: 4515 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PaymentsRoute(
    userName: String,
    selectedItem: String = "Payments",
    onNavigate: (String) -> Unit
) {
    var screen by remember { mutableStateOf(PaymentScreen.PICKER) }
    var draft by remember { mutableStateOf(PaymentDraft()) }

    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior()

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            containerColor = Color.Transparent,
            modifier = Modifier,
            topBar = {
                LargeTopAppBar(
                    title = { Text(selectedItem, color = Color.White) },
                    navigationIcon = {
                        if (screen != PaymentScreen.PICKER) {
                            IconButton(onClick = { screen = PaymentScreen.PICKER }) {
                                Icon(Icons.Default.ArrowBack, contentDescription = "Back", tint = Color.White)
                            }
                        }
                    },
                    colors = TopAppBarDefaults.largeTopAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White
                    ),
                    scrollBehavior = scrollBehavior
                )
            }
        ) { padding ->
            when (screen) {
                PaymentScreen.PICKER -> PaymentsPicker(
                    modifier = Modifier.padding(padding),
                    onTransfer = { screen = PaymentScreen.TRANSFER },
                    onDeposit = { screen = PaymentScreen.DEPOSIT },
                    onWithdraw = { screen = PaymentScreen.WITHDRAW }
                )
                PaymentScreen.TRANSFER -> TransferScreen(
                    modifier = Modifier.padding(padding).verticalScroll(rememberScrollState()),
                    onReview = {
                        draft = it
                        screen = PaymentScreen.REVIEW
                    }
                )
                PaymentScreen.DEPOSIT -> DepositScreen(
                    modifier = Modifier.padding(padding).verticalScroll(rememberScrollState()),
                    onReview = {
                        draft = it
                        screen = PaymentScreen.REVIEW
                    }
                )
                PaymentScreen.WITHDRAW -> WithdrawScreen(
                    modifier = Modifier.padding(padding).verticalScroll(rememberScrollState()),
                    onReview = {
                        draft = it
                        screen = PaymentScreen.REVIEW
                    }
                )
                PaymentScreen.REVIEW -> PaymentReviewScreen(
                    modifier = Modifier.padding(padding),
                    draft = draft,
                    onEdit = {
                        screen = when (draft.kind) {
                            PaymentKind.TRANSFER -> PaymentScreen.TRANSFER
                            PaymentKind.DEPOSIT -> PaymentScreen.DEPOSIT
                            PaymentKind.WITHDRAW -> PaymentScreen.WITHDRAW
                            else -> PaymentScreen.PICKER
                        }
                    },
                    onConfirm = { screen = PaymentScreen.RECEIPT }
                )
                PaymentScreen.RECEIPT -> PaymentReceiptScreen(
                    modifier = Modifier.padding(padding),
                    draft = draft,
                    onDone = { screen = PaymentScreen.PICKER }
                )
            }
        }
    }
}

private enum class PaymentScreen { PICKER, TRANSFER, DEPOSIT, WITHDRAW, REVIEW, RECEIPT }

================================================================================
FILE: features/payments/interfaces/ui/TransferScreen.kt  (size: 3666 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp

@Composable
fun TransferScreen(
    modifier: Modifier = Modifier,
    onReview: (PaymentDraft) -> Unit,
) {
    val cs = MaterialTheme.colorScheme

    var source by remember { mutableStateOf("") }
    var destAcc by remember { mutableStateOf("") }
    var destBank by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var desc by remember { mutableStateOf("") }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Surface(shape = RoundedCornerShape(16.dp), color = cs.primary.copy(alpha = 0.15f)) {
            Row(Modifier.fillMaxWidth().padding(14.dp), verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.AutoMirrored.Filled.Send, null, tint = Color.White)
                Spacer(Modifier.width(10.dp))
                Text("Transfer between accounts", color = Color.White, style = MaterialTheme.typography.titleMedium)
            }
        }

        AccountSelector(
            label = "From account",
            value = source,
            onValueChange = { source = it }
        )

        OutlinedTextField(
            value = destAcc,
            onValueChange = { destAcc = it },
            label = { Text("To account number") },
            keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Number, imeAction = ImeAction.Next),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = destBank,
            onValueChange = { destBank = it },
            label = { Text("Destination bank") },
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = amount,
            onValueChange = { amount = it },
            label = { Text("Amount") },
            keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Number, imeAction = ImeAction.Next),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = desc,
            onValueChange = { desc = it },
            label = { Text("Description (optional)") },
            singleLine = false,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(Modifier.height(4.dp))
        Button(modifier = Modifier.fillMaxWidth(), onClick = {
            onReview(
                PaymentDraft(
                    kind = PaymentKind.TRANSFER,
                    sourceAccount = source,
                    destinationAccount = destAcc,
                    destinationBank = destBank,
                    amount = amount,
                    description = desc,
                )
            )
        }) {
            Text("Review transfer")
        }
    }
}

================================================================================
FILE: features/payments/interfaces/ui/WithdrawScreen.kt  (size: 2686 bytes)
================================================================================
package com.bankingsystem.mobile.features.payments.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CallMade
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp

@Composable
fun WithdrawScreen(
    modifier: Modifier = Modifier,
    onReview: (PaymentDraft) -> Unit,
) {
    val cs = MaterialTheme.colorScheme
    var source by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var desc by remember { mutableStateOf("") }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Surface(shape = RoundedCornerShape(16.dp), color = cs.primary.copy(alpha = 0.15f)) {
            Row(Modifier.fillMaxWidth().padding(14.dp), verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Filled.CallMade, null, tint = Color.White)
                Spacer(Modifier.width(10.dp))
                Text("Withdraw from your account", color = Color.White, style = MaterialTheme.typography.titleMedium)
            }
        }

        AccountSelector(label = "From account", value = source, onValueChange = { source = it })

        OutlinedTextField(
            value = amount,
            onValueChange = { amount = it },
            label = { Text("Amount") },
            keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Number, imeAction = ImeAction.Next),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = desc,
            onValueChange = { desc = it },
            label = { Text("Description (optional)") },
            singleLine = false,
            modifier = Modifier.fillMaxWidth()
        )

        Button(modifier = Modifier.fillMaxWidth(), onClick = {
            onReview(
                PaymentDraft(
                    kind = PaymentKind.WITHDRAW,
                    sourceAccount = source,
                    amount = amount,
                    description = desc
                )
            )
        }) { Text("Review withdrawal") }
    }
}

================================================================================
FILE: features/profile/domain/model/UserProfile.kt  (size: 572 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.domain.model

data class UserProfile(
    val userId: String = "",
    val username: String = "",
    val firstName: String = "",
    val lastName: String = "",
    val address: String = "",
    val city: String = "",
    val state: String = "",
    val country: String = "",
    val postalCode: String = "",
    val homeNumber: String = "",
    val workNumber: String = "",
    val officeNumber: String = "",
    val mobileNumber: String = "",
    val email: String = "",
    val roleName: String = ""
)

================================================================================
FILE: features/profile/domain/repository/ProfileRepository.kt  (size: 391 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.domain.repository

import com.bankingsystem.mobile.features.profile.domain.model.UserProfile

interface ProfileRepository {
    suspend fun getMe(): Result<UserProfile>
    suspend fun updateMe(payload: Map<String, String>): Result<Unit>
    suspend fun changePassword(current: String, new: String, confirm: String): Result<Unit>
}

================================================================================
FILE: features/profile/integration/remote/api/ProfileApi.kt  (size: 713 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.integration.remote.api

import com.bankingsystem.mobile.features.profile.domain.model.UserProfile
import com.bankingsystem.mobile.features.profile.integration.remote.dto.UserProfileDto
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.PUT

interface ProfileApi {
    @GET("api/v1/users/me")
    suspend fun getMe(): UserProfileDto

    @PUT("api/v1/users/me")
    suspend fun updateMe(
        @Body payload: Map<String, String>
    ): Response<Unit>

    @PUT("/api/v1/auth/change-password")
    suspend fun changePassword(
        @Body body: Map<String, String>
    ): Response<Unit>
}

================================================================================
FILE: features/profile/integration/remote/dto/UserProfileDto.kt  (size: 1159 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.integration.remote.dto

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

@JsonClass(generateAdapter = true)
data class UserProfileDto(
    @Json(name = "userId")      val userId: String? = null,
    @Json(name = "username")    val username: String? = null,
    @Json(name = "firstName")   val firstName: String? = null,
    @Json(name = "lastName")    val lastName: String? = null,
    @Json(name = "address")     val address: String? = null,
    @Json(name = "city")        val city: String? = null,
    @Json(name = "state")       val state: String? = null,
    @Json(name = "country")     val country: String? = null,
    @Json(name = "postalCode")  val postalCode: String? = null,
    @Json(name = "homeNumber")  val homeNumber: String? = null,
    @Json(name = "workNumber")  val workNumber: String? = null,
    @Json(name = "officeNumber")val officeNumber: String? = null,
    @Json(name = "mobileNumber")val mobileNumber: String? = null,
    @Json(name = "email")       val email: String? = null,
    @Json(name = "roleName")    val roleName: String? = null
)

================================================================================
FILE: features/profile/integration/remote/dto/UserProfileDtoMapper.kt  (size: 802 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.integration.remote.dto

import com.bankingsystem.mobile.features.profile.domain.model.UserProfile

fun UserProfileDto.toDomain() = UserProfile(
    userId       = userId.orEmpty(),
    username     = username.orEmpty(),
    firstName    = firstName.orEmpty(),
    lastName     = lastName.orEmpty(),
    address      = address.orEmpty(),
    city         = city.orEmpty(),
    state        = state.orEmpty(),
    country      = country.orEmpty(),
    postalCode   = postalCode.orEmpty(),
    homeNumber   = homeNumber.orEmpty(),
    workNumber   = workNumber.orEmpty(),
    officeNumber = officeNumber.orEmpty(),
    mobileNumber = mobileNumber.orEmpty(),
    email        = email.orEmpty(),
    roleName     = roleName.orEmpty()
)

================================================================================
FILE: features/profile/integration/repository/ProfileRepositoryImpl.kt  (size: 1346 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.integration.repository

import com.bankingsystem.mobile.features.profile.domain.model.UserProfile
import com.bankingsystem.mobile.features.profile.domain.repository.ProfileRepository
import com.bankingsystem.mobile.features.profile.integration.remote.api.ProfileApi
import com.bankingsystem.mobile.features.profile.integration.remote.dto.toDomain
import javax.inject.Inject
import javax.inject.Singleton
import retrofit2.HttpException

@Singleton
class ProfileRepositoryImpl @Inject constructor(
    private val api: ProfileApi
) : ProfileRepository {

    override suspend fun getMe(): Result<UserProfile> = runCatching { api.getMe().toDomain() }

    override suspend fun updateMe(payload: Map<String, String>): Result<Unit> = runCatching {
        val res = api.updateMe(payload)
        if (!res.isSuccessful) throw HttpException(res)
    }

    override suspend fun changePassword(current: String, new: String, confirm: String): Result<Unit> =
        runCatching {
            val body = mapOf(
                "currentPassword" to current,
                "newPassword" to new,
                "confirmPassword" to confirm
            )
            val res = api.changePassword(body)
            if (!res.isSuccessful) throw HttpException(res)
        }
}

================================================================================
FILE: features/profile/interfaces/ui/ChangePasswordDialog.kt  (size: 5695 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.interfaces.ui

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.core.modules.common.designsystem.PasswordTextField
import com.bankingsystem.mobile.core.modules.common.util.checkPasswordStrength
import com.bankingsystem.mobile.core.modules.common.util.doPasswordsMatch

@Composable
fun ChangePasswordDialog(
    onConfirm: (current: String, new: String, confirm: String) -> Unit,
    onDismiss: () -> Unit
) {
    var current by remember { mutableStateOf("") }
    var newPass by remember { mutableStateOf("") }
    var confirm by remember { mutableStateOf("") }

    val strength = remember(newPass) { checkPasswordStrength(newPass) }
    val matches = remember(newPass, confirm) { doPasswordsMatch(newPass, confirm) }

    val canSubmit = current.isNotBlank() && strength.score >= 4 && matches
    val cs = MaterialTheme.colorScheme
    val shape = MaterialTheme.shapes.large

    AlertDialog(
        onDismissRequest = onDismiss,
        shape = shape,
        containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.92f),
        tonalElevation = 0.dp,
        title = {
            Text(
                "Change Password",
                color = MaterialTheme.colorScheme.onSurface,
                style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.ExtraBold)
            )
        },
        text = {
            Column {
                PasswordTextField(
                    value = current,
                    onValueChange = { current = it },
                    label = "Current password",
                    isError = current.isBlank(),
                    supportingText = {
                        if (current.isBlank()) {
                            Text(
                                "Enter your current password",
                                color = cs.onSurfaceVariant
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )

                PasswordTextField(
                    value = newPass,
                    onValueChange = { newPass = it },
                    label = "New password",
                    isError = newPass.isNotBlank() && strength.score < 4,
                    supportingText = {
                        StrengthMeter(strengthScore = strength.score, issues = strength.issues)
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 10.dp)
                )

                PasswordTextField(
                    value = confirm,
                    onValueChange = { confirm = it },
                    label = "Confirm new password",
                    isError = confirm.isNotBlank() && !matches,
                    supportingText = {
                        when {
                            confirm.isBlank() -> Text("Re-enter new password", color = cs.onSurfaceVariant)
                            matches -> Text("Passwords match", color = cs.tertiary)
                            else -> Text("Passwords do not match", color = cs.error)
                        }
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 10.dp)
                )
            }
        },
        confirmButton = {
            Button(
                enabled = canSubmit,
                onClick = { onConfirm(current, newPass, confirm) },
                shape = MaterialTheme.shapes.medium,
                colors = ButtonDefaults.buttonColors(containerColor = cs.primary)
            ) {
                Text("Change", color = cs.onPrimary)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = cs.onSurfaceVariant)
            }
        }
    )
}

@Composable
private fun StrengthMeter(strengthScore: Int, issues: List<String>) {
    val cs = MaterialTheme.colorScheme
    val scoreClamped = strengthScore.coerceIn(0, 4)
    val progress = scoreClamped / 4f

    val barColor = when (scoreClamped) {
        0, 1 -> cs.error
        2 -> cs.secondary
        else -> cs.primary
    }
    val label = when (scoreClamped) {
        0, 1 -> "Weak"
        2 -> "Okay"
        3 -> "Strong"
        else -> "Excellent"
    }

    Column {
        LinearProgressIndicator(
            progress = { progress },
            color = barColor,
            trackColor = cs.onSurfaceVariant.copy(alpha = 0.25f),
            modifier = Modifier
                .fillMaxWidth()
                .padding(top = 6.dp)
        )
        Text(
            text = label,
            style = MaterialTheme.typography.labelSmall,
            color = cs.onSurfaceVariant,
            modifier = Modifier.padding(top = 4.dp)
        )
        if (issues.isNotEmpty()) {
            Column(Modifier.padding(top = 4.dp)) {
                issues.forEach {
                    Text("• $it", style = MaterialTheme.typography.labelSmall, color = cs.onSurfaceVariant)
                }
            }
        }
    }
}

================================================================================
FILE: features/profile/interfaces/ui/EditableField.kt  (size: 247 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.interfaces.ui

enum class EditableField {
    USERNAME, EMAIL, FIRST_NAME, LAST_NAME, ADDRESS, CITY, STATE, COUNTRY,
    POSTAL_CODE, HOME_NUMBER, WORK_NUMBER, OFFICE_NUMBER, MOBILE_NUMBER
}

================================================================================
FILE: features/profile/interfaces/ui/PasswordVerificationDialog.kt  (size: 3258 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.interfaces.ui

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Visibility
import androidx.compose.material.icons.outlined.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp

@Composable
fun PasswordVerificationDialog(
    onConfirm: (password: String) -> Unit,
    onDismiss: () -> Unit
) {
    var password by remember { mutableStateOf("") }
    var show by remember { mutableStateOf(false) }

    val cs = MaterialTheme.colorScheme
    val shape = MaterialTheme.shapes.large

    AlertDialog(
        onDismissRequest = onDismiss,
        shape = shape,
        containerColor = cs.surface.copy(alpha = 0.90f),
        tonalElevation = 0.dp,

        title = {
            Text(
                "Verify Password",
                color = Color.Black,
                style = MaterialTheme.typography.titleLarge
            )
        },

        text = {
            Column {
                Text(
                    "Enter your current password to confirm username change.",
                    color = cs.onSurfaceVariant,
                    style = MaterialTheme.typography.bodyMedium
                )

                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 10.dp),
                    singleLine = true,
                    label = { Text("Current password") },
                    visualTransformation = if (show) VisualTransformation.None else PasswordVisualTransformation(),
                    trailingIcon = {
                        IconButton(onClick = { show = !show }) {
                            Icon(
                                imageVector = if (show) Icons.Outlined.VisibilityOff else Icons.Outlined.Visibility,
                                contentDescription = if (show) "Hide password" else "Show password"
                            )
                        }
                    },
                    shape = MaterialTheme.shapes.medium
                )
            }
        },

        confirmButton = {
            Button(
                onClick = { onConfirm(password) },
                enabled = password.isNotBlank(),
                colors = ButtonDefaults.buttonColors(containerColor = cs.primary),
                shape = MaterialTheme.shapes.medium
            ) {
                Text("Verify", color = cs.onPrimary)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = cs.onSurfaceVariant)
            }
        }
    )
}

================================================================================
FILE: features/profile/interfaces/ui/ProfileRoute.kt  (size: 2017 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.interfaces.ui

import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.hilt.navigation.compose.hiltViewModel

@Composable
fun ProfileRoute(
    onNavigate: (String) -> Unit
) {
    val vm: ProfileViewModel = hiltViewModel()
    val ui by vm.ui.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(ui.snackbarMessage) {
        ui.snackbarMessage?.let {
            snackbarHostState.showSnackbar(it)
            vm.snackbarShown()
        }
    }

    ProfileScreen(
        profile = ui.profile,
        isLoading = ui.isLoading,
        errorMessage = ui.errorMessage,

        editingField = ui.editingField,

        tempValue = ui.tempValue,

        onEditClicked = vm::startEditing,
        onCancelEditing = vm::cancelEditing,
        onSaveEditing = vm::saveEditing,
        onValueChange = vm::onTempValueChange,
        onChangePasswordClick = vm::openChangePassword,

        selectedItem = "Profile",
        onNavigate = onNavigate,

        isCheckingUsername = ui.isCheckingUsername,
        isUsernameAvailable = ui.isUsernameAvailable
    )

    if (ui.showPasswordDialog) {
        PasswordVerificationDialog(
            onConfirm = { vm.onPasswordVerified(it) },
            onDismiss = { vm.dismissPasswordDialog() }
        )
    }

    if (ui.showChangePasswordDialog) {
        ChangePasswordDialog(
            onConfirm = { current, newPass, confirm ->
                vm.changePassword(current, newPass, confirm)
            },
            onDismiss = { vm.dismissChangePassword() }
        )
    }

    SnackbarHost(hostState = snackbarHostState)
}

================================================================================
FILE: features/profile/interfaces/ui/ProfileScreen.kt  (size: 17955 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.interfaces.ui

import androidx.compose.animation.core.animateDpAsState
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.profile.domain.model.UserProfile
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProfileScreen(
    profile: UserProfile? = null,
    isLoading: Boolean = false,
    errorMessage: String? = null,

    editingField: EditableField? = null,
    tempValue: String = "",

    onEditClicked: (EditableField) -> Unit = {},
    onCancelEditing: () -> Unit = {},
    onSaveEditing: () -> Unit = {},
    onValueChange: (String) -> Unit = {},
    onChangePasswordClick: () -> Unit = {},

    selectedItem: String = "Profile",
    onNavigate: (String) -> Unit = {},

    isCheckingUsername: Boolean = false,
    isUsernameAvailable: Boolean? = null,
) {
    val cs = MaterialTheme.colorScheme
    var isSidebarOpen by remember { mutableStateOf(false) }
    val sidebarOffset by animateDpAsState(if (isSidebarOpen) 0.dp else (-280).dp, label = "sidebar")
    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior()

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
            containerColor = Color.Transparent,
            topBar = {
                LargeTopAppBar(
                    title = {
                        Text(
                            "My Profile",
                            color = Color.White,
                            style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.SemiBold)
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = { isSidebarOpen = !isSidebarOpen }) {
                            Icon(
                                Icons.Filled.Menu,
                                contentDescription = "Open navigation",
                                tint = cs.onSurface
                            )
                        }
                    },
                    colors = TopAppBarDefaults.largeTopAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    ),
                    scrollBehavior = scrollBehavior
                )
            }
        ) { padding ->
            when {
                isLoading -> Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(padding),
                    contentAlignment = Alignment.Center
                ) { CircularProgressIndicator() }

                errorMessage != null -> Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(padding),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        errorMessage,
                        style = MaterialTheme.typography.bodyLarge,
                        color = cs.error
                    )
                }

                else -> {
                    val fields: List<Pair<EditableField, String>> = listOf(
                        EditableField.USERNAME to "Username",
                        EditableField.FIRST_NAME to "First Name",
                        EditableField.LAST_NAME to "Last Name",
                        EditableField.EMAIL to "Email",
                        EditableField.ADDRESS to "Address",
                        EditableField.CITY to "City",
                        EditableField.STATE to "State",
                        EditableField.COUNTRY to "Country",
                        EditableField.POSTAL_CODE to "Postal Code",
                        EditableField.HOME_NUMBER to "Home Number",
                        EditableField.WORK_NUMBER to "Work Number",
                        EditableField.OFFICE_NUMBER to "Office Number",
                        EditableField.MOBILE_NUMBER to "Mobile Number"
                    )

                    LazyColumn(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(padding)
                            .padding(horizontal = 20.dp, vertical = 16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        item {
                            GlassPanel(modifier = Modifier.fillMaxWidth()) {
                                Text(
                                    "My Profile",
                                    color = Color.White,
                                    style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.ExtraBold),
                                    modifier = Modifier.align(Alignment.CenterHorizontally)
                                )

                                Spacer(Modifier.height(12.dp))
                                HorizontalDivider(
                                    color = MaterialTheme.colorScheme.outline.copy(
                                        alpha = 0.35f
                                    )
                                )
                                Spacer(Modifier.height(8.dp))

                                Column(verticalArrangement = Arrangement.spacedBy(14.dp)) {
                                    fields.forEach { (field, label) ->
                                        val isEditing = editingField == field
                                        val value =
                                            if (isEditing) tempValue else profile.getFieldValue(
                                                field
                                            )

                                        ProfileTableRow(
                                            label = label,
                                            value = value,
                                            isEditing = isEditing,
                                            onEditClick = { onEditClicked(field) },
                                            onValueChange = onValueChange,
                                            onCancel = onCancelEditing,
                                            onSave = onSaveEditing,
                                            isCheckingUsername = field == EditableField.USERNAME && isCheckingUsername,
                                            isUsernameAvailable = if (field == EditableField.USERNAME) isUsernameAvailable else null
                                        )

                                        HorizontalDivider(
                                            color = MaterialTheme.colorScheme.outline.copy(alpha = 0.15f)
                                        )
                                    }
                                }

                                Spacer(Modifier.height(12.dp))

                                profile?.roleName?.takeIf { it.isNotBlank() }?.let { role ->
                                    Surface(
                                        color = MaterialTheme.colorScheme.primary.copy(alpha = 0.15f),
                                        shape = RoundedCornerShape(999.dp),
                                        tonalElevation = 0.dp
                                    ) {
                                        Text(
                                            text = role.uppercase(),
                                            color = MaterialTheme.colorScheme.primary,
                                            style = MaterialTheme.typography.labelLarge,
                                            modifier = Modifier.padding(
                                                horizontal = 10.dp,
                                                vertical = 6.dp
                                            )
                                        )
                                    }
                                }
                            }
                        }

                        item {
                            Button(
                                onClick = onChangePasswordClick,
                                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error),
                                modifier = Modifier.fillMaxWidth(),
                                shape = RoundedCornerShape(16.dp)
                            ) {
                                Text("Change Password", color = MaterialTheme.colorScheme.onError)
                            }
                        }

                        item { Spacer(Modifier.height(8.dp)) }
                    }
                }
            }
        }

        if (isSidebarOpen) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(MaterialTheme.colorScheme.scrim)
                    .clickable { isSidebarOpen = false }
            )
        }
        Surface(
            modifier = Modifier
                .fillMaxHeight()
                .width(280.dp)
                .offset(x = sidebarOffset),
            tonalElevation = 0.dp,
            shadowElevation = 12.dp,
            shape = RoundedCornerShape(topEnd = 16.dp, bottomEnd = 16.dp),
        ) {
            Sidebar(
                selectedItem = selectedItem,
                onItemClick = {
                    isSidebarOpen = false
                    onNavigate(it)
                },
                userName = buildName(profile)
            )
        }
    }
}

/* ---------- Rows / chips ---------- */

@Composable
private fun ProfileTableRow(
    label: String,
    value: String,
    isEditing: Boolean,
    onEditClick: () -> Unit,
    onValueChange: (String) -> Unit,
    onCancel: () -> Unit,
    onSave: () -> Unit,
    isCheckingUsername: Boolean = false,
    isUsernameAvailable: Boolean? = null
) {
    val cs = MaterialTheme.colorScheme

    if (!isEditing) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                label,
                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold),
                color = Color.White,
                modifier = Modifier.weight(0.9f)
            )

            Text(
                value.ifBlank { "Not set" },
                style = MaterialTheme.typography.bodyLarge,
                color = if (value.isBlank())
                    cs.onSurfaceVariant.copy(alpha = 0.9f) else Color.Black,
                fontStyle = if (value.isBlank()) FontStyle.Italic else FontStyle.Normal,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis,
                modifier = Modifier.weight(1.6f)
            )

            TextButton(
                onClick = onEditClick,
                contentPadding = PaddingValues(horizontal = 0.dp, vertical = 6.dp)
            ) {
                Text("Edit")
            }
        }
    } else {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                label,
                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold),
                color = cs.onSurfaceVariant,
                modifier = Modifier.weight(0.9f)
            )
            OutlinedTextField(
                value = value,
                onValueChange = onValueChange,
                singleLine = true,
                modifier = Modifier.weight(1.6f),
                shape = RoundedCornerShape(12.dp)
            )
            Row {
                TextButton(onClick = onSave) { Text("Save") }
                TextButton(onClick = onCancel) { Text("Cancel") }
            }
        }

        if (label == "Username") {
            val helper = when {
                isCheckingUsername -> "Checking username..."
                isUsernameAvailable == true -> "Username is available"
                isUsernameAvailable == false -> "Username is not available or too short"
                else -> null
            }
            if (helper != null) {
                Text(
                    text = helper,
                    style = MaterialTheme.typography.labelSmall,
                    color = when {
                        isCheckingUsername -> cs.onSurfaceVariant
                        isUsernameAvailable == true -> cs.tertiary
                        else -> cs.error
                    },
                    modifier = Modifier.padding(top = 6.dp)
                )
            }
        }
    }
}

@Composable
private fun RoleChip(text: String) {
    val cs = MaterialTheme.colorScheme
    Surface(
        color = cs.primary.copy(alpha = 0.12f),
        contentColor = cs.primary,
        shape = RoundedCornerShape(10.dp),
        tonalElevation = 0.dp
    ) {
        Text(
            text = if (text.isBlank()) "UNKNOWN" else text.uppercase(),
            style = MaterialTheme.typography.labelLarge,
            modifier = Modifier.padding(horizontal = 10.dp, vertical = 6.dp)
        )
    }
}

/* ---------- Helpers ---------- */

private fun buildName(profile: UserProfile?): String {
    if (profile == null) return ""
    val first = profile.firstName?.trim().orEmpty()
    val last = profile.lastName?.trim().orEmpty()
    val user = profile.username?.trim().orEmpty()
    val parts = listOf(first, last).filter { it.isNotBlank() }
    return when {
        parts.isNotEmpty() -> parts.joinToString(" ")
        user.isNotBlank() -> user
        else -> ""
    }
}

private fun UserProfile?.getFieldValue(field: EditableField): String {
    val raw: String? = when (field) {
        EditableField.USERNAME -> this?.username
        EditableField.EMAIL -> this?.email
        EditableField.FIRST_NAME -> this?.firstName
        EditableField.LAST_NAME -> this?.lastName
        EditableField.ADDRESS -> this?.address
        EditableField.CITY -> this?.city
        EditableField.STATE -> this?.state
        EditableField.COUNTRY -> this?.country
        EditableField.POSTAL_CODE -> this?.postalCode
        EditableField.HOME_NUMBER -> this?.homeNumber
        EditableField.WORK_NUMBER -> this?.workNumber
        EditableField.OFFICE_NUMBER -> this?.officeNumber
        EditableField.MOBILE_NUMBER -> this?.mobileNumber
    }
    return raw?.trim().orEmpty()
}

@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    val shape = RoundedCornerShape(24.dp)

    Surface(
        modifier = modifier,
        shape = shape,
        color = Color.White.copy(alpha = 0.05f),
        tonalElevation = 0.dp,
        shadowElevation = 18.dp,
        border = BorderStroke(
            1.dp,
            Brush.linearGradient(
                listOf(
                    Color.White.copy(alpha = 0.35f),
                    Color.White.copy(alpha = 0.10f)
                )
            )
        )
    ) {
        Box(
            Modifier
                .clip(shape)
                .background(
                    brush = Brush.verticalGradient(
                        0f to Color.White.copy(alpha = 0.12f),
                        0.25f to Color.White.copy(alpha = 0.06f),
                        1f to Color.Transparent
                    ),
                    shape = shape
                )
                .background(
                    brush = Brush.radialGradient(
                        colors = listOf(Color.White.copy(alpha = 0.07f), Color.Transparent),
                        center = Offset(80f, 80f),
                        radius = 380f
                    ),
                    shape = shape
                )
                .padding(1.dp)
                .border(BorderStroke(1.dp, cs.outline.copy(alpha = 0.12f)), shape)
                .padding(20.dp)
        ) {
            Column(content = content)
        }
    }
}

================================================================================
FILE: features/profile/interfaces/ui/ProfileViewModel.kt  (size: 12739 bytes)
================================================================================
package com.bankingsystem.mobile.features.profile.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.core.modules.common.storage.AuthStore
import com.bankingsystem.mobile.core.modules.common.util.checkPasswordStrength
import com.bankingsystem.mobile.core.modules.common.util.doPasswordsMatch
import com.bankingsystem.mobile.features.auth.domain.repository.UserRepository
import com.bankingsystem.mobile.features.profile.domain.model.UserProfile
import com.bankingsystem.mobile.features.profile.domain.repository.ProfileRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.CoroutineExceptionHandler
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

data class ProfileUiState(
    val isLoading: Boolean = true,
    val errorMessage: String? = null,
    val profile: UserProfile? = null,
    val editingField: EditableField? = null,
    val tempValue: String = "",
    val isCheckingUsername: Boolean = false,
    val isUsernameAvailable: Boolean? = null,
    val showPasswordDialog: Boolean = false,
    val pendingUsername: String? = null,
    val showChangePasswordDialog: Boolean = false,
    val isChangingPassword: Boolean = false,
    val snackbarMessage: String? = null
)

@HiltViewModel
class ProfileViewModel @Inject constructor(
    private val profileRepo: ProfileRepository,
    private val authRepo: UserRepository,
    private val store: AuthStore
) : ViewModel() {

    private val _ui = MutableStateFlow(ProfileUiState())
    val ui: StateFlow<ProfileUiState> = _ui

    private var usernameCheckJob: Job? = null

    private val crashHandler = CoroutineExceptionHandler { _, e ->
        android.util.Log.e("ProfileVM", "Coroutine exception", e)
        toast(e.message ?: "Unexpected error")
    }

    init { loadProfile() }

    /* --------------------------- Data loading --------------------------- */

    fun loadProfile() = viewModelScope.launch(crashHandler) {
        _ui.value = _ui.value.copy(isLoading = true, errorMessage = null)
        val res = profileRepo.getMe()
        if (res.isSuccess) {
            val safe = res.getOrNull()?.toSanitized()
            _ui.value = _ui.value.copy(isLoading = false, profile = safe)
        } else {
            _ui.value = _ui.value.copy(isLoading = false, errorMessage = "Failed to load profile.")
        }
    }

    /* --------------------------- Inline editing ------------------------- */

    fun startEditing(field: EditableField) {
        val value = currentValue(field)
        _ui.value = _ui.value.copy(
            editingField = field,
            tempValue = value,
            isUsernameAvailable = null,
            isCheckingUsername = false
        )
        if (field == EditableField.USERNAME && value.isNotBlank()) {
            debounceUsername(value)
        }
    }

    fun cancelEditing() {
        _ui.value = _ui.value.copy(
            editingField = null,
            tempValue = "",
            isCheckingUsername = false,
            isUsernameAvailable = null
        )
    }

    fun onTempValueChange(new: String) {
        _ui.value = _ui.value.copy(tempValue = new)
        if (_ui.value.editingField == EditableField.USERNAME) {
            debounceUsername(new)
        }
    }

    private fun debounceUsername(value: String) {
        usernameCheckJob?.cancel()
        if (value.isBlank()) {
            _ui.value = _ui.value.copy(isCheckingUsername = false, isUsernameAvailable = null)
            return
        }
        usernameCheckJob = viewModelScope.launch(crashHandler) {
            _ui.value = _ui.value.copy(isCheckingUsername = true, isUsernameAvailable = null)
            delay(450)
            val ok = runCatching { authRepo.checkUsernameAvailability(value) }.getOrDefault(false)
            _ui.value = _ui.value.copy(isCheckingUsername = false, isUsernameAvailable = ok)
        }
    }

    fun saveEditing() = viewModelScope.launch(crashHandler) {
        val field = _ui.value.editingField ?: return@launch
        val temp = _ui.value.tempValue
        val prof = _ui.value.profile ?: return@launch

        if (field == EditableField.USERNAME) {
            val avail = _ui.value.isUsernameAvailable
            if (avail != true) { toast("Username is not available or too short."); return@launch }
            _ui.value = _ui.value.copy(showPasswordDialog = true, pendingUsername = temp)
            return@launch
        }

        val key = fieldKey(field)
        val res = profileRepo.updateMe(mapOf(key to temp))
        if (res.isSuccess) {
            val updated = prof.toSanitized().copyWith(field, temp)
            _ui.value = _ui.value.copy(
                profile = updated,
                editingField = null,
                tempValue = "",
                snackbarMessage = "Profile updated successfully"
            )
        } else {
            toast("Failed to update profile. Please try again.")
        }
    }

    /* ----------------------- Username change (verify) ------------------- */

    fun onPasswordVerified(password: String) = viewModelScope.launch(crashHandler) {
        val newUsername = _ui.value.pendingUsername ?: return@launch

        val update = profileRepo.updateMe(mapOf("username" to newUsername, "currentPassword" to password))
        if (update.isFailure) { toast("Failed to update username. Please try again."); return@launch }

        val login = authRepo.login(newUsername, password)
        if (login.isFailure) { toast("Login failed after username change."); return@launch }

        val auth = login.getOrNull()!!
        store.saveAuth(auth.token, auth.username, auth.role)

        val updated = _ui.value.profile?.toSanitized()?.copy(username = newUsername)
        _ui.value = _ui.value.copy(
            profile = updated,
            showPasswordDialog = false,
            pendingUsername = null,
            editingField = null,
            tempValue = "",
            snackbarMessage = "Username updated and re-authenticated"
        )
    }

    fun dismissPasswordDialog() {
        _ui.value = _ui.value.copy(showPasswordDialog = false, pendingUsername = null)
    }

    /* ------------------------ Change password flow ---------------------- */

    fun openChangePassword() {
        _ui.value = _ui.value.copy(showChangePasswordDialog = true)
    }

    fun dismissChangePassword() {
        _ui.value = _ui.value.copy(showChangePasswordDialog = false)
    }

    fun changePassword(currentPassword: String, newPassword: String, confirmNewPassword: String) =
        viewModelScope.launch(crashHandler) {
            val strength = checkPasswordStrength(newPassword)
            val matches = doPasswordsMatch(newPassword, confirmNewPassword)

            if (strength.score < 4) {
                toast(if (strength.issues.isNotEmpty())
                    "New password too weak: ${strength.issues.joinToString("; ")}"
                else "New password too weak.")
                return@launch
            }
            if (!matches) { toast("New password and confirmation do not match."); return@launch }

            _ui.value = _ui.value.copy(isChangingPassword = true)
            val res = profileRepo.changePassword(currentPassword, newPassword, confirmNewPassword)

            if (res.isSuccess) {
                _ui.value = _ui.value.copy(
                    isChangingPassword = false,
                    showChangePasswordDialog = false,
                    snackbarMessage = "Password changed successfully"
                )
            } else {
                _ui.value = _ui.value.copy(isChangingPassword = false)
                toast(res.exceptionOrNull()?.message ?: "Failed to change password.")
            }
        }

    /* ------------------------------- UX -------------------------------- */

    fun snackbarShown() { _ui.value = _ui.value.copy(snackbarMessage = null) }
    private fun toast(msg: String) { _ui.value = _ui.value.copy(snackbarMessage = msg) }

    /* ----------------------------- Helpers ------------------------------ */

    private fun currentValue(field: EditableField): String =
        when (field) {
            EditableField.USERNAME      -> (_ui.value.profile?.username as String?)?.trim().orEmpty()
            EditableField.EMAIL         -> (_ui.value.profile?.email as String?)?.trim().orEmpty()
            EditableField.FIRST_NAME    -> (_ui.value.profile?.firstName as String?)?.trim().orEmpty()
            EditableField.LAST_NAME     -> (_ui.value.profile?.lastName as String?)?.trim().orEmpty()
            EditableField.ADDRESS       -> (_ui.value.profile?.address as String?)?.trim().orEmpty()
            EditableField.CITY          -> (_ui.value.profile?.city as String?)?.trim().orEmpty()
            EditableField.STATE         -> (_ui.value.profile?.state as String?)?.trim().orEmpty()
            EditableField.COUNTRY       -> (_ui.value.profile?.country as String?)?.trim().orEmpty()
            EditableField.POSTAL_CODE   -> (_ui.value.profile?.postalCode as String?)?.trim().orEmpty()
            EditableField.HOME_NUMBER   -> (_ui.value.profile?.homeNumber as String?)?.trim().orEmpty()
            EditableField.WORK_NUMBER   -> (_ui.value.profile?.workNumber as String?)?.trim().orEmpty()
            EditableField.OFFICE_NUMBER -> (_ui.value.profile?.officeNumber as String?)?.trim().orEmpty()
            EditableField.MOBILE_NUMBER -> (_ui.value.profile?.mobileNumber as String?)?.trim().orEmpty()
        }

    private fun fieldKey(field: EditableField): String = when (field) {
        EditableField.USERNAME      -> "username"
        EditableField.EMAIL         -> "email"
        EditableField.FIRST_NAME    -> "firstName"
        EditableField.LAST_NAME     -> "lastName"
        EditableField.ADDRESS       -> "address"
        EditableField.CITY          -> "city"
        EditableField.STATE         -> "state"
        EditableField.COUNTRY       -> "country"
        EditableField.POSTAL_CODE   -> "postalCode"
        EditableField.HOME_NUMBER   -> "homeNumber"
        EditableField.WORK_NUMBER   -> "workNumber"
        EditableField.OFFICE_NUMBER -> "officeNumber"
        EditableField.MOBILE_NUMBER -> "mobileNumber"
    }

    private fun UserProfile.copyWith(field: EditableField, value: String): UserProfile =
        when (field) {
            EditableField.USERNAME      -> this.copy(username = value)
            EditableField.EMAIL         -> this.copy(email = value)
            EditableField.FIRST_NAME    -> this.copy(firstName = value)
            EditableField.LAST_NAME     -> this.copy(lastName = value)
            EditableField.ADDRESS       -> this.copy(address = value)
            EditableField.CITY          -> this.copy(city = value)
            EditableField.STATE         -> this.copy(state = value)
            EditableField.COUNTRY       -> this.copy(country = value)
            EditableField.POSTAL_CODE   -> this.copy(postalCode = value)
            EditableField.HOME_NUMBER   -> this.copy(homeNumber = value)
            EditableField.WORK_NUMBER   -> this.copy(workNumber = value)
            EditableField.OFFICE_NUMBER -> this.copy(officeNumber = value)
            EditableField.MOBILE_NUMBER -> this.copy(mobileNumber = value)
        }

    private fun UserProfile.toSanitized(): UserProfile = UserProfile(
        userId       = (this.userId as String?)       ?: "",
        username     = (this.username as String?)     ?: "",
        firstName    = (this.firstName as String?)    ?: "",
        lastName     = (this.lastName as String?)     ?: "",
        address      = (this.address as String?)      ?: "",
        city         = (this.city as String?)         ?: "",
        state        = (this.state as String?)        ?: "",
        country      = (this.country as String?)      ?: "",
        postalCode   = (this.postalCode as String?)   ?: "",
        homeNumber   = (this.homeNumber as String?)   ?: "",
        workNumber   = (this.workNumber as String?)   ?: "",
        officeNumber = (this.officeNumber as String?) ?: "",
        mobileNumber = (this.mobileNumber as String?) ?: "",
        email        = (this.email as String?)        ?: "",
        roleName     = (this.roleName as String?)     ?: ""
    )
}

================================================================================
FILE: features/settings/interfaces/ui/SettingsScreen.kt  (size: 14742 bytes)
================================================================================
package com.bankingsystem.mobile.features.settings.interfaces.ui

import android.widget.Toast
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsPressedAsState
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Logout
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Key
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material3.*
import androidx.compose.material3.SwitchDefaults
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.BuildConfig
import com.bankingsystem.mobile.core.modules.common.storage.LockPreferences
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.features.lock.interfaces.ui.LockSetupScreen
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    onLogout: () -> Unit,
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val lockPrefs = remember { LockPreferences(context) }

    var lockEnabled by remember { mutableStateOf(false) }
    var currentPin by remember { mutableStateOf<String?>(null) }
    var pendingEnable by remember { mutableStateOf(false) }
    var showLockSetup by remember { mutableStateOf(false) }
    var showLogoutDialog by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        val enabled = withContext(Dispatchers.IO) { lockPrefs.isLockEnabled() }
        val pin = withContext(Dispatchers.IO) { lockPrefs.getPin() }
        lockEnabled = enabled
        currentPin = pin
        pendingEnable = enabled
    }

    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior()
    val cs = MaterialTheme.colorScheme

    Box(Modifier.fillMaxSize()) {
        FadingAppBackground()

        Scaffold(
            modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
            containerColor = Color.Transparent,
            topBar = {
                LargeTopAppBar(
                    title = {
                        Text(
                            "Settings",
                            color = Color.White,
                            style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.SemiBold)
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = onBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                        }
                    },
                    colors = TopAppBarDefaults.largeTopAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    ),
                    scrollBehavior = scrollBehavior
                )
            }
        ) { padding ->

            if (showLockSetup) {
                LockSetupScreen(
                    initialPin = currentPin,
                    onSavePin = { pin ->
                        lockPrefs.savePin(pin)
                        lockPrefs.setLockEnabled(true)
                        currentPin = pin
                        lockEnabled = true
                        pendingEnable = true
                        showLockSetup = false
                        Toast.makeText(context, "App lock enabled", Toast.LENGTH_SHORT).show()
                    },
                    onLockEnabledChange = { enabled ->
                        lockPrefs.setLockEnabled(enabled)
                        lockEnabled = enabled
                        pendingEnable = enabled
                        if (!enabled) {
                            lockPrefs.clearLock()
                            currentPin = null
                        }
                        showLockSetup = false
                    },
                    onCancel = {
                        pendingEnable = lockEnabled
                        showLockSetup = false
                    }
                )
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(padding)
                        .padding(horizontal = 20.dp, vertical = 16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    item {
                        GlassPanel {
                            Text(
                                "Settings",
                                style = MaterialTheme.typography.headlineSmall.copy(
                                    fontWeight = FontWeight.ExtraBold,
                                    color = Color.White
                                )
                            )
                            Spacer(Modifier.height(6.dp))
                            Text(
                                "Manage app lock and app preferences",
                                style = MaterialTheme.typography.bodyMedium,
                                color = Color.White.copy(alpha = 0.85f)
                            )
                        }
                    }

                    item {
                        GlassGroup(title = "Security") {
                            SettingRow(
                                icon = Icons.Filled.Lock,
                                title = "App Lock",
                                subtitle = if (pendingEnable) "Enabled" else "Disabled",
                                trailing = {
                                    Switch(
                                        checked = pendingEnable,
                                        onCheckedChange = { enabled ->
                                            if (enabled) {
                                                showLockSetup = true
                                                pendingEnable = true
                                            } else {
                                                lockPrefs.setLockEnabled(false)
                                                lockPrefs.clearLock()
                                                lockEnabled = false
                                                currentPin = null
                                                pendingEnable = false
                                                Toast.makeText(context, "App lock disabled", Toast.LENGTH_SHORT).show()
                                            }
                                        },
                                        colors = SwitchDefaults.colors(
                                            checkedThumbColor = cs.onPrimary,
                                            checkedTrackColor = cs.primary,
                                            uncheckedThumbColor = cs.onSurfaceVariant,
                                            uncheckedTrackColor = cs.onSurfaceVariant.copy(alpha = 0.4f)
                                        )
                                    )
                                }
                            )

                            if (lockEnabled) {
                                Spacer(Modifier.height(6.dp))
                                SettingRow(
                                    icon = Icons.Filled.Key,
                                    title = "Change PIN",
                                    subtitle = "Update your lock code",
                                    onClick = { showLockSetup = true }
                                )
                            }
                        }
                    }

                    item {
                        GlassGroup(title = "About") {
                            SettingRow(
                                icon = Icons.Filled.Info,
                                title = "Version",
                                subtitle = BuildConfig.VERSION_NAME
                            )
                        }
                    }

                    item {
                        GlassPanel(
                            accent = cs.error
                        ) {
                            Text(
                                "Danger Zone",
                                style = MaterialTheme.typography.titleMedium,
                                color = cs.error,
                                fontWeight = FontWeight.SemiBold
                            )
                            Spacer(Modifier.height(10.dp))
                            Button(
                                onClick = { showLogoutDialog = true },
                                colors = ButtonDefaults.buttonColors(containerColor = cs.error),
                                shape = RoundedCornerShape(14.dp),
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                Icon(Icons.AutoMirrored.Filled.Logout, contentDescription = null, tint = cs.onError)
                                Spacer(Modifier.width(8.dp))
                                Text("Logout", color = cs.onError)
                            }
                        }
                    }

                    item { Spacer(Modifier.height(8.dp)) }
                }
            }
        }

        if (showLogoutDialog) {
            AlertDialog(
                onDismissRequest = { showLogoutDialog = false },
                title = { Text("Log out?") },
                text = { Text("You’ll need to log in again to access your account.") },
                confirmButton = {
                    TextButton(
                        onClick = {
                            showLogoutDialog = false
                            onLogout()
                        }
                    ) { Text("Log out") }
                },
                dismissButton = {
                    TextButton(onClick = { showLogoutDialog = false }) { Text("Cancel") }
                }
            )
        }
    }
}


@Composable
private fun GlassPanel(
    modifier: Modifier = Modifier,
    accent: Color? = null,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    val panelColor = cs.surface.copy(alpha = 0.10f)

    val borderBrush = if (accent == null) {
        Brush.linearGradient(listOf(cs.outline.copy(0.45f), cs.outline.copy(0.15f)))
    } else {
        Brush.linearGradient(listOf(accent.copy(0.50f), accent.copy(0.20f)))
    }

    Surface(
        modifier = modifier
            .fillMaxWidth()
            .border(width = 1.dp, brush = borderBrush, shape = RoundedCornerShape(24.dp)),
        shape = RoundedCornerShape(24.dp),
        color = panelColor,
        tonalElevation = 0.dp,
        shadowElevation = 10.dp
    ) {
        Column(
            modifier = Modifier
                .background(
                    Brush.verticalGradient(
                        listOf(Color.White.copy(alpha = 0.06f), Color.Transparent)
                    )
                )
                .padding(20.dp),
            content = content
        )
    }
}

@Composable
private fun GlassGroup(
    title: String,
    content: @Composable ColumnScope.() -> Unit
) {
    GlassPanel {
        Text(
            title,
            color = Color.White,
            style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.SemiBold)
        )
        Spacer(Modifier.height(10.dp))
        Column(content = content)
    }
}


@Composable
private fun SettingRow(
    icon: ImageVector,
    title: String,
    subtitle: String? = null,
    trailing: @Composable (() -> Unit)? = null,
    onClick: (() -> Unit)? = null
) {
    val cs = MaterialTheme.colorScheme
    val interaction = remember { MutableInteractionSource() }
    val pressed = interaction.collectIsPressedAsState().value
    val scale = if (pressed) 0.98f else 1f

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .graphicsLayer { scaleX = scale; scaleY = scale }
            .clip(RoundedCornerShape(14.dp))
            .clickable(enabled = onClick != null, interactionSource = interaction, indication = null) {
                onClick?.invoke()
            }
            .padding(horizontal = 8.dp, vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(36.dp)
                .clip(CircleShape)
                .background(cs.primary.copy(alpha = 0.15f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(icon, contentDescription = null, tint = cs.primary)
        }

        Spacer(Modifier.width(12.dp))

        Column(Modifier.weight(1f)) {
            Text(title, color = Color.White, style = MaterialTheme.typography.bodyLarge)
            if (!subtitle.isNullOrBlank()) {
                Text(subtitle, color = Color.White.copy(alpha = 0.75f), style = MaterialTheme.typography.bodyMedium)
            }
        }

        if (trailing != null) {
            Spacer(Modifier.width(12.dp))
            trailing()
        }
    }
}

================================================================================
FILE: features/splash/interfaces/ui/AnimatedSplashScreen.kt  (size: 1685 bytes)
================================================================================
package com.bankingsystem.mobile.features.splash.interfaces.ui

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.R
import kotlinx.coroutines.delay

@Composable
fun AnimatedSplashScreen(onTimeout: () -> Unit) {
    val scale = remember { Animatable(0.8f) }
    LaunchedEffect(Unit) {
        scale.animateTo(
            targetValue = 1.2f,
            animationSpec = tween(durationMillis = 700, easing = FastOutSlowInEasing)
        )
        scale.animateTo(
            targetValue = 1.0f,
            animationSpec = tween(durationMillis = 700, easing = FastOutSlowInEasing)
        )
        delay(1000)
        onTimeout()
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Image(
            painter = painterResource(id = R.drawable.ic_splash_logo),
            contentDescription = "App Logo",
            modifier = Modifier
                .size(150.dp)
                .scale(scale.value)
        )
    }
}

================================================================================
FILE: features/wallet/collect_text_and_tree.py  (size: 8587 bytes)
================================================================================
#!/usr/bin/env python3
"""
Collect project sources:
- For text files: write full contents (preserved exactly).
- For non-text files: write only the file name (marked as UNSUPPORTED/BINARY).
- Finally, append an ASCII tree of the entire project.

Defaults: no pruning; includes hidden files; deterministic order.
You can pass --exclude to skip specific directories, and --followlinks to follow symlinks.
"""

from __future__ import annotations
import argparse
import os
from pathlib import Path
import sys
import tokenize
import mimetypes
import re

HEADER_LINE = "=" * 80

# Common text-like extensions (still fallback to detection)
TEXT_EXTS = {
    # Code
    ".py", ".java", ".kt", ".kts",
    ".js", ".ts", ".jsx", ".tsx",
    ".css", ".scss", ".sass", ".less",
    ".html", ".htm", ".vue", ".svelte",
    ".c", ".h", ".cpp", ".hpp", ".cc", ".m", ".mm",
    ".go", ".rs", ".php", ".rb", ".swift", ".scala",
    ".cs", ".sql", ".sh", ".bat", ".ps1",
    # Config / data / docs
    ".json", ".yaml", ".yml", ".xml", ".ini", ".cfg", ".conf", ".properties",
    ".toml", ".gradle", ".md", ".txt", ".env", ".csv", ".tsv",
    ".gitignore", ".gitattributes", ".editorconfig", ".prettierrc", ".eslintrc",
}

# MIME types we treat as text even if extension is unknown
TEXT_MIME_PREFIXES = ("text/",)
TEXT_MIME_EXTRAS = {
    "application/json", "application/xml", "application/javascript",
    "application/x-sh", "application/x-shellscript",
}

# ---------- Helpers ----------

def _has_bom(head: bytes) -> str | None:
    if head.startswith(b"\xef\xbb\xbf"):
        return "utf-8-sig"
    if head.startswith(b"\xff\xfe\x00\x00"):
        return "utf-32-le"
    if head.startswith(b"\x00\x00\xfe\xff"):
        return "utf-32-be"
    if head.startswith(b"\xff\xfe"):
        return "utf-16-le"
    if head.startswith(b"\xfe\xff"):
        return "utf-16-be"
    return None

def _looks_binary(head: bytes) -> bool:
    if b"\x00" in head:
        return True
    # Consider control chars (excluding \t, \n, \r, \f) as "weird"
    weird = sum(1 for b in head if (b < 32 and b not in (9,10,13,12)))
    # If > 30% are weird control bytes, likely binary
    return (len(head) > 0) and (weird / len(head) > 0.30)

def is_text_file(path: Path, sample_bytes: int = 4096) -> bool:
    # 1) Obvious by extension
    if path.suffix.lower() in TEXT_EXTS:
        return True
    # 2) BOM presence indicates text
    try:
        with path.open("rb") as f:
            head = f.read(sample_bytes)
    except Exception:
        return False
    if _has_bom(head):
        return True
    # 3) MIME hint
    mt, _ = mimetypes.guess_type(path.as_posix())
    if mt and (mt.startswith(TEXT_MIME_PREFIXES) or mt in TEXT_MIME_EXTRAS):
        return True
    # 4) Heuristic on bytes
    return not _looks_binary(head)

def read_text_preserve(path: Path) -> str:
    """Read text preserving original characters as closely as possible."""
    # Respect PEP 263 for Python files
    if path.suffix.lower() == ".py":
        with tokenize.open(path) as f:
            return f.read()
    # BOM-aware for common Unicode encodings
    with path.open("rb") as fb:
        head = fb.read(4)
    enc = _has_bom(head)
    if enc:
        return path.read_text(encoding=enc)
    # Try UTF-8, then Latin-1 (lossless mapping of bytes 0–255)
    try:
        return path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return path.read_text(encoding="latin-1")

def write_header(out, rel_path: Path, size_bytes: int | None, marker: str | None = None):
    out.write(f"{HEADER_LINE}\n")
    out.write(f"FILE: {rel_path.as_posix()}")
    if size_bytes is not None:
        out.write(f"  (size: {size_bytes} bytes)")
    if marker:
        out.write(f"  [{marker}]")
    out.write("\n")
    out.write(f"{HEADER_LINE}\n")

def iter_all_files(root: Path, followlinks: bool, exclude_dirs: set[str]) -> list[Path]:
    files: list[Path] = []
    for dirpath, dirnames, filenames in os.walk(root, followlinks=followlinks):
        # prune
        if exclude_dirs:
            dirnames[:] = [d for d in dirnames if d not in exclude_dirs]
        for fn in filenames:
            files.append(Path(dirpath) / fn)
    files.sort(key=lambda p: p.as_posix().lower())
    return files

def tree_lines(root: Path, exclude_dirs: set[str], followlinks: bool) -> list[str]:
    """Produce an ASCII tree (dirs then files, sorted)."""
    lines: list[str] = [f"{root.name}/"]
    def walk(d: Path, prefix: str):
        try:
            entries = sorted(
                [e for e in d.iterdir() if e.name not in exclude_dirs],
                key=lambda p: (not p.is_dir(), p.name.lower())
            )
        except PermissionError:
            return
        for i, e in enumerate(entries):
            last = (i == len(entries) - 1)
            conn = "└── " if last else "├── "
            if e.is_dir():
                lines.append(f"{prefix}{conn}{e.name}/")
                walk(e, prefix + ("    " if last else "│   "))
            else:
                lines.append(f"{prefix}{conn}{e.name}")
    walk(root, "")
    return lines

# ---------- Main logic ----------

def collect(root: Path, out_path: Path, followlinks: bool, exclude_dirs: set[str]) -> int:
    root = root.resolve()
    out_path = out_path.resolve()

    if not root.exists() or not root.is_dir():
        print(f"Error: root '{root}' is not a directory.", file=sys.stderr)
        return 2

    files = iter_all_files(root, followlinks, exclude_dirs)
    if not files:
        print("No files found.", file=sys.stderr)
        return 1

    out_path.parent.mkdir(parents=True, exist_ok=True)

    text_count = 0
    bin_count = 0

    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        for f in files:
            # Don't include the output file itself
            try:
                if f.resolve() == out_path:
                    continue
            except Exception:
                pass

            rel = f.relative_to(root)
            try:
                size_bytes = f.stat().st_size
            except Exception:
                size_bytes = None

            try:
                if is_text_file(f):
                    content = read_text_preserve(f)
                    write_header(out, rel, size_bytes)
                    out.write(content)
                    if not content.endswith("\n"):
                        out.write("\n")
                    out.write("\n")
                    text_count += 1
                else:
                    write_header(out, rel, size_bytes, marker="UNSUPPORTED/NON-TEXT")
                    out.write("(contents omitted)\n\n")
                    bin_count += 1
            except Exception as e:
                write_header(out, rel, size_bytes, marker="READ_ERROR")
                out.write(f"[ERROR] {e}\n\n")
                bin_count += 1

        # ---- Append project tree ----
        out.write(f"{HEADER_LINE}\nPROJECT TREE\n{HEADER_LINE}\n")
        for line in tree_lines(root, exclude_dirs, followlinks):
            out.write(line + "\n")

        # ---- Summary ----
        out.write("\n")
        out.write(f"{HEADER_LINE}\nSUMMARY\n{HEADER_LINE}\n")
        out.write(f"Text files written : {text_count}\n")
        out.write(f"Non-text/omitted   : {bin_count}\n")
        out.write(f"Total files seen   : {len(files)}\n")

    print(f"Done. Text={text_count}  Non-text={bin_count}  Wrote -> '{out_path}'.")
    return 0

def parse_excludes(argv_excludes: list[str]) -> set[str]:
    # Accept bare directory names (top-level names) to prune while walking
    return set(argv_excludes or [])

def main():
    ap = argparse.ArgumentParser(description="Write all text files, list non-text files, then append project tree.")
    ap.add_argument("root", type=Path, help="Root directory to scan")
    ap.add_argument("output", type=Path, help="Output .txt file")
    ap.add_argument("--exclude", nargs="*", default=[], help="Directory names to exclude (space-separated)")
    ap.add_argument("--followlinks", action="store_true", help="Follow symlinked directories")
    args = ap.parse_args()

    exclude_dirs = parse_excludes(args.exclude)
    rc = collect(args.root, args.output, followlinks=args.followlinks, exclude_dirs=exclude_dirs)
    sys.exit(rc)

if __name__ == "__main__":
    main()

================================================================================
FILE: features/wallet/domain/model/WalletModels.kt  (size: 692 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.domain.model

data class Card(
    val id: String,
    val brand: String,
    val last4: String,
    val isDefault: Boolean,
    val createdAt: String
)

data class Amount(
    val value: Double,
    val currency: String
)

enum class PaymentStatus { PENDING, PROCESSING, SUCCESS, FAILED, CANCELED }

data class PaymentIntent(
    val intentId: String,
    val status: PaymentStatus,
    val amount: Amount,
    val description: String? = null,
    val returnUrl: String? = null,
    val providerClientSecret: String? = null
)

data class CreateCardSessionResult(
    val sessionId: String,
    val url: String
)

================================================================================
FILE: features/wallet/domain/repository/WalletRepository.kt  (size: 903 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.domain.repository

import com.bankingsystem.mobile.features.wallet.domain.model.*

interface WalletRepository {
    // Cards
    suspend fun getCards(): Result<List<Card>>
    suspend fun startAddCardSession(): Result<CreateCardSessionResult>
    suspend fun makeDefault(cardId: String): Result<Unit>
    suspend fun deleteCard(cardId: String): Result<Unit>

    // Payments
    suspend fun createQrPayment(amount: Amount, qrData: String?, merchantRef: String?, idemKey: String? = null): Result<PaymentIntent>
    suspend fun createReloadPayment(msisdn: String, amount: Amount, idemKey: String? = null): Result<PaymentIntent>
    suspend fun createBillPayment(billerId: String, reference: String, amount: Amount, idemKey: String? = null): Result<PaymentIntent>
    suspend fun getPaymentIntent(intentId: String): Result<PaymentIntent>
}

================================================================================
FILE: features/wallet/integration/api/WalletApi.kt  (size: 1475 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.integration.api

import com.bankingsystem.mobile.features.wallet.integration.remote.dto.*
import retrofit2.Response
import retrofit2.http.*

interface WalletApi {

    // ---- Cards ----
    @GET("api/v1/wallet/cards")
    suspend fun getCards(): CardListResponseDto

    @POST("api/v1/wallet/cards/session")
    suspend fun createAddCardSession(): CreateCardSessionResponseDto

    @PATCH("api/v1/wallet/cards/{id}:default")
    suspend fun makeDefault(@Path("id") id: String): Response<Unit>

    @DELETE("api/v1/wallet/cards/{id}")
    suspend fun deleteCard(@Path("id") id: String): Response<Unit>

    // ---- Payments ----
    @POST("api/v1/wallet/payments/qr")
    suspend fun createQrPayment(
        @Body body: QrPaymentRequestDto,
        @Header("Idempotency-Key") idempotencyKey: String? = null
    ): PaymentIntentDto

    @POST("api/v1/wallet/payments/reload")
    suspend fun createReloadPayment(
        @Body body: ReloadRequestDto,
        @Header("Idempotency-Key") idempotencyKey: String? = null
    ): PaymentIntentDto

    @POST("api/v1/wallet/payments/bill")
    suspend fun createBillPayment(
        @Body body: BillPayRequestDto,
        @Header("Idempotency-Key") idempotencyKey: String? = null
    ): PaymentIntentDto

    @GET("api/v1/wallet/payments/{intentId}")
    suspend fun getPaymentIntent(@Path("intentId") intentId: String): PaymentIntentDto
}

================================================================================
FILE: features/wallet/integration/remote/dto/WalletDtos.kt  (size: 3079 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.integration.remote.dto

import com.bankingsystem.mobile.features.wallet.domain.model.*
import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

// ---- Responses ----

@JsonClass(generateAdapter = true)
data class CardDto(
    @Json(name = "id")        val id: String,
    @Json(name = "brand")     val brand: String,
    @Json(name = "last4")     val last4: String,
    @Json(name = "isDefault") val isDefault: Boolean,
    @Json(name = "createdAt") val createdAt: String
)

@JsonClass(generateAdapter = true)
data class CardListResponseDto(
    @Json(name = "cards") val cards: List<CardDto> = emptyList()
)

@JsonClass(generateAdapter = true)
data class CreateCardSessionResponseDto(
    @Json(name = "sessionId") val sessionId: String,
    @Json(name = "url")       val url: String
)

@JsonClass(generateAdapter = true)
data class AmountDto(
    @Json(name = "value")    val value: Double,
    @Json(name = "currency") val currency: String
)

enum class PaymentStatusDto { PENDING, PROCESSING, SUCCESS, FAILED, CANCELED }

@JsonClass(generateAdapter = true)
data class PaymentIntentDto(
    @Json(name = "intentId")            val intentId: String,
    @Json(name = "status")              val status: PaymentStatusDto,
    @Json(name = "amount")              val amount: AmountDto,
    @Json(name = "description")         val description: String? = null,
    @Json(name = "returnUrl")           val returnUrl: String? = null,
    @Json(name = "providerClientSecret")val providerClientSecret: String? = null
)

// ---- Requests ----

@JsonClass(generateAdapter = true)
data class QrPaymentRequestDto(
    @Json(name = "amount")      val amount: AmountDto,
    @Json(name = "qrData")      val qrData: String? = null,
    @Json(name = "merchantRef") val merchantRef: String? = null
)

@JsonClass(generateAdapter = true)
data class ReloadRequestDto(
    @Json(name = "msisdn") val msisdn: String,
    @Json(name = "amount") val amount: AmountDto
)

@JsonClass(generateAdapter = true)
data class BillPayRequestDto(
    @Json(name = "billerId")  val billerId: String,
    @Json(name = "reference") val reference: String,
    @Json(name = "amount")    val amount: AmountDto
)

// ---- Mappers (DTO <-> Domain) ----

fun CardDto.toDomain() = Card(id, brand, last4, isDefault, createdAt)

fun AmountDto.toDomain() = Amount(value, currency)
fun Amount.toDto() = AmountDto(value, currency)

fun PaymentIntentDto.toDomain() = PaymentIntent(
    intentId = intentId,
    status = when (status) {
        PaymentStatusDto.PENDING -> PaymentStatus.PENDING
        PaymentStatusDto.PROCESSING -> PaymentStatus.PROCESSING
        PaymentStatusDto.SUCCESS -> PaymentStatus.SUCCESS
        PaymentStatusDto.FAILED -> PaymentStatus.FAILED
        PaymentStatusDto.CANCELED -> PaymentStatus.CANCELED
    },
    amount = amount.toDomain(),
    description = description,
    returnUrl = returnUrl,
    providerClientSecret = providerClientSecret
)

================================================================================
FILE: features/wallet/integration/repository/WalletRepositoryImpl.kt  (size: 2482 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.integration.repository

import com.bankingsystem.mobile.features.wallet.domain.model.*
import com.bankingsystem.mobile.features.wallet.domain.repository.WalletRepository
import com.bankingsystem.mobile.features.wallet.integration.api.WalletApi
import com.bankingsystem.mobile.features.wallet.integration.remote.dto.*
import retrofit2.HttpException
import javax.inject.Inject

class WalletRepositoryImpl @Inject constructor(
    private val api: WalletApi
) : WalletRepository {

    // ---- Cards ----
    override suspend fun getCards(): Result<List<Card>> = runCatching {
        api.getCards().cards.map { it.toDomain() }
    }

    override suspend fun startAddCardSession(): Result<CreateCardSessionResult> = runCatching {
        val dto = api.createAddCardSession()
        CreateCardSessionResult(dto.sessionId, dto.url)
    }

    override suspend fun makeDefault(cardId: String): Result<Unit> = runCatching {
        val resp = api.makeDefault(cardId)
        if (!resp.isSuccessful) throw HttpException(resp)
        Unit
    }

    override suspend fun deleteCard(cardId: String): Result<Unit> = runCatching {
        val resp = api.deleteCard(cardId)
        if (!resp.isSuccessful) throw HttpException(resp)
        Unit
    }

    // ---- Payments ----
    override suspend fun createQrPayment(
        amount: Amount,
        qrData: String?,
        merchantRef: String?,
        idemKey: String?
    ): Result<PaymentIntent> = runCatching {
        api.createQrPayment(
            QrPaymentRequestDto(amount = amount.toDto(), qrData = qrData, merchantRef = merchantRef),
            idemKey
        ).toDomain()
    }

    override suspend fun createReloadPayment(
        msisdn: String,
        amount: Amount,
        idemKey: String?
    ): Result<PaymentIntent> = runCatching {
        api.createReloadPayment(ReloadRequestDto(msisdn, amount.toDto()), idemKey).toDomain()
    }

    override suspend fun createBillPayment(
        billerId: String,
        reference: String,
        amount: Amount,
        idemKey: String?
    ): Result<PaymentIntent> = runCatching {
        api.createBillPayment(BillPayRequestDto(billerId, reference, amount.toDto()), idemKey).toDomain()
    }

    override suspend fun getPaymentIntent(intentId: String): Result<PaymentIntent> = runCatching {
        api.getPaymentIntent(intentId).toDomain()
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/AddCardScreen.kt  (size: 4766 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun AddCardScreen(
    modifier: Modifier = Modifier,
    onCancel: () -> Unit,
    onContinueSecurely: () -> Unit
) {
    val cs = MaterialTheme.colorScheme

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Add a card", color = Color.White, style = MaterialTheme.typography.titleLarge)

        // Higher contrast info card
        ElevatedCard(
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.elevatedCardColors(
                containerColor = cs.primary.copy(alpha = 0.20f),
                contentColor = Color.White
            ),
            elevation = CardDefaults.elevatedCardElevation(defaultElevation = 0.dp)
        ) {
            Column(Modifier.fillMaxWidth().padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("We use a secure payment gateway to tokenize your card.")
                Text("We never see or store your full card details.", color = Color.White.copy(0.9f))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Filled.Lock, contentDescription = null, tint = cs.onPrimary)
                    Spacer(Modifier.width(8.dp))
                    Text("Secured by your card issuer (3‑D Secure)")
                }
            }
        }

        val tfColors = TextFieldDefaults.colors(
            focusedContainerColor = Color.Transparent,
            unfocusedContainerColor = Color.Transparent,
            disabledContainerColor = Color.Transparent,
            focusedIndicatorColor = Color.White.copy(alpha = 0.30f),
            unfocusedIndicatorColor = Color.White.copy(alpha = 0.20f),
            disabledIndicatorColor = Color.White.copy(alpha = 0.12f),
            cursorColor = Color.White,
            focusedTextColor = Color.White,
            unfocusedTextColor = Color.White,
            disabledTextColor = Color.White.copy(alpha = 0.6f),
            focusedLabelColor = Color.White,
            unfocusedLabelColor = Color.White.copy(alpha = 0.85f),
            focusedPlaceholderColor = Color.White.copy(alpha = 0.75f),
            unfocusedPlaceholderColor = Color.White.copy(alpha = 0.75f)
        )


        OutlinedTextField(
            value = "",
            onValueChange = {},
            readOnly = true,
            label = { Text("Name on card") },
            placeholder = { Text("e.g., A. Perera") },
            modifier = Modifier.fillMaxWidth(),
            colors = tfColors
        )
        OutlinedTextField(
            value = "",
            onValueChange = {},
            readOnly = true,
            label = { Text("Card number") },
            placeholder = { Text("1234 5678 9012 3456") },
            modifier = Modifier.fillMaxWidth(),
            colors = tfColors
        )
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedTextField(
                value = "",
                onValueChange = {},
                readOnly = true,
                label = { Text("MM/YY") },
                placeholder = { Text("12/28") },
                modifier = Modifier.weight(1f),
                colors = tfColors
            )
            OutlinedTextField(
                value = "",
                onValueChange = {},
                readOnly = true,
                label = { Text("CVV") },
                placeholder = { Text("123") },
                modifier = Modifier.weight(1f),
                colors = tfColors
            )
        }

        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = onCancel, modifier = Modifier.weight(1f)) { Text("Cancel") }
            Button(onClick = onContinueSecurely, modifier = Modifier.weight(1f)) { Text("Continue securely") }
        }

        Text(
            "Tapping ‘Continue securely’ will open a secure page from our payment provider to add your card.",
            color = Color.White.copy(0.85f),
            style = MaterialTheme.typography.bodySmall
        )
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/BillerPayScreen.kt  (size: 1529 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun BillerPayScreen(
    modifier: Modifier = Modifier,
    onConfirm: () -> Unit,
    onCancel: () -> Unit
) {
    var accountRef by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Pay bill", color = Color.White, style = MaterialTheme.typography.titleLarge)

        OutlinedTextField(value = accountRef, onValueChange = { accountRef = it }, label = { Text("Account / Reference") }, modifier = Modifier.fillMaxWidth())
        OutlinedTextField(value = amount, onValueChange = { amount = it }, label = { Text("Amount") }, modifier = Modifier.fillMaxWidth())

        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = onCancel, modifier = Modifier.weight(1f)) { Text("Cancel") }
            Button(onClick = onConfirm, modifier = Modifier.weight(1f)) { Text("Pay now") }
        }

        Text("We’ll charge your saved card via our payment provider and send the payment to the biller.", color = Color.White.copy(0.85f))
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/BillersListScreen.kt  (size: 2815 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun BillersListScreen(
    modifier: Modifier = Modifier,
    onPick: () -> Unit,
    onCancel: () -> Unit
) {
    val cs = MaterialTheme.colorScheme
    val billers = remember { listOf("Electricity Board", "Water Board", "Internet Provider", "Insurance Co.") }
    var search by remember { mutableStateOf("") }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Billers", color = Color.White, style = MaterialTheme.typography.titleLarge)

        OutlinedTextField(
            value = search,
            onValueChange = { search = it },
            label = { Text("Search billers") },
            readOnly = true,
            modifier = Modifier.fillMaxWidth(),
            colors = TextFieldDefaults.colors(
                focusedContainerColor = Color.Transparent,
                unfocusedContainerColor = Color.Transparent,
                focusedTextColor = Color.White,
                unfocusedTextColor = Color.White,
                focusedIndicatorColor = Color.White.copy(alpha = 0.25f),
                unfocusedIndicatorColor = Color.White.copy(alpha = 0.15f),
                focusedLabelColor = Color.White,
                unfocusedLabelColor = Color.White.copy(alpha = 0.85f),
                focusedPlaceholderColor = Color.White.copy(alpha = 0.75f),
                unfocusedPlaceholderColor = Color.White.copy(alpha = 0.75f),
                cursorColor = Color.Transparent
            )

        )

        LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
            items(billers) { biller ->
                ElevatedCard(
                    onClick = onPick,
                    shape = RoundedCornerShape(16.dp),
                    colors = CardDefaults.elevatedCardColors(
                        containerColor = cs.surface.copy(alpha = 0.22f),
                        contentColor = Color.White
                    ),
                    elevation = CardDefaults.elevatedCardElevation(defaultElevation = 0.dp)
                ) {
                    Text(biller, modifier = Modifier.padding(16.dp))
                }
            }
        }

        OutlinedButton(onClick = onCancel) { Text("Back") }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/CardListScreen.kt  (size: 5374 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.wallet.interfaces.ui.components.EmptyState
import com.bankingsystem.mobile.features.wallet.interfaces.ui.components.ErrorBanner
import com.bankingsystem.mobile.features.wallet.interfaces.ui.components.ShimmerBox
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletStrings
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletUiTokens

@Composable
fun CardListScreen(
    modifier: Modifier = Modifier,
    state: WalletUiState,
    onAddCard: () -> Unit,
    onBack: () -> Unit,
    onMakeDefault: (String) -> Unit,
    onDelete: (String) -> Unit
) {
    Column(modifier = modifier.fillMaxSize().padding(20.dp)) {
        Row(
            Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text("My Cards", color = Color.White, style = MaterialTheme.typography.titleLarge)
            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                OutlinedButton(onClick = onBack) { Text("Back") }
                Button(onClick = onAddCard) { Text("Add card") }
            }
        }
        Spacer(Modifier.height(12.dp))

        state.lastError?.let { ErrorBanner(message = it); Spacer(Modifier.height(12.dp)) }

        when {
            state.isLoadingCards -> {
                Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    repeat(3) { ShimmerBox(height = 72) }
                }
            }
            state.cards.isEmpty() -> {
                EmptyState(
                    title = WalletStrings.NoCardsTitle,
                    subtitle = WalletStrings.NoCardsSubtitle,
                    cta = WalletStrings.AddCardCta,
                    onCta = onAddCard
                )
            }
            else -> {
                LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    items(state.cards, key = { it.id }) { card ->
                        ElevatedCard(
                            shape = RoundedCornerShape(16.dp),
                            colors = CardDefaults.elevatedCardColors(
                                containerColor = MaterialTheme.colorScheme.surface.copy(
                                    alpha = WalletUiTokens.CardSurfaceAlpha
                                )
                            ),
                            elevation = CardDefaults.elevatedCardElevation(defaultElevation = 0.dp)
                        ) {
                            Row(
                                Modifier.fillMaxWidth().padding(16.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Column(Modifier.weight(1f)) {
                                    Text(
                                        "${card.brand} •••• ${card.last4}",
                                        color = Color.White,
                                        style = MaterialTheme.typography.titleMedium
                                    )
                                    Text(
                                        "Exp ${card.expMonth}/${card.expYear}",
                                        color = Color.White.copy(0.85f)
                                    )
                                }
                                if (card.isDefault) {
                                    Icon(
                                        Icons.Filled.CheckCircle,
                                        contentDescription = null,
                                        tint = MaterialTheme.colorScheme.primary
                                    )
                                } else {
                                    OutlinedButton(onClick = { onMakeDefault(card.id) }) {
                                        Text("Make default")
                                    }
                                }
                                Spacer(Modifier.width(8.dp))
                                IconButton(onClick = { onDelete(card.id) }) {
                                    Icon(
                                        Icons.Filled.Delete,
                                        contentDescription = "Delete",
                                        tint = Color.White.copy(0.9f)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/CardsViewModel.kt  (size: 2019 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.features.wallet.domain.model.Card
import com.bankingsystem.mobile.features.wallet.domain.repository.WalletRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

data class CardsUiState(
    val loading: Boolean = false,
    val cards: List<Card> = emptyList(),
    val error: String? = null
)

@HiltViewModel
class CardsViewModel @Inject constructor(
    private val walletRepo: WalletRepository
) : ViewModel() {

    private val _state = MutableStateFlow(CardsUiState(loading = true))
    val state: StateFlow<CardsUiState> = _state

    init { refresh() }

    fun refresh() = viewModelScope.launch {
        _state.value = _state.value.copy(loading = true, error = null)
        walletRepo.getCards()
            .onSuccess { _state.value = CardsUiState(cards = it) }
            .onFailure { _state.value = CardsUiState(error = it.message ?: "Failed to load cards") }
    }

    fun makeDefault(id: String) = viewModelScope.launch {
        walletRepo.makeDefault(id)
            .onSuccess { refresh() }
            .onFailure { /* TODO: surface error */ }
    }

    fun delete(id: String) = viewModelScope.launch {
        walletRepo.deleteCard(id)
            .onSuccess { refresh() }
            .onFailure { /* TODO: surface error */ }
    }

    /** Start provider-hosted Add-Card session; returns URL via onUrl. */
    fun launchAddCardSession(
        onUrl: (String) -> Unit,
        onError: (String) -> Unit
    ) = viewModelScope.launch {
        walletRepo.startAddCardSession()
            .onSuccess { onUrl(it.url) }
            .onFailure { onError(it.message ?: "Failed to start add-card session") }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/common.kt  (size: 826 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.runtime.Immutable

@Immutable
data class WalletCardUi(
    val id: String,
    val brand: String,   // e.g., VISA, MASTERCARD
    val last4: String,
    val expMonth: Int,
    val expYear: Int,
    val isDefault: Boolean = false,
)

@Immutable
data class QrPreview(
    val merchantName: String = "",
    val amount: String = "", // display-only string for UI
    val memo: String = ""
)

@Immutable
data class WalletUiState(
    val cards: List<WalletCardUi> = listOf(
        WalletCardUi(id = "1", brand = "VISA", last4 = "4242", expMonth = 12, expYear = 28, isDefault = true)
    ),
    val isLoadingCards: Boolean = false,
    val lastError: String? = null,
    val qrPreview: QrPreview = QrPreview()
)

================================================================================
FILE: features/wallet/interfaces/ui/components/CopyableField.kt  (size: 1080 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.components

import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ContentCopy
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun CopyableField(label: String, value: String) {
    Row(Modifier.fillMaxWidth().padding(vertical = 6.dp)) {
        Text("$label: ", color = Color.White.copy(0.75f), style = MaterialTheme.typography.labelMedium)
        Text(value, color = Color.White)
        Spacer(Modifier.weight(1f))
        IconButton(onClick = { /* copy to clipboard (no logic) */ }) {
            Icon(Icons.Filled.ContentCopy, contentDescription = "Copy", tint = Color.White)
        }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/components/EmptyState.kt  (size: 1244 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material3.Button
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun EmptyState(
    title: String,
    subtitle: String,
    cta: String,
    onCta: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxWidth().padding(20.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Icon(Icons.Filled.CreditCard, contentDescription = null, tint = Color.White)
        Text(title, color = Color.White, style = MaterialTheme.typography.titleMedium)
        Text(subtitle, color = Color.White.copy(0.85f))
        Spacer(Modifier.height(8.dp))
        Button(onClick = onCta) { Text(cta) }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/components/ErrorBanner.kt  (size: 1296 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.components

import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletUiTokens

@Composable
fun ErrorBanner(message: String) {
    ElevatedCard(
        shape = RoundedCornerShape(14.dp),
        colors = CardDefaults.elevatedCardColors(
            containerColor = WalletUiTokens.Danger.copy(alpha = 0.18f),
            contentColor = Color.White
        ),
        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 0.dp),
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(Modifier.fillMaxWidth().padding(12.dp)) {
            Text(message, style = MaterialTheme.typography.bodyMedium)
        }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/components/SavedCardChip.kt  (size: 966 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.components

import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun SavedCardChip(
    brand: String,
    last4: String,
    exp: String,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .border(1.dp, MaterialTheme.colorScheme.outline.copy(alpha = 0.4f), RoundedCornerShape(100))
            .padding(horizontal = 12.dp, vertical = 6.dp)
    ) {
        Text(text = "$brand •••• $last4  ·  $exp", color = Color.White)
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/components/ShimmerBox.kt  (size: 1920 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.components

import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun ShimmerBox(height: Int = 56) {
    val transition = rememberInfiniteTransition(label = "shimmer")
    val x by transition.animateFloat(
        initialValue = 0f,
        targetValue = 1000f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 1200, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "offset"
    )

    val brush = Brush.linearGradient(
        colors = listOf(
            Color.White.copy(alpha = 0.08f),
            Color.White.copy(alpha = 0.18f),
            Color.White.copy(alpha = 0.08f)
        ),
        start = androidx.compose.ui.geometry.Offset(x, 0f),
        end = androidx.compose.ui.geometry.Offset(x + 200f, 200f)
    )

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(height.dp)
            .clip(RoundedCornerShape(16.dp))
            .background(brush)
    )
}

================================================================================
FILE: features/wallet/interfaces/ui/components/StatusPill.kt  (size: 887 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun StatusPill(text: String) {
    Box(
        modifier = Modifier
            .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f), RoundedCornerShape(100))
            .padding(horizontal = 10.dp, vertical = 4.dp)
    ) {
        Text(text, color = Color.White, style = MaterialTheme.typography.labelMedium)
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/MobileReloadScreen.kt  (size: 1519 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun MobileReloadScreen(
    modifier: Modifier = Modifier,
    onConfirm: () -> Unit,
    onCancel: () -> Unit
) {
    var msisdn by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Mobile reload", color = Color.White, style = MaterialTheme.typography.titleLarge)

        OutlinedTextField(value = msisdn, onValueChange = { msisdn = it }, label = { Text("Mobile number") }, modifier = Modifier.fillMaxWidth())
        OutlinedTextField(value = amount, onValueChange = { amount = it }, label = { Text("Amount") }, modifier = Modifier.fillMaxWidth())

        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = onCancel, modifier = Modifier.weight(1f)) { Text("Cancel") }
            Button(onClick = onConfirm, modifier = Modifier.weight(1f)) { Text("Pay now") }
        }

        Text("Your card will be charged via our payment provider. Airtime is usually delivered instantly.", color = Color.White.copy(0.85f))
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/objects/WalletStrings.kt  (size: 789 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.objects

object WalletStrings {
    const val NoCardsTitle = "No cards yet"
    const val NoCardsSubtitle = "Add a debit or credit card to start paying."
    const val AddCardCta = "Add card"

    const val CameraPermTitle = "Camera permission needed"
    const val CameraPermBody = "Allow camera access to scan QR codes. You can also enter the payment manually."
    const val OpenSettings = "Open settings"

    const val ProcessingTitle = "Processing with payment provider…"
    const val LeaveProcessing = "Leave processing?"
    const val LeaveProcessingBody = "Your payment may still be confirming. You can return later from the Wallet home."
    const val Stay = "Stay"
    const val Leave = "Leave"
}

================================================================================
FILE: features/wallet/interfaces/ui/objects/WalletUiTokens.kt  (size: 392 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui.objects

import androidx.compose.ui.graphics.Color

object WalletUiTokens {
    const val CardSurfaceAlpha = 0.22f
    const val HeaderSurfaceAlpha = 0.28f
    const val BorderAlphaFocused = 0.30f
    const val BorderAlphaUnfocused = 0.20f
    const val LabelAlphaUnfocused = 0.85f
    val Danger = Color(0xFFEF5350)
}

================================================================================
FILE: features/wallet/interfaces/ui/PaymentResultScreen.kt  (size: 1315 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun PaymentResultScreen(
    modifier: Modifier = Modifier,
    onDone: () -> Unit,
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(Icons.Default.CheckCircle, contentDescription = null, tint = MaterialTheme.colorScheme.primary, modifier = Modifier.size(64.dp))
        Spacer(Modifier.height(12.dp))
        Text("Payment complete (UI only)", style = MaterialTheme.typography.titleLarge, color = Color.White)
        Spacer(Modifier.height(6.dp))
        Text("This is a placeholder screen without real processing.", color = Color.White.copy(0.75f))
        Spacer(Modifier.height(16.dp))
        Button(onClick = onDone) { Text("Done") }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/ProcessingScreen.kt  (size: 2098 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.wallet.interfaces.ui.components.StatusPill
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletStrings

@Composable
fun ProcessingScreen(
    modifier: Modifier = Modifier,
    onDone: () -> Unit,
    onBackHome: () -> Unit
) {
    var showLeaveDialog by remember { mutableStateOf(false) }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        CircularProgressIndicator()
        Spacer(Modifier.height(12.dp))
        Text(WalletStrings.ProcessingTitle, color = Color.White)
        Spacer(Modifier.height(16.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = { showLeaveDialog = true }) { Text("Back to home") }
            Button(onClick = onDone) { Text("Continue") }
        }
        Spacer(Modifier.height(24.dp))
        Column(verticalArrangement = Arrangement.spacedBy(8.dp), horizontalAlignment = Alignment.CenterHorizontally) {
            StatusPill("Created")
            StatusPill("Requires Auth")
            StatusPill("Processing")
        }
    }

    if (showLeaveDialog) {
        AlertDialog(
            onDismissRequest = { showLeaveDialog = false },
            title = { Text(WalletStrings.LeaveProcessing) },
            text = { Text(WalletStrings.LeaveProcessingBody) },
            confirmButton = { TextButton(onClick = { showLeaveDialog = false }) { Text(WalletStrings.Stay) } },
            dismissButton = { TextButton(onClick = onBackHome) { Text(WalletStrings.Leave) } }
        )
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/QrPayConfirmScreen.kt  (size: 2889 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun QrPayConfirmScreen(
    modifier: Modifier = Modifier,
    state: WalletUiState,
    onChangeCard: () -> Unit,
    onConfirm: () -> Unit,
    onCancel: () -> Unit
) {
    val preview = state.qrPreview

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Confirm payment", color = Color.White, style = MaterialTheme.typography.titleLarge)

        Surface(shape = RoundedCornerShape(16.dp), color = MaterialTheme.colorScheme.surface.copy(alpha = 0.3f)) {
            Column(Modifier.fillMaxWidth().padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                Labeled("Merchant", preview.merchantName)
                if (preview.amount.isNotBlank()) Labeled("Amount", preview.amount)
                if (preview.memo.isNotBlank()) Labeled("Note", preview.memo)
            }
        }

        // Card picker (UI only)
        Surface(shape = RoundedCornerShape(16.dp), color = MaterialTheme.colorScheme.surface.copy(alpha = 0.22f)) {
            Column(Modifier.fillMaxWidth().padding(16.dp), verticalArrangement = Arrangement.spacedBy(10.dp)) {
                Text("Payment method", color = Color.White, fontWeight = FontWeight.SemiBold)
                state.cards.forEach { card ->
                    SavedCardRow(card = card, isSelected = card.isDefault)
                }
                OutlinedButton(onClick = onChangeCard) { Text("Change / Manage cards") }
            }
        }

        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = onCancel, modifier = Modifier.weight(1f)) { Text("Cancel") }
            Button(onClick = onConfirm, modifier = Modifier.weight(1f)) { Text("Pay now") }
        }
    }
}

@Composable
private fun Labeled(label: String, value: String) {
    Column { Text(label, style = MaterialTheme.typography.labelMedium, color = Color.White.copy(0.75f)); Text(value, color = Color.White) }
}

@Composable
private fun SavedCardRow(card: WalletCardUi, isSelected: Boolean) {
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
        Text("${card.brand} •••• ${card.last4}  (Exp ${card.expMonth}/${card.expYear})", color = Color.White)
        if (isSelected) Text("Default", color = MaterialTheme.colorScheme.primary)
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/QrPayScanScreen.kt  (size: 3486 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.QrCodeScanner
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletStrings
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletUiTokens

@Composable
fun QrPayScanScreen(
    modifier: Modifier = Modifier,
    onCancel: () -> Unit,
    onScanned: (QrPreview) -> Unit
) {
    val showPermissionPrompt = remember { mutableStateOf(true) }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Scan QR", color = Color.White, style = MaterialTheme.typography.titleLarge)

        if (showPermissionPrompt.value) {
            ElevatedCard(
                shape = RoundedCornerShape(16.dp),
                colors = CardDefaults.elevatedCardColors(
                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = WalletUiTokens.CardSurfaceAlpha),
                    contentColor = Color.White
                ),
                elevation = CardDefaults.elevatedCardElevation(defaultElevation = 0.dp)
            ) {
                Column(Modifier.fillMaxWidth().padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text(WalletStrings.CameraPermTitle, style = MaterialTheme.typography.titleSmall)
                    Text(WalletStrings.CameraPermBody, color = Color.White.copy(0.9f))
                    Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                        OutlinedButton(onClick = { showPermissionPrompt.value = false }) { Text("Not now") }
                        Button(onClick = { /* open settings (UI-only) */ }) { Text(WalletStrings.OpenSettings) }
                    }
                }
            }
        }

        // Camera preview placeholder (UI only)
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
                .background(Color.Black.copy(alpha = 0.2f), RoundedCornerShape(16.dp)),
            contentAlignment = Alignment.Center
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Icon(Icons.Filled.QrCodeScanner, contentDescription = null, tint = Color.White)
                Spacer(Modifier.height(8.dp))
                Text("Camera preview (placeholder)", color = Color.White.copy(0.9f))
            }
        }

        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            OutlinedButton(onClick = onCancel, modifier = Modifier.weight(1f)) { Text("Cancel") }
            Button(onClick = { onScanned(QrPreview(merchantName = "Demo Store", amount = "1,250.00", memo = "Coffee")) }, modifier = Modifier.weight(1f)) {
                Text("Simulate scan")
            }
        }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/WalletHomeScreen.kt  (size: 4366 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.QrCodeScanner
import androidx.compose.material.icons.filled.ReceiptLong
import androidx.compose.material.icons.filled.SwapVerticalCircle
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun WalletHomeScreen(
    modifier: Modifier = Modifier,
    state: WalletUiState,
    onOpenCards: () -> Unit,
    onAddCard: () -> Unit,
    onScanQr: () -> Unit,
    onReload: () -> Unit,
    onBiller: () -> Unit,
) {
    val cs = MaterialTheme.colorScheme

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // My Cards summary
        Surface(
            shape = RoundedCornerShape(20.dp),
            color = cs.primary.copy(alpha = 0.28f)
        ) {
            Row(
                Modifier.fillMaxWidth().padding(18.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(Modifier.weight(1f)) {
                    Text("My Cards", color = Color.White, style = MaterialTheme.typography.titleLarge, fontWeight = FontWeight.SemiBold)
                    Spacer(Modifier.height(4.dp))
                    val defaultCard = state.cards.firstOrNull { it.isDefault }
                    Text(
                        defaultCard?.let { "Default: ${it.brand} •••• ${it.last4}" } ?: "No default card",
                        color = Color.White.copy(0.9f)
                    )
                }
                Button(onClick = onOpenCards) { Text("Manage") }
            }
        }

        // Quick actions
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
            QuickActionCard("Scan QR", Icons.Filled.QrCodeScanner, onScanQr, Modifier.weight(1f))
            QuickActionCard("Mobile Reload", Icons.Filled.SwapVerticalCircle, onReload, Modifier.weight(1f))
            QuickActionCard("Pay a Bill", Icons.Filled.ReceiptLong, onBiller, Modifier.weight(1f))
        }

        // Add card CTA
        ElevatedCard(shape = RoundedCornerShape(16.dp), colors = CardDefaults.elevatedCardColors(containerColor = cs.surface.copy(alpha = 0.22f))) {
            Row(Modifier.fillMaxWidth().padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Filled.CreditCard, contentDescription = null, tint = Color.White)
                Spacer(Modifier.width(12.dp))
                Column(Modifier.weight(1f)) {
                    Text("Add a card", color = Color.White, style = MaterialTheme.typography.titleMedium)
                    Text("Save a debit or credit card for faster checkout.", color = Color.White.copy(0.85f))
                }
                OutlinedButton(onClick = onAddCard) { Text("Add") }
            }
        }
    }
}

@Composable
private fun QuickActionCard(title: String, icon: androidx.compose.ui.graphics.vector.ImageVector, onClick: () -> Unit, modifier: Modifier = Modifier) {
    val cs = MaterialTheme.colorScheme
    ElevatedCard(
        onClick = onClick,
        modifier = modifier,
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.elevatedCardColors(containerColor = cs.surface.copy(alpha = 0.22f))
    ) {
        Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(10.dp), horizontalAlignment = Alignment.Start) {
            Icon(icon, contentDescription = null, tint = Color.White)
            Text(title, style = MaterialTheme.typography.titleMedium, color = Color.White)
            Text("Use your saved card to pay.", style = MaterialTheme.typography.bodySmall, color = Color.White.copy(0.85f))
        }
    }
}

================================================================================
FILE: features/wallet/interfaces/ui/WalletRoute.kt  (size: 10782 bytes)
================================================================================
package com.bankingsystem.mobile.features.wallet.interfaces.ui

import android.annotation.SuppressLint
import android.net.Uri
import androidx.browser.customtabs.CustomTabsIntent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material3.rememberDrawerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.bankingsystem.mobile.core.modules.common.designsystem.FadingAppBackground
import com.bankingsystem.mobile.core.modules.common.designsystem.Sidebar
import com.bankingsystem.mobile.features.wallet.interfaces.ui.objects.WalletUiTokens
import kotlinx.coroutines.launch

@SuppressLint("ConfigurationScreenWidthHeight")
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WalletRoute(
    userName: String,
    selectedItem: String = "Wallet",
    onNavigate: (String) -> Unit
) {
    val config = LocalConfiguration.current
    val isCompact = config.screenWidthDp < 600

    var screen by remember { mutableStateOf(WalletScreen.HOME) }
    var uiState by remember { mutableStateOf(WalletUiState()) }

    // ---- Cards ViewModel wiring (NEW) ----
    val cardsVm = hiltViewModel<CardsViewModel>()
    val cardsState by cardsVm.state.collectAsState()

    LaunchedEffect(cardsState.loading, cardsState.error, cardsState.cards) {
        uiState = uiState.copy(
            isLoadingCards = cardsState.loading,
            lastError = cardsState.error,
            cards = cardsState.cards.map { it.toWalletUi() }
        )
    }

    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()
    val ctx = LocalContext.current

    val topBar: @Composable () -> Unit = {
        TopAppBar(
            title = { Text(selectedItem, color = Color.White) },
            navigationIcon = {
                if (screen != WalletScreen.HOME) {
                    IconButton(onClick = { screen = WalletScreen.HOME }) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = "Back",
                            tint = Color.White
                        )
                    }
                }
            },
            actions = {
                if (isCompact) {
                    IconButton(onClick = { scope.launch { drawerState.open() } }) {
                        Icon(Icons.Filled.Menu, contentDescription = "Menu", tint = Color.White)
                    }
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = Color.Transparent,
                scrolledContainerColor = Color.Transparent,
                titleContentColor = Color.White,
                navigationIconContentColor = Color.White,
                actionIconContentColor = Color.White
            )
        )
    }

    val content: @Composable (PaddingValues) -> Unit = { padding ->
        Box(Modifier.fillMaxSize().padding(padding)) {
            when (screen) {
                WalletScreen.HOME -> WalletHomeScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    state = uiState,
                    onOpenCards = { screen = WalletScreen.CARDS },
                    onAddCard = { screen = WalletScreen.ADD_CARD },
                    onScanQr = { screen = WalletScreen.QR_SCAN },
                    onReload = { screen = WalletScreen.RELOAD },
                    onBiller = { screen = WalletScreen.BILLERS }
                )

                WalletScreen.CARDS -> CardListScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    state = uiState,
                    onAddCard = { screen = WalletScreen.ADD_CARD },
                    onBack = { screen = WalletScreen.HOME },
                    onMakeDefault = { id -> cardsVm.makeDefault(id) },
                    onDelete = { id -> cardsVm.delete(id) }
                )

                WalletScreen.ADD_CARD -> AddCardScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onCancel = { screen = WalletScreen.CARDS },
                    onContinueSecurely = {
                        // Start hosted add-card session and open provider page
                        cardsVm.launchAddCardSession(
                            onUrl = { url ->
                                CustomTabsIntent.Builder().build()
                                    .launchUrl(ctx, Uri.parse(url))
                                // Stay here; deep link return will navigate/update as needed
                            },
                            onError = { /* TODO show error banner/snackbar */ }
                        )
                    }
                )

                WalletScreen.QR_SCAN -> QrPayScanScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onCancel = { screen = WalletScreen.HOME },
                    onScanned = { parsed ->
                        uiState = uiState.copy(qrPreview = parsed)
                        screen = WalletScreen.QR_CONFIRM
                    }
                )

                WalletScreen.QR_CONFIRM -> QrPayConfirmScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    state = uiState,
                    onChangeCard = { screen = WalletScreen.CARDS },
                    onConfirm = { screen = WalletScreen.PROCESSING },
                    onCancel = { screen = WalletScreen.HOME }
                )

                WalletScreen.RELOAD -> MobileReloadScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onConfirm = { screen = WalletScreen.PROCESSING },
                    onCancel = { screen = WalletScreen.HOME }
                )

                WalletScreen.BILLERS -> BillersListScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onPick = { screen = WalletScreen.BILL_PAY },
                    onCancel = { screen = WalletScreen.HOME }
                )

                WalletScreen.BILL_PAY -> BillerPayScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onConfirm = { screen = WalletScreen.PROCESSING },
                    onCancel = { screen = WalletScreen.BILLERS }
                )

                WalletScreen.PROCESSING -> ProcessingScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onDone = { screen = WalletScreen.RESULT },
                    onBackHome = { screen = WalletScreen.HOME }
                )

                WalletScreen.RESULT -> PaymentResultScreen(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 20.dp),
                    onDone = { screen = WalletScreen.HOME }
                )
            }
        }
    }

    if (isCompact) {
        ModalNavigationDrawer(
            drawerState = drawerState,
            drawerContent = {
                ModalDrawerSheet(drawerContainerColor = Color(0xFF0B0B12)) {
                    Sidebar(
                        selectedItem = selectedItem,
                        onItemClick = { label ->
                            scope.launch { drawerState.close() }
                            onNavigate(label)
                        },
                        userName = userName
                    )
                }
            }
        ) {
            Box(Modifier.fillMaxSize()) {
                FadingAppBackground()
                Scaffold(containerColor = Color.Transparent, topBar = topBar, content = content)
            }
        }
    } else {
        Row(Modifier.fillMaxSize()) {
            Surface(
                modifier = Modifier
                    .fillMaxHeight()
                    .width(300.dp),
                tonalElevation = 0.dp,
                shadowElevation = 16.dp
            ) {
                Sidebar(
                    selectedItem = selectedItem,
                    onItemClick = onNavigate,
                    userName = userName
                )
            }
            Box(Modifier.weight(1f).fillMaxHeight()) {
                FadingAppBackground()
                Scaffold(containerColor = Color.Transparent, topBar = topBar, content = content)
            }
        }
    }
}

private enum class WalletScreen {
    HOME, CARDS, ADD_CARD, QR_SCAN, QR_CONFIRM, RELOAD, BILLERS, BILL_PAY, PROCESSING, RESULT
}

// Domain -> UI mapper
private fun com.bankingsystem.mobile.features.wallet.domain.model.Card.toWalletUi() =
    WalletCardUi(
        id = id,
        brand = brand,
        last4 = last4,
        // Domain model doesn't include exp; keep defaults used in UI
        expMonth = 0,
        expYear = 0,
        isDefault = isDefault
    )

================================================================================
FILE: local.properties  (size: 25 bytes)
================================================================================
sdk.dir=D\:/Android/Sdk

================================================================================
FILE: MainActivity.kt  (size: 5696 bytes)
================================================================================
package com.bankingsystem.mobile

import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.viewModels
import androidx.annotation.RequiresApi
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.runtime.*
import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen
import androidx.hilt.navigation.compose.hiltViewModel
import dagger.hilt.android.AndroidEntryPoint
import com.bankingsystem.mobile.core.modules.common.storage.LockPreferences
import com.bankingsystem.mobile.features.lock.interfaces.ui.AppLocker
import com.bankingsystem.mobile.features.auth.interfaces.ui.LoginScreen
import com.bankingsystem.mobile.features.auth.interfaces.ui.LoginState
import com.bankingsystem.mobile.features.auth.interfaces.ui.LoginViewModel
import com.bankingsystem.mobile.app.navigation.AppNavHost
import com.bankingsystem.mobile.features.auth.interfaces.ui.RegisterScreen
import com.bankingsystem.mobile.core.modules.common.designsystem.theme.BankAppTheme
import com.bankingsystem.mobile.features.wallet.interfaces.ui.CardsViewModel

@ExperimentalMaterial3Api
@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    private lateinit var lockPreferences: LockPreferences

    private val cardsVm: CardsViewModel by viewModels()

    private var walletReturnPending: Boolean = false

    @RequiresApi(Build.VERSION_CODES.O)
    override fun onCreate(savedInstanceState: Bundle?) {
        installSplashScreen()
        super.onCreate(savedInstanceState)
        lockPreferences = LockPreferences(this)

        handleWalletReturnDeepLink(intent?.data)

        setContent {
            BankAppTheme {
                val loginViewModel: LoginViewModel = hiltViewModel()
                val loginState by loginViewModel.loginState.collectAsState()

                var lockerAuthenticated by remember { mutableStateOf(false) }
                var lockEnabled by remember { mutableStateOf(false) }
                var storedPin by remember { mutableStateOf("") }
                var showRegister by remember { mutableStateOf(false) }

                LaunchedEffect(Unit) { loginViewModel.autoLogin() }

                LaunchedEffect(loginState) {
                    if (loginState is LoginState.Success) {
                        lockEnabled = lockPreferences.isLockEnabled()
                        storedPin = lockPreferences.getPin() ?: ""
                        lockerAuthenticated = !lockEnabled
                        showRegister = false

                        if (walletReturnPending) {
                            cardsVm.refresh()
                            walletReturnPending = false
                        }
                    } else {
                        lockerAuthenticated = false
                        lockEnabled = false
                        storedPin = ""
                    }
                }

                val doLogout: () -> Unit = {
                    lockerAuthenticated = false
                    lockEnabled = false
                    storedPin = ""
                    loginViewModel.logout()
                }

                when (val state = loginState) {
                    is LoginState.Success -> {
                        if (lockEnabled && !lockerAuthenticated) {
                            AppLocker(
                                correctPin = storedPin,
                                onAuthenticated = {
                                    lockerAuthenticated = true
                                    if (walletReturnPending) {
                                        cardsVm.refresh()
                                        walletReturnPending = false
                                    }
                                }
                            )
                        } else {
                            AppNavHost(
                                userName = state.username,
                                onLogout = doLogout
                            )
                        }
                    }
                    is LoginState.Error, LoginState.Idle, is LoginState.Loading -> {
                        if (showRegister) {
                            RegisterScreen(
                                onRegisterSuccess = { showRegister = false },
                                onNavigateToLogin = { showRegister = false }
                            )
                        } else {
                            LoginScreen(
                                onNavigate = { },
                                onNavigateToRegister = { showRegister = true }
                            )
                        }
                    }
                }
            }
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        setIntent(intent)
        handleWalletReturnDeepLink(intent.data)
    }

    private fun handleWalletReturnDeepLink(uri: Uri?) {
        if (uri == null) return
        val isWalletReturn = uri.scheme == "mybank" &&
                uri.host == "wallet" &&
                (uri.path?.startsWith("/return") == true)
        if (!isWalletReturn) return

        // Optional: read params if needed later
        // val status = uri.getQueryParameter("status")
        // val pi = uri.getQueryParameter("pi")

        walletReturnPending = true
        runCatching { cardsVm.refresh() }
    }
}

================================================================================
PROJECT TREE
================================================================================
mobile/
├── app/
│   ├── di/
│   │   ├── AccountsBindings.kt
│   │   ├── AuthBindings.kt
│   │   ├── CustomerBindings.kt
│   │   ├── KycBindings.kt
│   │   ├── NetworkModule.kt
│   │   ├── ProfileBindings.kt
│   │   ├── Qualifiers.kt
│   │   ├── StorageModule.kt
│   │   └── WalletBindings.kt
│   └── navigation/
│       ├── AppNavHost.kt
│       └── Routes.kt
├── core/
│   └── modules/
│       └── common/
│           ├── designsystem/
│           │   ├── theme/
│           │   │   ├── Color.kt
│           │   │   ├── Fonts.kt
│           │   │   └── Theme.kt
│           │   ├── AppBackground.kt
│           │   ├── Button.kt
│           │   ├── FadingAppBackground.kt
│           │   ├── InputField.kt
│           │   ├── PasswordTextField.kt
│           │   ├── PrimaryButton.kt
│           │   ├── QuickAction.kt
│           │   ├── SelectionCard.kt
│           │   ├── Sidebar.kt
│           │   └── ValidatedTextField.kt
│           ├── network/
│           │   ├── AuthErrorInterceptor.kt
│           │   └── AuthInterceptor.kt
│           ├── security/
│           │   ├── EncryptionHelper.kt
│           │   └── KeyStoreManager.kt
│           ├── storage/
│           │   ├── AuthStore.kt
│           │   ├── AuthStoreImpl.kt
│           │   ├── DefaultAccountStore.kt
│           │   ├── LockPreferences.kt
│           │   └── TokenManager.kt
│           └── util/
│               ├── BiometricHelper.kt
│               └── PasswordUtils.kt
├── features/
│   ├── accounts/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── errors/
│   │   │   │   ├── ApiCallException.kt
│   │   │   │   └── CustomerMissingException.kt
│   │   │   ├── model/
│   │   │   │   ├── Account.kt
│   │   │   │   ├── Branch.kt
│   │   │   │   └── Transaction.kt
│   │   │   └── repository/
│   │   │       └── AccountRepository.kt
│   │   ├── integration/
│   │   │   ├── remote/
│   │   │   │   ├── api/
│   │   │   │   │   └── AccountsApi.kt
│   │   │   │   └── dto/
│   │   │   │       └── AccountNet.kt
│   │   │   └── repository/
│   │   │       └── AccountRepositoryImpl.kt
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── models/
│   │           │   └── AccountUi.kt
│   │           ├── AccountMappers.kt
│   │           ├── AccountsRoute.kt
│   │           ├── AccountTransactionsRoute.kt
│   │           ├── AccountTransactionsScreen.kt
│   │           ├── AccountTransactionsViewModel.kt
│   │           ├── MyAccountsRoute.kt
│   │           ├── MyAccountsScreen.kt
│   │           ├── MyAccountsViewModel.kt
│   │           ├── OpenAccountScreen.kt
│   │           └── OpenAccountViewModel.kt
│   ├── auth/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   │   └── ValidateTokenResponse.kt
│   │   │   └── repository/
│   │   │       └── UserRepository.kt
│   │   ├── integration/
│   │   │   ├── remote/
│   │   │   │   ├── api/
│   │   │   │   │   └── AuthApi.kt
│   │   │   │   └── dto/
│   │   │   │       ├── LoginRequest.kt
│   │   │   │       ├── LoginResponse.kt
│   │   │   │       └── RegisterRequest.kt
│   │   │   └── repository/
│   │   │       └── UserRepositoryImpl.kt
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── LoginScreen.kt
│   │           ├── LoginViewModel.kt
│   │           ├── RegisterScreen.kt
│   │           └── RegisterViewModel.kt
│   ├── customer/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   │   └── CustomerRequest.kt
│   │   │   └── repository/
│   │   │       └── CustomerRepository.kt
│   │   ├── integration/
│   │   │   └── remote/
│   │   │       ├── api/
│   │   │       │   └── CustomerApi.kt
│   │   │       ├── dto/
│   │   │       │   └── CustomerDtos.kt
│   │   │       └── repository/
│   │   │           └── CustomerRepositoryImpl.kt
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── CustomerRegistrationScreen.kt
│   │           └── CustomerRegistrationViewModel.kt
│   ├── home/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   └── repository/
│   │   ├── integration/
│   │   │   └── remote/
│   │   │       ├── api/
│   │   │       └── dto/
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── model/
│   │           │   └── UiTransaction.kt
│   │           ├── BalanceCard.kt
│   │           ├── BankHomeRoute.kt
│   │           ├── BankHomeScreen.kt
│   │           ├── HomeViewModel.kt
│   │           └── Transactions.kt
│   ├── kyc/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   │   ├── KycCaseStatus.kt
│   │   │   │   ├── KycCheck.kt
│   │   │   │   ├── KycSubmitResponse.kt
│   │   │   │   ├── KycUploadIds.kt
│   │   │   │   └── UploadedPart.kt
│   │   │   └── repository/
│   │   │       └── KycRepository.kt
│   │   ├── integration/
│   │   │   ├── remote/
│   │   │   │   ├── api/
│   │   │   │   │   └── KycApi.kt
│   │   │   │   └── dto/
│   │   │   │       ├── KycCaseStatusResponse.kt
│   │   │   │       ├── KycCheckDto.kt
│   │   │   │       ├── KycSubmitBody.kt
│   │   │   │       ├── KycSubmitResponse.kt
│   │   │   │       └── UploadedPart.kt
│   │   │   └── repository/
│   │   │       └── KycRepositoryImpl.kt
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── KycCameraHelpers.kt
│   │           ├── KycComponents.kt
│   │           ├── KycModels.kt
│   │           ├── KycRoute.kt
│   │           ├── KycScreens.kt
│   │           ├── KycStatusRoute.kt
│   │           ├── KycUtils.kt
│   │           └── KycViewModel.kt
│   ├── lock/
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── AppLocker.kt
│   │           ├── LockScreen.kt
│   │           ├── LockSetupScreen.kt
│   │           └── PinUnlockScreen.kt
│   ├── payments/
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── AccountSelector.kt
│   │           ├── common.kt
│   │           ├── DepositScreen.kt
│   │           ├── PaymentReceiptScreen.kt
│   │           ├── PaymentReviewScreen.kt
│   │           ├── PaymentsPicker.kt
│   │           ├── PaymentsRoute.kt
│   │           ├── TransferScreen.kt
│   │           └── WithdrawScreen.kt
│   ├── profile/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   │   └── UserProfile.kt
│   │   │   └── repository/
│   │   │       └── ProfileRepository.kt
│   │   ├── integration/
│   │   │   ├── remote/
│   │   │   │   ├── api/
│   │   │   │   │   └── ProfileApi.kt
│   │   │   │   └── dto/
│   │   │   │       ├── UserProfileDto.kt
│   │   │   │       └── UserProfileDtoMapper.kt
│   │   │   └── repository/
│   │   │       └── ProfileRepositoryImpl.kt
│   │   └── interfaces/
│   │       └── ui/
│   │           ├── ChangePasswordDialog.kt
│   │           ├── EditableField.kt
│   │           ├── PasswordVerificationDialog.kt
│   │           ├── ProfileRoute.kt
│   │           ├── ProfileScreen.kt
│   │           └── ProfileViewModel.kt
│   ├── settings/
│   │   └── interfaces/
│   │       └── ui/
│   │           └── SettingsScreen.kt
│   ├── splash/
│   │   ├── application/
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   └── repository/
│   │   ├── integration/
│   │   │   └── remote/
│   │   │       ├── api/
│   │   │       └── dto/
│   │   └── interfaces/
│   │       └── ui/
│   │           └── AnimatedSplashScreen.kt
│   └── wallet/
│       ├── application/
│       ├── domain/
│       │   ├── model/
│       │   │   └── WalletModels.kt
│       │   └── repository/
│       │       └── WalletRepository.kt
│       ├── integration/
│       │   ├── api/
│       │   │   └── WalletApi.kt
│       │   ├── remote/
│       │   │   └── dto/
│       │   │       └── WalletDtos.kt
│       │   └── repository/
│       │       └── WalletRepositoryImpl.kt
│       ├── interfaces/
│       │   └── ui/
│       │       ├── components/
│       │       │   ├── CopyableField.kt
│       │       │   ├── EmptyState.kt
│       │       │   ├── ErrorBanner.kt
│       │       │   ├── SavedCardChip.kt
│       │       │   ├── ShimmerBox.kt
│       │       │   └── StatusPill.kt
│       │       ├── objects/
│       │       │   ├── WalletStrings.kt
│       │       │   └── WalletUiTokens.kt
│       │       ├── AddCardScreen.kt
│       │       ├── BillerPayScreen.kt
│       │       ├── BillersListScreen.kt
│       │       ├── CardListScreen.kt
│       │       ├── CardsViewModel.kt
│       │       ├── common.kt
│       │       ├── MobileReloadScreen.kt
│       │       ├── PaymentResultScreen.kt
│       │       ├── ProcessingScreen.kt
│       │       ├── QrPayConfirmScreen.kt
│       │       ├── QrPayScanScreen.kt
│       │       ├── WalletHomeScreen.kt
│       │       └── WalletRoute.kt
│       └── collect_text_and_tree.py
├── App.kt
├── code.txt
├── collect_text_and_tree.py
├── local.properties
└── MainActivity.kt

================================================================================
SUMMARY
================================================================================
Text files written : 158
Non-text/omitted   : 0
Total files seen   : 158
